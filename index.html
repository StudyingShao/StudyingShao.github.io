<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="邵大宝的学习Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="邵大宝的学习Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jiang Shao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>邵大宝的学习Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">邵大宝的学习Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">最爱严小跳</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/GAMES101-RayTracing-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/GAMES101-RayTracing-2/" class="post-title-link" itemprop="url">GAMES101-RayTracing-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-28 17:21:15" itemprop="dateCreated datePublished" datetime="2022-02-28T17:21:15+08:00">2022-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/GAMES101-Geometry-Assignment4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/GAMES101-Geometry-Assignment4/" class="post-title-link" itemprop="url">GAMES101 Geometry Assignment4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-28 14:23:33 / Modified: 17:37:52" itemprop="dateCreated datePublished" datetime="2022-02-28T14:23:33+08:00">2022-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-Geometry-Assignment4"><a href="#GAMES101-Geometry-Assignment4" class="headerlink" title="GAMES101 Geometry Assignment4"></a>GAMES101 Geometry Assignment4</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7f10f51bce47">hexo 博客添加pdf 插件1</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/111452a36e94">hexo 博客添加pdf 插件2</a></p>
<ol>
<li>安装插件<br>npm install —save hexo-pdf</li>
<li>在md文件中添加pdf</li>
</ol>
</blockquote>
<p>作业要求：<br><div class="pdfobject-container" data-target="pdf/assignment4.pdf" data-height="500px"></div></p>
<object data="GAMES101-Geometry-Assignment4/assignment4.pdf" type="application/pdf" width="50%" height="50%">

<h2 id="cv-Mat数据类型"><a href="#cv-Mat数据类型" class="headerlink" title="cv::Mat数据类型"></a>cv::Mat数据类型</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/czsnooker/article/details/118345494">OpenCV基础类型4—cv::Mat详解</a><br>cv::Mat是OpenCV定义的用于表示任意维度的稠密数组，OpenCV使用它来存储和传递图像。</p>
<p>由于cv::Mat要用于存储图像，它里面的元素可以是“像素”，对于像素，OpenCV定义了专门的数据格式来描述它们。<br>基本数据类型 + 通道数<br>CV_{8U, 16S, 16U, 32S, 32F, 64F}C{1, 2, 3}</p>
<p>数据类型前面的数字，对应数据类型的bit数。<br>8U:unsigned char;<br>16S: short int;<br>16U: unsigned short int;<br>32F: float;<br>64F: double.</p>
<p>{1，2，3}代表通道数。<br>彩色图像每个像素需要存储B、G、R（蓝、绿、红）3个信息，需要3个位置， 每一个称为一个“颜色通道”。<br>灰度图像无颜色，只有一个通道，故常为CV_8UC1。由黑到白。</p>
<p>作业中cv::Mat构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat window = cv::<span class="built_in">Mat</span>(<span class="number">700</span>, <span class="number">700</span>, CV_8UC3, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><br>对应图像高（行数）700-row，宽（列数）700-col， 数据类型：CV_8UC3（unsigned char，彩色三通道），初始值为cv::Scalar(0)代表纯黑色。</p>
<p><strong>访问元素</strong><br>直接访问，使用模板函数at&lt;&gt;()</p>
<p>单通道, 尖括号里面的类型照着文章开头介绍的类型对应关系输入<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里数据类型为CV_32FC1，对应float，单通道，所以使用at&lt;float&gt;</span></span><br><span class="line">cv::Mat img = cv::Mat::<span class="built_in">ones</span>(<span class="number">240</span>, <span class="number">320</span>, CV_32FC1);</span><br><span class="line"><span class="type">float</span> elem = img.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>多通道，Vec3b代表固定向量类。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/czsnooker/article/details/118314514?spm=1001.2014.3001.5501">利用固定向量类访问</a><br>OpenCV中固定向量模板类cv::Vec&lt;&gt;别名命名规则：<br>cv::Vec{2,3,4,6}{b, s ,w , i, f, d}<br>{2,3,4,6}代表向量的长度。<br>{b, s ,w , i, f, d}表示向量内数据类型。分别对应：<br>b：unsigned char;<br>s：short int;<br>w：unsigned short;<br>i：int;<br>f：float;<br>d：double.</p>
<p>注意类型之间的对应，固定向量与Mat的代表字母有一点差异<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cv::Mat元素类型CV_8UC3，对应unsigned char彩色三通道，因此使用固定向量类型cv::Vec3b，长度3向量，数据类型unsigned char</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">img1</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, CV_8UC3, cv::Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">cv::Vec3b elem = img1.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">elem_B = elem[<span class="number">0</span>]; <span class="comment">//蓝色通道数值---255</span></span><br><span class="line">elem_G = elem[<span class="number">1</span>]; <span class="comment">//绿色通道数值---255</span></span><br><span class="line">elem_R = elem[<span class="number">2</span>]; <span class="comment">//红色通道---0</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>要求你的实现将Bézier 曲线绘制为绿色。</p>
</blockquote>
<p>绿色对应RGB(0, 255, 0)。</p>
<h2 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t_step 0.001f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTROL_POINTS_NUM 6</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;cv::Point2f&gt; control_points;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_handler</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span> *userdata)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event == cv::EVENT_LBUTTONDOWN &amp;&amp; control_points.<span class="built_in">size</span>() &lt; CONTROL_POINTS_NUM) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Left button of the mouse is clicked - position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">        &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        control_points.<span class="built_in">emplace_back</span>(x, y);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">naive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_0 = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_1 = points[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_2 = points[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_3 = points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> point = std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">3</span>) * p_0 + <span class="number">3</span> * t * std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">2</span>) * p_1 +</span><br><span class="line">                 <span class="number">3</span> * std::<span class="built_in">pow</span>(t, <span class="number">2</span>) * (<span class="number">1</span> - t) * p_2 + std::<span class="built_in">pow</span>(t, <span class="number">3</span>) * p_3;</span><br><span class="line"></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> result = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span></span><br><span class="line">    <span class="function">cv::Point2f <span class="title">point_</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = control_points.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//贝塞尔曲线阶数为控制点个数-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//伯恩斯坦多项式</span></span><br><span class="line">        <span class="type">float</span> Bni = <span class="built_in">Factorial</span>(n) / <span class="built_in">Factorial</span>(i) / <span class="built_in">Factorial</span>(n - i) * <span class="built_in">powf</span>(t, i) * <span class="built_in">pow</span>(<span class="number">1</span> - t, n - i);</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; Bni &lt;&lt; std::endl;</span></span><br><span class="line">        point_ += Bni * control_points[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> point_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0</span>; t &lt; <span class="number">1</span>; t+=t_step)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Point2f point_ = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point_.y, point_.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat window = cv::<span class="built_in">Mat</span>(<span class="number">700</span>, <span class="number">700</span>, CV_8UC3, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));<span class="comment">//黑色屏幕</span></span><br><span class="line">    <span class="comment">//cv::Mat window = cv::Mat(700, 700, CV_8UC3, cv::Scalar(0,255,0));//绿色屏幕</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(window, window, cv::COLOR_BGR2RGB);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Bezier Curve&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">setMouseCallback</span>(<span class="string">&quot;Bezier Curve&quot;</span>, mouse_handler, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (key != <span class="number">27</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point : control_points) </span><br><span class="line">        &#123;</span><br><span class="line">            cv::<span class="built_in">circle</span>(window, point, <span class="number">3</span>, &#123;<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>&#125;, <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (control_points.<span class="built_in">size</span>() == CONTROL_POINTS_NUM) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//naive_bezier(control_points, window);</span></span><br><span class="line">            <span class="built_in">bezier</span>(control_points, window);</span><br><span class="line"></span><br><span class="line">            cv::<span class="built_in">imshow</span>(<span class="string">&quot;Bezier Curve&quot;</span>, window);</span><br><span class="line">            cv::<span class="built_in">imwrite</span>(<span class="string">&quot;my_bezier_curve.png&quot;</span>, window);</span><br><span class="line">            key = cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Bezier Curve&quot;</span>, window);</span><br><span class="line">        key = cv::<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></object>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/25/GAMES101-Geometry-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/GAMES101-Geometry-1/" class="post-title-link" itemprop="url">GAMES101 Geometry part1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 17:05:59" itemprop="dateCreated datePublished" datetime="2022-02-25T17:05:59+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 14:24:03" itemprop="dateModified" datetime="2022-02-28T14:24:03+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-Geometry-part1"><a href="#GAMES101-Geometry-part1" class="headerlink" title="GAMES101 Geometry part1"></a>GAMES101 Geometry part1</h1><p><strong>表示几何形状的方式：</strong></p>
<p>隐式表示：</p>
<ol>
<li>algebraic surface 代数曲面</li>
<li>level set 水平集</li>
<li>distance functions 距离函数</li>
<li>…</li>
</ol>
<p>显式表示：</p>
<ol>
<li>point cloud 点云</li>
<li>polygon mesh 多边形网格</li>
<li>subdivision, NURBS 样条曲线</li>
<li>…</li>
</ol>
<p><strong>隐式表示</strong>基于对点的划分。所有的点满足特定的关系。<br>缺点：Sampling Can Be Hard，由于只知道点所满足的关系，因此想要知道组成几何的点比较困难。<br>优点：Inside/Outside Tests Easy，判断空间中一个点是否在曲面内很容易，直接代入到几何的约束关系中。</p>
<p><strong>显示表示</strong>是直接给出所有组成几何的点，或者依据参数映射给出所有点。<br>优点：Sampling Is Easy<br>缺点：Inside/Outside Test Hard</p>
<h2 id="Implicit-Representations-in-Computer-Graphics-计算机图形学中几何的隐式表示方法"><a href="#Implicit-Representations-in-Computer-Graphics-计算机图形学中几何的隐式表示方法" class="headerlink" title="Implicit Representations in Computer Graphics 计算机图形学中几何的隐式表示方法"></a>Implicit Representations in Computer Graphics 计算机图形学中几何的隐式表示方法</h2><h3 id="Algebraic-Surfaces-Implicit-代数表面"><a href="#Algebraic-Surfaces-Implicit-代数表面" class="headerlink" title="Algebraic Surfaces (Implicit) 代数表面"></a>Algebraic Surfaces (Implicit) 代数表面</h3><p>Surface is zero set of a polynomial in x, y, z.<br>表面为多项式的零集。（使得一个多项式等于0的所有值的集合）</p>
<p>${ {x}^{2} }+{ {y}^{2} }+{ {z}^{2} }-1=0$<br>${ {\left( R-\sqrt{ { {x}^{2} }+{ {y}^{2} } } \right)}^{2} }+{ {z}^{2} }-{ {r}^{2} }=0$<br>${ {\left( { {x}^{2} }+\frac{9}{4}{ {y}^{2} }+{ {z}^{2} }-1 \right)}^{3} }-{ {x}^{2} }{ {z}^{3} }-\frac{9}{80}{ {y}^{2} }{ {z}^{3} }=0$</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/1.png" width="100%" height="100%"></center>

<h3 id="Constructive-Solid-Geometry-Implicit-构造实体几何"><a href="#Constructive-Solid-Geometry-Implicit-构造实体几何" class="headerlink" title="Constructive Solid Geometry (Implicit) 构造实体几何"></a>Constructive Solid Geometry (Implicit) 构造实体几何</h3><p>Combine implicit geometry via Boolean operations.<br>通过布尔运算构造几何。并集、交集、差集</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/2.png" width="100%" height="100%"></center>

<h3 id="Distance-Functions-Implicit-距离函数"><a href="#Distance-Functions-Implicit-距离函数" class="headerlink" title="Distance Functions (Implicit) 距离函数"></a>Distance Functions (Implicit) 距离函数</h3><p>Gradually blend surfaces together using Distance functions. 使用距离函数逐渐混合表面。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/3.png" width="100%" height="100%"><img src="/2022/02/25/GAMES101-Geometry-1/3_1.png" width="100%" height="100%"></center>

<p><strong>Distance functions: 距离函数</strong><br>giving minimum distance (could be signed distance)<br>from anywhere to object.<br>给出任意位置到物体的最小距离（垂直于表面），可以是有符号的距离，为负代表在物体内部。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/4.png" width="100%" height="100%"></center>

<p>逐渐混合的原理是，如图例所示，对于区域中一个边界来说，边界左侧为负（视为边界内部）右侧为正（视为边界外部）。<strong>SDF为0代表边界</strong>，图AB正负所占区域各不相同，blend之后相当于对AB中边界的一个线性插值（对0的位置的插值）。</p>
<h3 id="Level-Set-Methods-implicit-水平集"><a href="#Level-Set-Methods-implicit-水平集" class="headerlink" title="Level Set Methods (implicit) 水平集"></a>Level Set Methods (implicit) 水平集</h3><p>对于复杂形状来说，描述边界的方程很难得到，因此对空间进行采样，给出空间中各个点的距离值。这样边界就可以通过插值方式得到（距离为0的地方）。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/5.png" width="100%" height="100%"></center>

<h3 id="Fractals-Implicit-分形"><a href="#Fractals-Implicit-分形" class="headerlink" title="Fractals (Implicit) 分形"></a>Fractals (Implicit) 分形</h3><p>Exhibit self-similarity, detail at all scales.<br>自相似特性 </p>
<h3 id="隐式描述几何形状的优缺点"><a href="#隐式描述几何形状的优缺点" class="headerlink" title="隐式描述几何形状的优缺点"></a>隐式描述几何形状的优缺点</h3><p>优点：</p>
<ol>
<li>紧凑的表示方法（比如一个函数）</li>
<li>对于特定的查询非常方便（比如在物体内外、点到边界的距离）</li>
<li>方便表面与光线求交点</li>
<li>对于一些简单形状，描述准确、无采样误差</li>
<li>易于处理拓扑结构的变化（比如流体：拓扑结构多变且多样）</li>
</ol>
<p>缺点：</p>
<ol>
<li>对复杂形状来说隐式描述相对困难</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/25/GAMES101-Geometry-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/GAMES101-Geometry-2/" class="post-title-link" itemprop="url">GAMES101 Geometry part2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 17:03:43" itemprop="dateCreated datePublished" datetime="2022-02-25T17:03:43+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 14:24:13" itemprop="dateModified" datetime="2022-02-28T14:24:13+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-Geometry-part2"><a href="#GAMES101-Geometry-part2" class="headerlink" title="GAMES101 Geometry part2"></a>GAMES101 Geometry part2</h1><h2 id="Explicit-Representations-in-Computer-Graphics-计算机图形学中几何的显式表示方法"><a href="#Explicit-Representations-in-Computer-Graphics-计算机图形学中几何的显式表示方法" class="headerlink" title="Explicit Representations in Computer Graphics 计算机图形学中几何的显式表示方法"></a>Explicit Representations in Computer Graphics 计算机图形学中几何的显式表示方法</h2><p><strong>Curves</strong></p>
<ul>
<li>Bezier curves 贝塞尔曲线<br>— De Casteljau’s algorithm 德卡斯特里奥算法</li>
<li>B-splines, etc. B样条曲线</li>
</ul>
<p><strong>Surfaces</strong></p>
<ul>
<li>Bezier surfaces 贝塞尔曲面</li>
<li>Triangles &amp; quads 三角形网格与四边形网格<br>— Subdivision, simplification, regularization 细化，粗化，正则化</li>
</ul>
<h3 id="Point-Cloud-Explicit-点云"><a href="#Point-Cloud-Explicit-点云" class="headerlink" title="Point Cloud (Explicit) 点云"></a>Point Cloud (Explicit) 点云</h3><ol>
<li>Easiest representation: list of points (x,y,z)<br>最简单的表示方法，点列表</li>
<li>Easily represent any kind of geometry<br>很容易表示任何形状</li>
<li>Useful for LARGE datasets (&gt;&gt;1 point/pixel)<br>适用于于大型数据集，每个像素都有远大于1个点</li>
<li>Often converted into polygon mesh<br>经常被转化为多边形网络</li>
<li>Difficult to draw in undersampled regions<br>对采样不足的区域很难绘制（指点比较稀疏的区域，每个像素包含的点太少、甚至可能没有）</li>
</ol>
<center><img src="/2022/02/25/GAMES101-Geometry-2/1.png" width="50%" height="50%"></center>

<h3 id="Polygon-Mesh-Explicit-多边形网络"><a href="#Polygon-Mesh-Explicit-多边形网络" class="headerlink" title="Polygon Mesh (Explicit) 多边形网络"></a>Polygon Mesh (Explicit) 多边形网络</h3><ol>
<li>Store vertices &amp; polygons (often triangles or quads)<br>存储顶点和多边形（三角形、四边形居多）</li>
<li>Easier to do processing / simulation, adaptive sampling<br>易于处理、模拟、自适应采样</li>
<li>More complicated data structures<br>更复杂的数据结构</li>
<li>Perhaps most common representation in graphics<br>图形学中目前最常用的表示方法</li>
</ol>
<center><img src="/2022/02/25/GAMES101-Geometry-2/2.png" width="100%" height="100%"></center>

<h4 id="The-Wavefront-Object-File-obj-Format"><a href="#The-Wavefront-Object-File-obj-Format" class="headerlink" title="The Wavefront Object File (.obj) Format"></a>The Wavefront Object File (.obj) Format</h4><p>描述多边形网格的文件格式。<br>Commonly used in Graphics research.<br>Just a text file that specifies vertices, normals, texture<br>coordinates and their connectivities.<br>是一个txt文件，指定了多边形网络的<strong>顶点</strong>、<strong>法线</strong>、<strong>纹理坐标</strong>与<strong>顶点之间的连接关系</strong>。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/3.png" width="100%" height="100%"></center>

<p>文件中：<br>v代表vertices顶点坐标<br>vt代表各个顶点对应的纹理坐标<br>vn代表各个顶点对应的法线方向<br>f则代表face，指顶点之间的连接方式从而组成一个面，格式为v/vt/vn</p>
<h3 id="Bezier-Curves-贝塞尔曲线"><a href="#Bezier-Curves-贝塞尔曲线" class="headerlink" title="Bézier Curves 贝塞尔曲线"></a>Bézier Curves 贝塞尔曲线</h3><p>Defining Cubic Bézier Curve With Tangents<br>使用切线定义三次贝塞尔曲线</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/4.png" width="70%" height="70%"></center>

<p>P为一系列控制点，用于定义曲线。指明了曲线要满足的一些性质。</p>
<ol>
<li>曲线由P0开始，到P3结束</li>
<li>在P0处曲线沿着P0P1为切线，切线长度为t0</li>
<li>在P3处曲线沿着P2P3为切线，切线程度为t1</li>
</ol>
<h4 id="de-Casteljau-Algorithm"><a href="#de-Casteljau-Algorithm" class="headerlink" title="de Casteljau Algorithm"></a>de Casteljau Algorithm</h4><p>用于绘制贝塞尔曲线</p>
<p>Consider three points (quadratic Bezier)<br>考虑三个控制点的情况（二次贝塞尔曲线）</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/5_1.png" width="50%"><img src="/2022/02/25/GAMES101-Geometry-2/5_2.png" width="50%"></center>

<p>三次线性插值，根据同一个t得到对应位置。<br>$b_{0}^{1}={ {b}_{0} }+({ {b}_{1} }-{ {b}_{0} })<em>t$<br>$b_{1}^{1}={ {b}_{1} }+({ {b}_{2} }-{ {b}_{1} })</em>t$<br>$b_{0}^{2}=b_{0}^{1}+(b_{1}^{1}-b_{0}^{1})*t$</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45333934/article/details/108274320">公式渲染错误：Nunjucks Error 解决方案</a></p>
<script type="math/tex; mode=display">b_{0}^{2}={ {(1-t)}^{2} }{ {b}_{0} }+2t(1-t){ {b}_{1} }+{ {t}^{2} }{ {b}_{2} }</script><p>Four input points in total (Cubic Bézier Curve)<br>相同的递归线性插值</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/9.png" width="90%"></center>

<center><img src="/2022/02/25/GAMES101-Geometry-2/6.png" width="100%"></center>
<center><img src="/2022/02/25/GAMES101-Geometry-2/7.png" width="50%"><img src="/2022/02/25/GAMES101-Geometry-2/7_2.png" width="50%"></center>

<p><strong>通用贝塞尔曲线公式</strong><br><strong>Bernstein polynomial 伯恩斯坦多项式</strong></p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/8.png" width="50%"></center>

<script type="math/tex; mode=display">\left( \begin{align}
  & n \nonumber \\
 & i \nonumber \\
\end{align} \right)=\frac{n!}{i!(n-i)!}</script><p><strong>Bernstein form of a Bézier curve of order n:</strong><br><strong>n阶贝塞尔曲线伯恩斯坦形式（n+1个控制点）：</strong></p>
<script type="math/tex; mode=display">{ {b}^{n} }(t)=\sum\limits_{i=0}^{n}{ { {b}_{i} }B_{i}^{n}(t)}</script><center><img src="/2022/02/25/GAMES101-Geometry-2/11.png" width="50%"></center>
伯恩斯坦多项式在t的任何位置，各个多项式的和都为1，是对所有控制点的线性插值。可以看到在t=0和1的位置，多项式其他项都是0，只有首项/末项为1，对应插值结果为首个/最后一个控制点。

#### Properties of Bézier Curves 贝塞尔曲线特性

1. Interpolates endpoints 插值端点
   曲线端点为首末控制点，对于3次贝塞尔曲线，曲线端点为b0, b3
2. Tangent to end segments 
   曲线在首末位置正切于控制点组成的线段，同上${b}'(0)=3({ {b}_{1} }-{ {b}_{0} })$, ${b}'(1)=3({ {b}_{3} }-{ {b}_{2} })$括号中为插值变量t。系数3只是因为三阶曲线有四个控制点，其他阶数并不严格是3。
3. Affine transformation property 
   Transform curve by transforming control points
   对控制点进行仿射变换，再使用变换后的控制点绘制贝塞尔曲线，与直接对贝塞尔曲线进行仿射变换等效。（仅对仿射变换有效，对投影等变换无效）
4. Convex hull property 凸包性质
   Curve is within convex hull of control points
   贝塞尔曲线一定在控制点所围成的凸包内（凸包，板上钉钉子，用个橡皮筋围一下，都是凸角）
<center><img src="/2022/02/25/GAMES101-Geometry-2/12.png" width="50%"></center>
<center><font color="#708090" size="2">10阶贝塞尔曲线，11个控制点。</font></center>

<h4 id="Piecewise-Bezier-Curves-分段贝塞尔曲线"><a href="#Piecewise-Bezier-Curves-分段贝塞尔曲线" class="headerlink" title="Piecewise Bézier Curves 分段贝塞尔曲线"></a>Piecewise Bézier Curves 分段贝塞尔曲线</h4><p>对于高阶贝塞尔曲线来说，要控制曲线的形状非常困难，控制点之间都是互相耦合的。因此要实现一个较长的贝塞尔曲线，可以将低阶的贝塞尔曲线连接起来实现 -&gt; Piecewise Bézier Curves。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/13.png" width="50%"></center>
<center><font color="#708090" size="2">Piecewise Bézier Curves.</font></center>

<p>逐段贝塞尔曲线：每四个控制点，定义一段三阶贝塞尔曲线。对于图中第一段来说，控制点为1234，曲线起止与14控制点。</p>
<h5 id="Piecewise-Bezier-Curve-–-Continuity-连续性"><a href="#Piecewise-Bezier-Curve-–-Continuity-连续性" class="headerlink" title="Piecewise Bézier Curve – Continuity 连续性"></a>Piecewise Bézier Curve – Continuity 连续性</h5><p>如何使两端曲线连接处光滑，起止点连接（值连续），起止点处切线方向一致，且切线大小相同（导数连续）。</p>
<p><strong>C0连续</strong>：起止点连接</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/14.png" width="100%"></center>

<p><strong>C1连续</strong>：切线连续，两端切线方向相反，长度相同。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/15.png" width="100%"></center>

<h3 id="Bezier-Surfaces-贝塞尔曲面"><a href="#Bezier-Surfaces-贝塞尔曲面" class="headerlink" title="Bézier Surfaces 贝塞尔曲面"></a>Bézier Surfaces 贝塞尔曲面</h3><center><img src="/2022/02/25/GAMES101-Geometry-2/16.png" width="100%"></center>
<center><font color="#708090" size="2">Bicubic Bézier Surface Patch.</font></center>

<p>通过双线性插值方法得到，双三次贝塞尔曲面，一共4*4个控制点。</p>
<ol>
<li>每行拿出四个控制点，在所有时间u上插值，得到一条贝塞尔曲线。</li>
<li>在每个时间u，又能在对应四条贝塞尔曲线上得到四个曲线上的点。</li>
<li>在每个时间u，以这四个点为控制点，在所有时间v上插值，又能画出一条贝塞尔曲线，则不同时间u的这条曲线构成了一个贝塞尔曲面。</li>
<li>对应两个插值时间(u, v)，这两个参数可以映射到曲面上的每个点，参数映射-&gt;所以贝塞尔曲面是显示表示方法。</li>
</ol>
<center><img src="/2022/02/25/GAMES101-Geometry-2/17.png" width="100%"></center>
<center><img src="/2022/02/25/GAMES101-Geometry-2/18.png" width="100%"></center>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/25/GAMES101-Geometry-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/GAMES101-Geometry-3/" class="post-title-link" itemprop="url">GAMES101 Geometry part3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 17:02:43" itemprop="dateCreated datePublished" datetime="2022-02-25T17:02:43+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 17:01:37" itemprop="dateModified" datetime="2022-02-28T17:01:37+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-Geometry-part3"><a href="#GAMES101-Geometry-part3" class="headerlink" title="GAMES101 Geometry part3"></a>GAMES101 Geometry part3</h1><ol>
<li>mesh subdivision 网格细化</li>
<li>mesh simplification 网格粗化</li>
<li>mesh regularization 网格正则化，使三角形趋于一致</li>
</ol>
<h2 id="Mesh-Subdivision"><a href="#Mesh-Subdivision" class="headerlink" title="Mesh Subdivision"></a>Mesh Subdivision</h2><p>两步操作：</p>
<ol>
<li>创建更多的三角形</li>
<li>移动这些三角形的位置</li>
</ol>
<h3 id="Loop-Subdivision-与循环无关，发明人叫Loop，仅适用于三角形网格"><a href="#Loop-Subdivision-与循环无关，发明人叫Loop，仅适用于三角形网格" class="headerlink" title="Loop Subdivision (与循环无关，发明人叫Loop，仅适用于三角形网格)"></a>Loop Subdivision (与循环无关，发明人叫Loop，仅适用于三角形网格)</h3><p>连接三角形三条边的中点，则原本的一个三角形转变为四个。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/1.png" width="100%" height="100%"></center>

<p><strong>新顶点</strong>和<strong>原有顶点</strong>具有不同的更新策略。（区分为两类）</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/2.png" width="100%" height="100%"></center>

<p>其中新顶点的更新要考虑到新顶点所在边所对应的两个三角形。AB为新顶点所在边，被两个三角形共有。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/3.png" width="100%" height="100%"></center>

<p>对于旧顶点，由于顶点是位于三角形顶点上的，因此会被多个三角形共有，其值的更新就要考虑到周围所有的三角形。n指顶点的度，也就是顶点所连接的边的数量，对应有多少个相邻顶点。u为一个与n有关的值。从公式看，除了相邻顶点，旧顶点值的更新还需用到自身的值，权重为(1-n*u)。而周围点权重为u*n，n体现在sum中。</p>
<h3 id="Catmull-Clark-Subdivision（General-Mesh，任意网格都适用）"><a href="#Catmull-Clark-Subdivision（General-Mesh，任意网格都适用）" class="headerlink" title="Catmull-Clark Subdivision（General Mesh，任意网格都适用）"></a>Catmull-Clark Subdivision（General Mesh，任意网格都适用）</h3><p>引入概念：<br>奇异点extraordinary vertex：度不为4的点（连接边数不为4）</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/4.png" width="100%" height="100%"></center>

<p>连接每个面的中点与每条边的中点。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/5.png" width="100%" height="100%"></center>

<p>得到的新网格有两个特性。</p>
<ol>
<li>得到的所有面均为四边形面，所有的非四边形面全部消失。</li>
<li>原来的奇异点不变，其对应的度也不变。（连接面中点与边中点，与这个顶点无关）</li>
<li>新增加的奇异点的数量等于原来非四边形面的数量。（多边形每条边都与面中点相连，中点的度就等于多边形的边数）</li>
<li>由于做完一次Catmull-Clark Subdivision后，所有面均为四边形面。因此下一次再做Catmull-Clark Subdivision后，奇异点数量不变。</li>
</ol>
<center><img src="/2022/02/25/GAMES101-Geometry-3/6_1.png" width="50%" height="50%"><img src="/2022/02/25/GAMES101-Geometry-3/6_2.png" width="50%" height="50%"></center>

<p>细分之后点被分为三类，各自对应不同的update policy。<br>新点：1面中点、2边中点，3旧顶点。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/7.png" width="100%" height="100%"></center>

<h2 id="Mesh-Simplification"><a href="#Mesh-Simplification" class="headerlink" title="Mesh Simplification"></a>Mesh Simplification</h2><ol>
<li>减少三角形的数量</li>
<li>保持整体形状</li>
</ol>
<h3 id="Edge-Collapse-边坍缩"><a href="#Edge-Collapse-边坍缩" class="headerlink" title="Edge Collapse 边坍缩"></a>Edge Collapse 边坍缩</h3><p>把一条边的两个顶点捏在一起，使一条边消失。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/8.png" width="100%" height="100%"></center>

<p>两个问题：</p>
<ol>
<li>坍缩后的顶点应该取在哪？</li>
<li>应该坍缩网格中的哪些边？</li>
</ol>
<p>对于第一个问题，如果仅仅取坍缩边顶点的平均值，如图所示，显而易见的并不能很好地保留原先的形状。所以引入一个度量<br><strong>Quadric Error Metrics 二次误差度量</strong><br>到坍缩前相关的各个面的square distance (L2 distance)的和最小的点，作为新顶点。<br>square distance (L2 distance)：指欧几里德距离，直线距离。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-3/9.png" width="100%" height="100%"></center>

<p>对于第二个问题，应该坍缩哪些边？<br>最终目的是尽可能地保持原有形状，那么就先对每条边，计算坍缩对应边之后，新顶点的Quadric Error Metrics二次误差度量。从小到大开始坍缩。<br>带来的新问题：每次坍缩会影响周围其他边的二次误差度量。-&gt;每次坍缩完一条边之后，更新受到影响的边的二次误差度量。<br>那么就需要一种数据结构，除了能提供当前极值之外，还得能动态地以最小代价修改任意元素（快速搜索，快速增删）。-&gt;堆（优先级队列）<br>这种做法得到的其实不是全局最优解，而是每一次都取<strong>局部最优解</strong>（每次坍缩当前二次误差度量最小的边），是一种<strong>贪心算法</strong>，能得到近似最优解。</p>
<blockquote>
<h4 id="优先级队列-priority-queue"><a href="#优先级队列-priority-queue" class="headerlink" title="优先级队列 priority queue"></a>优先级队列 priority queue</h4><p>最高优先级元素先出。</p>
<ol>
<li>非线性数据结构，由完全二叉树构造而成，完全二叉树可由一维数组实现。</li>
<li>堆中某个节点的值，总是不大于/不小于其父节点的值</li>
<li>大顶堆（根节点最大），小顶堆（根节点最小）</li>
</ol>
<p>由于堆是由完全二叉树构造而成，因此除了堆本身的性质（能快速提供最大值/最小值）之外，还具备二叉树的优点（二叉树具备了数组和链表的优点：快速查找，支持动态插入/删除）。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/25/GAMES101-RayTracing-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/GAMES101-RayTracing-1/" class="post-title-link" itemprop="url">GAMES101_RayTracing_1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 16:44:37" itemprop="dateCreated datePublished" datetime="2022-02-25T16:44:37+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 14:24:23" itemprop="dateModified" datetime="2022-02-28T14:24:23+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-RayTracing"><a href="#GAMES101-RayTracing" class="headerlink" title="GAMES101 RayTracing"></a>GAMES101 RayTracing</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/23/cuda-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/cuda-6/" class="post-title-link" itemprop="url">CUDA学习随记6 Asynchronous Barrier</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-23 21:41:50 / Modified: 22:04:22" itemprop="dateCreated datePublished" datetime="2022-02-23T21:41:50+08:00">2022-02-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CUDA学习随记6-Asynchronous-Barrier"><a href="#CUDA学习随记6-Asynchronous-Barrier" class="headerlink" title="CUDA学习随记6 Asynchronous Barrier"></a>CUDA学习随记6 Asynchronous Barrier</h1><p><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/06/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e/">CUDA, 软件抽象的幻影背后</a><br><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/08/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%ba%8c/">CUDA, 软件抽象的幻影背后 之二</a><br><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/13/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%b8%89/">CUDA, 软件抽象的幻影背后 之三</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#aw-barrier">CUDA C++ Programming Guide: B.25. Asynchronous Barrier</a><br><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-mbarrier">PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/22/cuda-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/cuda-5/" class="post-title-link" itemprop="url">CUDA学习随记5 Asynchronous copy cp.async</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-22 21:51:12" itemprop="dateCreated datePublished" datetime="2022-02-22T21:51:12+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-23 20:47:52" itemprop="dateModified" datetime="2022-02-23T20:47:52+08:00">2022-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CUDA学习随记5-Asynchronous-copy-cp-async"><a href="#CUDA学习随记5-Asynchronous-copy-cp-async" class="headerlink" title="CUDA学习随记5 Asynchronous copy cp.async"></a>CUDA学习随记5 Asynchronous copy cp.async</h1><p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-asynchronous-copy">1. PTX (Parallel Thread Execution) ISA (Instruction Set Architecture)</a><br><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html">2. CUDA Binary Utilities (用于查询SASS code)</a></p>
<p>An asynchronous copy operation copies data from one state space to another asynchronously without blocking the executing thread.<br>Initiation of an asynchronous copy operation simply dispatches the copy operation from the source memory location to the destination memory location.<br>异步拷贝，不阻塞线程，仅发起一个异步拷贝请求。</p>
<p>There are two ways to wait for the completion of an asynchronous copy operation:<br>两种方式等待异步拷贝操作完成：</p>
<ol>
<li>使用<strong>cp.async-groups</strong><br>a. Initiate asynchronous copy operations.<br>b. Commit copy operations into a cp.async-group. cp.async.commit_group<br>c. Wait for cp.async-group to complete the copy. cp.async.wait_group<br>d. Once the cp.async-group completes, the writes performed by the copy operation in that cp.async-group are made visible to the thread that initiated the copy operations.</li>
<li>使用<strong>mbarrier</strong>对象<br>a. Initiate asynchronous copy operations.<br>b. Make an mbarrier object track the asynchronous copy operations.<br>c. Wait for the mbarrier object to complete the phase using mbarrier.test_wait.<br>d. Once mbarrier.test_wait returns True, the writes performed by the copy operation are made visible to all the threads which waited on the mbarrier object.</li>
</ol>
<p>A sequence of asynchronous copy operations initiated by a thread can be batched into a per-thread group referred to as cp.async-group.<br>由单个线程发出的一系列异步拷贝操作可以打包为a per-thread group，称为cp.async-group。</p>
<p>A commit operation creates a cp.async-group containing all prior asynchronous copy operations initiated by the executing thread but none of the asynchronous copy operations following the commit operation. A committed asynchronous copy operation belongs to a single cp.async-group.<br>创建一个cp.async-group将包含所有由本线程发出的之前的异步拷贝操作，不包括之后的。每个异步拷贝操作仅属于一个cp.async-group。<br>由于执行到cp.async-group时，其之前的所有异步拷贝操作均已完成，因此下一个cp.async-group仅包含两条cp.async-group之间的新发出的异步拷贝操作，所以说每个异步拷贝操作仅属于一个cp.async-group。</p>
<p>When a cp.async-group completes, all the asynchronous copy operations belonging in that group are complete and the executing thread that initiated copy operations can read copied results. All cp.async-groups committed by an executing thread always complete in the order in which they were committed. There is no ordering between asynchronous copy operations within a cp.async-group.<br>当cp.async-group完成时，其所包含的所有异步拷贝操作均已完成，发出异步拷贝请求的线程（也就是当前线程）可以安全读取拷贝结果。线程发射的cp.async-groups永远按照顺序完成，而cp.async-group中包含的异步拷贝操作的执行顺序是随机的。</p>
<p>Writes performed by an asynchronous copy operation are visible to the thread that initiated the asynchronous copy operation only after the cp.async-group completes or mbarrier object tracking the asynchronous copy has completed the phase.<br>仅当cp.async-group完成 or mbarrier追踪到异步拷贝完成，当前线程才能安全读取由当前线程发出的异步拷贝操作写入的数据（数据可见）。</p>
<p>Once an asynchronous copy operation is initaited, modifiying the source memory location or reading from the destination memory location before the asynchronous copy operation completes, will cause unpredictable results.<br>一旦一个异步拷贝操作被发起，不等待异步拷贝操作完成就 修改源内存地址中的数据 or 就读取目标内存地址中的数据，将会产生unpredictable results。</p>
<h4 id="cp-async"><a href="#cp-async" class="headerlink" title="cp.async"></a>cp.async</h4><p>Initiates an asynchronous copy operation from one state space to another.<br>发起一个异步拷贝操作。<br>Operand src specifies a location in the global state space and dst specifies a location in the shared state space.<br>异步拷贝只能是从global mem拷贝到shared mem。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp.async.ca.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], cp-size&#123;, src-size&#125;&#123;, cache-policy&#125; ;</span><br><span class="line">cp.async.cg.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], <span class="number">16</span>&#123;, src-size&#125;&#123;, cache-policy&#125; ;</span><br><span class="line">cp.async.ca.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], cp-size&#123;, ignore-src&#125;&#123;, cache-policy&#125; ;</span><br><span class="line">cp.async.cg.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], <span class="number">16</span>&#123;, ignore-src&#125;&#123;, cache-policy&#125; ;</span><br></pre></td></tr></table></figure><br>The <strong>.cg</strong> qualifier indicates caching of data only at global level cache L2 and not at L1 whereas <strong>.ca</strong> qualifier indicates caching of data at all levels including L1 cache. Cache operator are treated as performance hints only.<br><strong>.cg</strong>表示仅用L2 cache，数据传输绕过L1 cache与register。对应LDGSTS.BYPASS。<br><strong>.ca</strong>表示同时使用L1 cache与L2 cache，数据传输仅绕过register。对应LDGSTS.ACCESS。<br>这俩标识符只是对编译器的建议，具体用不用要看编译器的意思。实际上具体使用哪种取决于传输数据的大小与对齐方式。4 Bytes-&gt;access，16 Bytes-&gt;bypass。</p>
<p>Operand cp-size is an integer constant which specifies the size of data in bytes to be copied to the destination dst. cp-size can only be 4, 8 and 16.<br>cp-size指定了传输数据的大小（in bytes），可以是4、8、16，可以看到cp-size最小是4，而.cg指令cp-size直接指定为16，正好符合上面的说法。</p>
<center><img src="/2022/02/22/cuda-5/LDGSTS%20access%20and%20bypass.png" width="100%" height="100%"><font color="#708090" size="2">Two types of LDGSTS: access and bypass.</font></center>

<p>Instruction cp.async allows optionally specifying a 32-bit integer operand <strong>src-size</strong>. Operand src-size represents the size of the data in bytes to be copied from src to dst and must be less than <strong>cp-size</strong>. In such case, remaining bytes in destination dst are filled with zeros. Specifying src-size larger than cp-size results in undefined behavior.<br>src-size，指定拷贝源数据大小，必须比cp-size小，否则undefined behavior。很简答，如果比cp-size大，则拷贝数据不完整，再读取肯定不对。cp-size比src-size多出来的部份在dst中会被填充0。</p>
<p>The optional and non-immediate predicate argument <strong>ignore-src</strong> specifies whether the data from the source location src should be ignored completely. If the source data is ignored then zeros will be copied to destination dst. If the argument ignore-src is not specified then it defaults to False.<br>指定是否忽略scr中的数据，如果置为true，则向dst中拷贝0。默认为false。</p>
<p>The mandatory(强制的) <strong>.async</strong> qualifier indicates that the cp instruction will <strong>initiate the memory copy operation asynchronously</strong> and <strong>control will return to the executing thread before the copy operation is complete</strong>. The executing thread can then use <strong>cp.async.wait_all</strong> or <strong>cp.async.wait_group</strong> or <strong>mbarrier instructions</strong> to wait for completion of the asynchronous copy operation. No other synchronization mechanisms described in Memory Consistency Model can be used to guarantee the completion of the asynchronous copy operations.<br>三种用来同步异步数据传输操作的方法：<br><strong>cp.async.wait_all</strong> or <strong>cp.async.wait_group</strong> or <strong>mbarrier instructions</strong></p>
<p>There is no ordering guarantee between two cp.async operations if they are not explicitly synchronized using cp.async.wait_all or cp.async.wait_group or mbarrier instructions.<br>如果没有显式同步，两个cp.async之间没有顺序保证。</p>
<p>The <strong>.level::prefetch_size</strong> qualifier is a hint to <strong>fetch additional data of the specified size into the respective cache level</strong>.The sub-qualifier prefetch_size can be set to either of 64B, 128B, 256B thereby allowing the prefetch size to be 64 Bytes, 128 Bytes or 256 Bytes respectively.</p>
<p>The qualifier .level::prefetch_size may only be used with .global state space and with generic addressing where the address points to .global state space. If the generic address does not fall within the address window of the global memory, then the prefetching behavior is undefined.</p>
<p>The .level::prefetch_size qualifier is treated as a performance hint only.</p>
<p>When the optional argument <strong>cache-policy</strong> is specified, the qualifier <strong>.level::cache_hint</strong> is required. The 64-bit operand cache-policy specifies <strong>the cache eviction policy</strong> that may be used during the memory access.</p>
<p>The qualifier .level::cache_hint is only supported for .global state space and for generic addressing where the address points to the .global state space.</p>
<p>cache-policy is a hint to the cache subsystem and may not always be respected. It is treated as a performance hint only, and does not change the memory consistency behavior of the program.</p>
<p>.level::prefetch_size与.level::cache_hint都是与缓存相关的qualifier。都是hints to the compiler，并不一定被编译器所采纳。由于是缓存相关的，所以操作对象地址必须在global memory中，否则会导致undefined behavior.<br>.level::prefetch_size用于在缓存中除了要拷贝的数据之外，额外fetch一定大小的数据到对应cache中，用于增加缓存命中率，减少从device memory中读取数据的次数。<br>.level::cache_hint用于cache-policy指定时，用于指定缓存清除策略，如何使用缓存。</p>
<h4 id="cp-async-commit-group"><a href="#cp-async-commit-group" class="headerlink" title="cp.async.commit_group"></a>cp.async.commit_group</h4><p>Commits all prior initiated but uncommitted cp.async instructions into a cp.async-group.<br>将之前的未被commit的cp.async commit到一个cp.async-group。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp.async.commit_group;</span><br></pre></td></tr></table></figure>
<p>这条PTX code所产生的SASS code就是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDGDEPBAR <span class="comment">//Global Load Dependency Barrier</span></span><br></pre></td></tr></table></figure><br>会导致一个很大的stall long scoreboard。</p>
<p><strong>cp.async.commit_group</strong> instruction creates a new cp.async-group <strong>per thread</strong> and batches all prior cp.async instructions <strong>initiated by the executing thread but not committed to any cp.async-group</strong> into the new cp.async-group. If there are no uncommitted cp.async instructions then cp.async.commit_group results in an empty cp.async-group.</p>
<p>An executing thread can wait for the completion of all cp.async operations in a cp.async-group using cp.async.wait_group.</p>
<p>There is no memory ordering guarantee provided between any two cp.async operations within the same cp.async-group. So two or more cp.async operations within a cp.async-group copying data to the same location results in undefined behavior.<br>在同一个cp.async-group中的cp.async没有顺序保证，因此在同一cp.async-group中对同一地址的cp.async会导致undefined behavior。</p>
<h4 id="cp-async-wait-group-cp-async-wait-all"><a href="#cp-async-wait-group-cp-async-wait-all" class="headerlink" title="cp.async.wait_group/cp.async.wait_all"></a>cp.async.wait_group/cp.async.wait_all</h4><p>Wait for completion of prior asynchronous copy operations.<br>等待先前的异步拷贝操作完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp.async.wait_group N;</span><br><span class="line">cp.async.wait_all;</span><br></pre></td></tr></table></figure>
<p><strong>cp.async.wait_group</strong> instruction will cause executing thread to wait till <strong>only N or fewer of the most recent cp.async-groups are pending</strong> and <strong>all the prior cp.async-groups committed by the executing threads are complete</strong>. For example, when N is 0, the executing thread waits on all the prior cp.async-groups to complete. Operand N is an integer constant.</p>
<p>cp.async.wait_all;等待execution thread先前的所有cp.async都完成。也就是等价于commit一个cp.async-group然后马上等待所有先前的cp.async-group完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp.async.commit_group; <span class="comment">//将仍未被commit的cp.async commit到一个cp.async-group中</span></span><br><span class="line">cp.async.wait_group <span class="number">0</span>; <span class="comment">//等待所有先前的cp.async-group完成</span></span><br></pre></td></tr></table></figure></p>
<p>如果N为0，那么这条PTX code所产生的SASS code就是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEPBAR.LE SB0, <span class="number">0x0</span> ;</span><br></pre></td></tr></table></figure><br>DEPBAR的作用是等某个Scoreboard的计数不为0的情况（比如DEPBAR.LE SB5, 0x6 ;表示stall直至第5个Scoreboard的值降到6或以下）</p>
<p>SB指的就是scoreboard，由于是。记录cp.async-group的数量（一个counter）与每个cp.async-group所对应的cp.async (LDGSTS)的数量。每次一个cp.async-group完成，counter - 1。counter的数量刚好对应N的值。<br>N标明等待只有N或更少个cp.async-group未完成才继续。如果是0，那么就是等待只有0个未完成，代表等待所有的cp.async-group完成。由于cp.async-group是保持发射顺序的，因此N等待的永远是倒数的N个cp.async-group，就是最近发射的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of .wait_all:</span></span><br><span class="line">cp.async.ca.shared.global [shrd1], [gbl1], <span class="number">4</span>;</span><br><span class="line">cp.async.cg.shared.global [shrd2], [gbl2], <span class="number">16</span>;</span><br><span class="line">cp.async.wait_all;  <span class="comment">// waits for all prior cp.async to complete</span></span><br></pre></td></tr></table></figure>
<p>cp.async.wait_all等待前面所有的cp.async完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of .wait_group :</span></span><br><span class="line">cp.async.ca.shared.global [shrd3], [gbl3], <span class="number">8</span>;</span><br><span class="line">cp.async.commit_group;  <span class="comment">// End of group 1</span></span><br><span class="line"></span><br><span class="line">cp.async.cg.shared.global [shrd4], [gbl4], <span class="number">16</span>;</span><br><span class="line">cp.async.commit_group;  <span class="comment">// End of group 2</span></span><br><span class="line"></span><br><span class="line">cp.async.cg.shared.global [shrd5], [gbl5], <span class="number">16</span>;</span><br><span class="line">cp.async.commit_group;  <span class="comment">// End of group 3</span></span><br><span class="line"></span><br><span class="line">cp.async.wait_group <span class="number">1</span>;  <span class="comment">// waits for group 1 and group 2 to complete</span></span><br></pre></td></tr></table></figure>
<p>cp.async.wait_group 1 允许有一个cp.async-group未完成，按照顺序，此条指令等待group 1 and 2完成。</p>
<p>Writes performed by cp.async operations are made <strong>visible to the executing thread</strong> only after :</p>
<ol>
<li>The completion of cp.async.wait_all or</li>
<li>The completion of cp.async.wait_group on the cp.async-group in which the cp.async belongs to or</li>
<li>mbarrier.test_wait returns True on an mbarrier object which is tracking the completion of the cp.async operation.<br>三种情况下，由cp.async写入的数据对当前线程可见。cp.async.wait_all完成了，代表此处之前所有的cp.async都已完成。cp.async所在的cp.async-group完成了，使用cp.async.wait_group实现。追踪此cp.async的mbarrier的mbarrier.test_wait返回true。</li>
</ol>
<p>There is no ordering between two cp.async operations that are not synchronized with cp.async.wait_all or cp.async.wait_group or mbarrier objects.</p>
<p><strong>cp.async.wait_group and cp.async.wait_all does not provide any ordering and visibility guarantees for any other memory operation apart from cp.async.</strong><br>cp.async.wait_group and cp.async.wait_all仅影响cp.async的顺序，其他内存操作与此无关。很容易看出嘛。前缀都是cp.async.*，明显就是这个专用的。这里没说mbarrier，说明这玩应是对所有内存操作都有效的，是同步障碍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/20/cuda-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/20/cuda-4/" class="post-title-link" itemprop="url">CUDA学习随记4 Volta’s Independent Thread Scheduling</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-20 20:09:48" itemprop="dateCreated datePublished" datetime="2022-02-20T20:09:48+08:00">2022-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-23 16:24:30" itemprop="dateModified" datetime="2022-02-23T16:24:30+08:00">2022-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Volta’s-Independent-Thread-Scheduling"><a href="#Volta’s-Independent-Thread-Scheduling" class="headerlink" title="Volta’s Independent Thread Scheduling"></a>Volta’s Independent Thread Scheduling</h1><p><a target="_blank" rel="noopener" href="https://developer.nvidia.com/blog/inside-volta/">Inside Volta: The World’s Most Advanced Data Center GPU</a></p>
<p>High Performance Computing (HPC) is a fundamental pillar of modern science. From predicting weather, to discovering drugs, to finding new energy sources, researchers use large computing systems to simulate and predict our world. AI extends traditional HPC by allowing researchers to analyze large volumes of data for rapid insights where simulation alone cannot fully predict the real world.<br>高性能计算HPC是现代科学的基本支柱。从天气预测到药物研究，再到获取新能源，研究人员使用大型的计算系统来模拟与预测我们的世界。人工智能AI通过允许研究人员分析大量的数据以便快速获得洞察，拓展了传统的高性能计算，用于仅靠模拟不能完全预测现实世界的情况。<br>Computational Science for scientific simulation.<br>Data Science for finding insights in data.</p>
<center><img src="/2022/02/20/cuda-4/Volta%20GV100%20architecture.png" width="100%" height="100%"><font color="#708090" size="2">Volta GV100 Full GPU with 84 SM Units.</font></center>

<p><strong>每块 GV100 包含：</strong><br>6 x Graphics Processing Clusters (GPCs)<br>每个GPC包含 7 x Texture Processing Clusters (TPCs)，共 42<br>每个TPC包含 2 x Streaming Multiprocessors (SMs)，共 84<br>8 x 512-bit Memory Controllers(4096 bits total) 用于与显存进行数据交换</p>
<p><strong>每个 SM 包含：</strong><br>64 FP32 Cores<br>64 INT32 Cores<br>32 FP64 Cores<br><em>8 new Tensor Cores</em><br>4 texture units</p>
<center><img src="/2022/02/20/cuda-4/Volta%20GV100%20SM.png" width="100%" height="100%"><font color="#708090" size="2">Volta GV100 Full GPU with 84 SM Units.</font></center>

<p><strong>每个SM被划分为四个部份partitions，每个部份包含：</strong><br>8 FP64 Cores<br>16 INT32 Cores<br>16 FP32 Cores<br>2 new mixed-precision Tensor Cores for deep learning matrix arithmetic<br>a new L0 instruction cache<br>a warp scheduler<br>a dispatch unit<br>a 64 KB Register File</p>
<p>Unlike Pascal GPUs, which could not execute FP32 and INT32 instructions simultaneously, the Volta GV100 SM includes separate FP32 and INT32 cores, allowing simultaneous execution of FP32 and INT32 operations at full throughput, while also increasing instruction issue throughput. </p>
<p>Pascal GPU所有的CUDA核心都是FP32+INT32混合核心，这种核心每个周期只能进行浮点运算或整型运算的一种。整块SM分区（具有一个warp scheduler）同时切换，这块分区某一时刻只能进行FP或INT运算的一种。</p>
<p>Volta/Turing GPU单独开辟了一条INT型通道，其具有独立的FP32与INT32核心，可同时执行FP32与INT32操作。</p>
<blockquote>
<p>关于NVIDIA三代GPU架构CUDA核心的变化（Pascal, Turing, Ampere）<br><a target="_blank" rel="noopener" href="https://weibo.com/tv/show/1034:4548031207637036?from=old_pc_videoshow">微博 林亦LYi: 什么是「显卡测不准原理」</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1a64y1F7Gp?from=search&amp;seid=665276990359275781&amp;spm_id_from=333.337.0.0">B站 林亦LYi: 什么是「显卡测不准原理」</a></p>
</blockquote>
<center><img src="/2022/02/20/cuda-4/FP_INT.png" width="100%" height="100%"><font color="#708090" size="2">Floating Point vs Integer.</font></center>
<center><img src="/2022/02/20/cuda-4/CUDA_cores.png" width="100%" height="100%"><font color="#708090" size="2">SM of Volta & Turing</font></center>

<blockquote>
<p>RTX20系显卡使用Turing架构，而RTX30系显卡使用Ampere架构。<br>图中可以看出，FP32核心要比INT32核心更大一些，这是由于用于浮点型运算的核心要更复杂一些，也只有FP32核心才被称为CUDA核心。<br>Turing架构中，INT32核心和FP32核心是独立的，每个SM中各有64个。<br>Ampere架构中，除了64个FP32核心，原有的64个INT32核心转变为了64个FP32+INT32核心，而这部分核心也算作CUDA核心，因此每个SM上共有64+64=128个CUDA核心。<br>FP32+INT32核心在一个周期内，只能进行浮点型或整数型运算的一种。二选一。混合核心并不能提供完全的浮点运算能力。程序的整型运算越多，浮点运算能力就会下降越明显。这是由于混合核心在FP32与INT32核心间的切换导致的。每次切换时，以SM中的一块partition为单位切换，partition中的所有混合核心同时切换。</p>
</blockquote>
<center><img src="/2022/02/20/cuda-4/CUDA_cores_1.png" width="100%" height="100%"><font color="#708090" size="2">SM of Volta & Turing</font></center>

<blockquote>
<p>Pascal架构中所有CUDA核心都是混合核心，SM每个分区一个时刻只能进行一种运算。<br>Turing架构中为INT型单独开辟一条通道，可同时执行INT型运算与FP运算，但这样INT型运算性能过剩，多数时间都在摸鱼。<br>Ampere架构中把INT型核心又换回了混合核心，这样就避免了INT型核心空闲的问题。</p>
</blockquote>
<h2 id="Tensor-Cores"><a href="#Tensor-Cores" class="headerlink" title="Tensor Cores"></a>Tensor Cores</h2><p>Matrix-Matrix multiplication (BLAS GEMM) operations are at the core of neural network training and inferencing, and are used to multiply large matrices of input data and weights in the connected layers of the network.<br>矩阵乘操作是神经网络训练和推理的核心，被用于做输入数据和对应权重矩阵的乘法。<br>BLAS: Basic Linear Algebra Subprograms 基本线性代数子程序<br>GEMM: General Matrix Multiplication 通用矩阵乘法</p>
<p>Each Tensor Core provides a 4x4x4 matrix processing array which performs the operation $\textbf{D} = \textbf{A} \times \textbf{B} + \textbf{C}$, where $\textbf{A}$, $\textbf{B}$, $\textbf{C}$, and $\textbf{D}$ are 4×4 matrices as shown below. The matrix multiply inputs $\textbf{A}$ and $\textbf{B}$ are FP16 matrices, while the accumulation matrices $\textbf{C}$ and $\textbf{D}$ may be FP16 or FP32 matrices.<br>每个Tensor Core提供一个4x4x4的矩阵处理阵列，分别包括ABCD四个4x4的矩阵，乘法矩阵AB是FP16的，而加法矩阵CD可以是FP16也可以是FP32。</p>
<center><img src="/2022/02/20/cuda-4/Tensor%20Core%204x4x4%20matrix%20multiply%20and%20accumulate.png" width="100%" height="100%"><font color="#708090" size="2">Tensor Core 4x4x4 matrix multiply and accumulate.</font></center>

<p>Each Tensor Core performs 64 floating point FMA mixed-precision operations per clock.<br>FMA: Fused Multiply Add/Accumulate 融合乘加<br>4x4 矩阵乘$\textbf{A} \times \textbf{B}$，一共做 4x4x4 = 64次乘法，4x4x3 = 48次加法。结果矩阵加一个 4x4 矩阵$\textbf{C}$。整个计算一共64次乘，64次加，因此为64 FMA operations。<br>D00 = A00<em>B00 + C00 FMA<br>D00 = A01</em>B10 + D00 FMA<br>D00 = A02<em>B20 + D00 FMA<br>D00 = A03</em>B30 + D00 FMA<br>结果矩阵$\textbf{D}$中一个数对应4次FMA。</p>
<p>During program execution, multiple Tensor Cores are used concurrently by a full warp of execution. The threads within a warp provide a larger 16x16x16 matrix operation to be processed by the Tensor Cores. CUDA exposes these operations as Warp-Level Matrix Operations in the CUDA C++ API. These C++ interfaces provide specialized matrix load, matrix multiply and accumulate, and matrix store operations to efficiently utilize Tensor Cores in CUDA C++ programs.<br>多个Tensor cores被一个完整的warp同时使用，为Warp-Level Matrix Operations，包括matrix load, matrix multiply and accumulate, and matrix store operations。</p>
<p>In addition to CUDA C++ interfaces to program Tensor Cores directly, CUDA 9 cuBLAS and cuDNN libraries include new library interfaces to make use of Tensor Cores for deep learning applications and frameworks.<br>除了CUDA C++之外，CUDA 9.0中的cuBLAS与cuDNN库也提供了调用Tensor core的接口。</p>
<p>从Volta开始，L1 data cache与shared mem合并为一块内存。共享128 KB/SM的内存空间。<br>The new combined L1 data cache and shared memory subsystem of the Volta SM significantly improves performance while also simplifying programming and reducing the tuning required to attain at or near-peak application performance.<br>这样做在提升了程序性能的同时，简化了编程，也减少了达到峰值性能所需的调优。<br>narrows the gap between applications that are manually tuned to keep data in shared memory and those that access data in device memory directly.<br>由于现在L1与shared mem实际为一块内存，具有相同的特性，因此也缩小了人为使用shared mem优化程序与直接访问device mem的程序性能差距。<br>allow L1 cache operations to attain the benefits of shared memory performance. Shared memory provides high bandwidth and low latency, but the CUDA programmer needs to explicitly manage this memory. Volta narrows the gap between applications that explicitly manage shared memory and those that access data in device memory directly.<br>Shared mem带宽高延迟低，但需要人为控制。因此合并L1与shared mem可以使得L1 cache获得shared mem的特性，从而缩小直接访问device mem与人为使用shared mem的性能差距，简化编程。</p>
<h2 id="Independent-Thread-Scheduling"><a href="#Independent-Thread-Scheduling" class="headerlink" title="Independent Thread Scheduling"></a>Independent Thread Scheduling</h2><p>Volta GV100 is the first GPU to support independent thread scheduling, which enables finer-grain synchronization and cooperation between parallel threads in a program.<br>Volta GV100是首个支持独立线程调度的GPU。</p>
<h4 id="Prior-NVIDIA-GPU-SIMT-Models"><a href="#Prior-NVIDIA-GPU-SIMT-Models" class="headerlink" title="Prior NVIDIA GPU SIMT Models"></a>Prior NVIDIA GPU SIMT Models</h4><p>Pascal and earlier NVIDIA GPUs execute <strong>groups of 32 threads, known as warps</strong>, in SIMT (Single Instruction, Multiple Thread) fashion. The Pascal warp uses <strong>a single program counter shared amongst all 32 threads</strong>, combined with an “<strong>active mask</strong>” that specifies which threads of the warp are active at any given time.  This means that divergent execution paths leave some threads inactive, <strong>serializing execution</strong> for different portions of the warp as shown below. The original mask is stored until the warp reconverges at the end of the divergent section, at which point the mask is restored and the threads run together once again.<br>warp中的32个线程共享同一个程序计数器（也称为指令指针，或指令地址寄存器），同步执行相同的指令，同时使用一个mask标记当前哪些线程是active的。当遇到分支路径时，顺序执行不同的分支并屏蔽掉不在此路径上的线程。在分支部份开始时切换顺序执行，在分支结束时重新同步reconverge所有线程。</p>
<center><img src="/2022/02/20/cuda-4/independent%20thread%20scheduling%201.png" width="100%" height="100%"><font color="#708090" size="2">Thread scheduling under the SIMT warp execution model of Pascal and earlier NVIDIA GPUs.</font></center>

<p>如图所示，会先执行其中一个分支直到结束，屏蔽掉不在这条分支上的线程，再开始执行另一条分支，在分支结束时所有线程重新同步。</p>
<p>The Pascal SIMT execution model maximizes efficiency by reducing the quantity of resources required to track thread state and by aggressively reconverging threads to maximize parallelism. Tracking thread state in aggregate for the whole warp, however, means that when the execution pathway diverges, the threads which take different branches lose concurrency until they reconverge. This loss of concurrency means that threads from the same warp in divergent regions or different states of execution cannot signal each other or exchange data. This presents an inconsistency in which threads from different warps continue to run concurrently, but diverged threads from the same warp run sequentially until they reconverge. This means, for example, that algorithms requiring fine-grained sharing of data guarded by locks or mutexes can easily lead to deadlock, depending on which warp the contending threads come from. Therefore, on Pascal and earlier GPUs, programmers have to avoid fine-grained synchronization or rely on lock-free or warp-aware algorithms.<br>The Pascal SIMT execution model通过减少记录线程状态所需资源（同一warp同步执行，只记录一个active mask）、积极同步线程最大化并行度（分支结束即立刻同步warp中的线程）来最大化效率。<br>串行化逐个执行分支，也就意味着同一个warp中执行不同分支的线程之间失去了并行性，彼此不能通信、交换数据。但不同warp中的线程仍然是同步的，分支仅屏蔽掉本warp中的一部分线程而执行另一部分，这就显示出一种矛盾。这也就阻止了更细粒度（warp-level）的编程，同一个warp中不同线程交换数据使用锁或互斥体很容易导致死锁问题（一个线程等待另一个线程，但另一个线程需要等待本线程执行完毕才能执行，互相等待导致死锁）。</p>
<h4 id="Volta-SIMT-Model"><a href="#Volta-SIMT-Model" class="headerlink" title="Volta SIMT Model"></a>Volta SIMT Model</h4><p>enabling equal concurrency between all threads, regardless of warp.<br>maintaining execution state per thread, including the program counter and call stack.<br>Volta通过维护每一个线程的执行状态，包括程序计数器（指令地址寄存器）和调用栈，在所有线程间实现了相同的并发性，即同一个warp中的线程也是并发的。</p>
<center><img src="/2022/02/20/cuda-4/independent%20thread%20scheduling%202.png" width="100%" height="100%"><font color="#708090" size="2">Volta (bottom) independent thread scheduling architecture block diagram compared to Pascal and earlier architectures (top).</font></center>

<p>Volta maintains per-thread scheduling resources such as program counter (PC) and call stack (S), while earlier architectures maintained these resources per warp.<br>Volta每个线程维护一个program counter (PC) and call stack (S)，而之前的架构每个warp维护一个。</p>
<p>To maximize parallel efficiency, Volta includes a <strong>schedule optimizer</strong> which determines how to group <strong>active threads from the same warp</strong> together into SIMT units. Threads can now diverge and reconverge at sub-warp granularity, and Volta will still <strong>group together threads which are executing the same code and run them in parallel</strong>.</p>
<center><img src="/2022/02/20/cuda-4/independent%20thread%20scheduling%203.png" width="100%" height="100%"><font color="#708090" size="2">Volta independent thread scheduling enables interleaved execution of statements from divergent branches.</font></center>

<p>Statements from the if and else branches in the program can now be interleaved in time.<br>if else分支中的语句现在可以交错执行。<br>Note that execution is still SIMT: at any given clock cycle CUDA cores execute the same instruction for all active threads in a warp just as before, retaining the execution efficiency of previous architectures.<br>仍然是SIMT执行架构，单指令流多线程。每个clock cycle，所有active threads在CUDA cores上执行相同的指令。<br>Importantly, Volta’s ability to independently schedule threads within a warp makes it possible to implement complex, <strong>fine-grained algorithms (sub-warp)</strong> and data structures in a more natural way. While the scheduler supports independent execution of threads, it optimizes non-synchronizing code to maintain <strong>as much convergence as possible</strong> for maximum SIMT efficiency.<br>Independently schedule threads within a warp，使得位于不同分支的语句（由不同active threads执行）可以交错执行，从而warp中的线程具有concurrency，可以互相同步、交换数据，使得sub-warp算法成为可能。Scheduler尽可能地优化非同步代码，以实现最大化的convergence（并行性越好，SIMT efficiency越高）。</p>
<p>It is interesting to note that the Figure does not show execution of statement Z by all threads in the warp at the same time. This is because the scheduler must conservatively assume that Z may produce data required by other divergent branches of execution in which case it would be unsafe to automatically enforce reconvergence. In the common case where A, B, X, and Y do not consist of synchronizing operations, the scheduler can identify that it is safe for the warp to naturally reconverge on Z, as on prior architectures.<br>从图中可以看出，位于if else分支语句之外的Z语句，并没有被所有线程同步执行。也就是说在divergence结束的部份，warp中的线程并不一定会reconverge。<br>这是由于编译器保守地假定本线程中的Z语句会产生其他divergent线程执行所需要的数据，如果同步会导致其他线程一直处于等待这部分数据的情况unsafe。一般情况下，如果if else中的指令未包含同步操作，scheduler能识别出在执行Z之前reconverge是safe的，那么就会reconverge，从而提高并行性提高SIMT efficiency。<br>但divergence之后是否reconverge warp中的线程是编译器擅自做主，没保证，最安全的还是人为使用CUDA 9 新引入的__syncwarp()函数to force reconvergence同步all threads in a warp。</p>
<center><img src="/2022/02/20/cuda-4/independent%20thread%20scheduling%204.png" width="100%" height="100%"><font color="#708090" size="2">Programs can use explicit synchronization __syncwarp() to reconverge threads in a warp.</font></center>

<p>In this case, the divergent portions of the warp might not execute Z together, but all execution pathways from threads within a warp will complete before any thread reaches the statement after the <strong>syncwarp(). Similarly, placing the call to </strong>syncwarp() before the execution of Z would force reconvergence before executing Z, potentially enabling greater SIMT efficiency if the developer knows that this is safe for their application.<br>到达__syncwarp()时，所有warp中的divergent portions执行完毕，在此处reconverge。</p>
<h4 id="Starvation-Free-Algorithms"><a href="#Starvation-Free-Algorithms" class="headerlink" title="Starvation-Free Algorithms"></a>Starvation-Free Algorithms</h4><p>Starvation-free algorithms are a key pattern enabled by independent thread scheduling.</p>
<p>Starvation: 并发进程永久地无法获得执行工作所需的某个资源的情况。饥饿可能会导致程序无效或不正确，因为无法获得资源的线程没有正确地完成工作。<br>Starvation-Free: 无饥饿。<strong>某个线程，总是可以获取到某个资源，获取资源的时间不作限制，可长可短，只要能获取到即可</strong>。取决于线程之间是否有优先级的存在，如果系统允许高优先级的线程插队，这样有可能导致低优先级线程产生饥饿，资源被高优先级线程一直锁住，导致低优先级线程一直无法访问。Starvation-Free的线程可以是阻塞的，可以spinning on a lock等待数据可供访问。</p>
<p>Starvation-Free Algorithms are concurrent computing algorithms that are guaranteed to execute correctly so long as the system ensures that <strong>all threads have adequate access to a contended resource</strong>.<br>并发算法，需要保证所有线程对竞争资源都具有充分的访问权限。</p>
<p>Inserting nodes into a doubly-linked list in a multithreaded application.<br>在一个多线程应用中，向一个双向链表中插入节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">insert_after</span><span class="params">(Node *a, Node *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *c;</span><br><span class="line">    <span class="built_in">lock</span>(a); <span class="built_in">lock</span>(a-&gt;next);</span><br><span class="line">    c = a-&gt;next;</span><br><span class="line"></span><br><span class="line">    a-&gt;next = b;</span><br><span class="line">    b-&gt;prev = a;</span><br><span class="line"></span><br><span class="line">    b-&gt;next = c;</span><br><span class="line">    c-&gt;prev = b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unlock</span>(c); <span class="built_in">unlock</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双向链表，前后节点都要记录。<br>a -&gt; a_next(c)<br>a -&gt; b -&gt; a_next(c)<br>由于要修改a与a_next中的数据，因此首先锁定这两个节点，修改之后解锁。</p>
<p>each element of a doubly linked list has at least three components: a next pointer, a previous pointer, and a lock providing the owner <strong>exclusive access</strong> to update the node.<br>独占访问权</p>
<center><img src="/2022/02/20/cuda-4/a%20double-linked%20list%20with%20locks.png" width="100%" height="100%"><font color="#708090" size="2">A doubly-linked list with fine-grained locks. Per-node locks are acquired (left) before inserting node B into the list (right).</font></center>

<p>Independent thread scheduling in Volta ensures that even if a thread T0 currently holds the lock for node A, another thread T1 in the same warp can successfully wait for the lock to become available without impeding the progress of thread T0. Note, however, that because active threads in a warp execute together, threads spinning on a lock may degrade the performance of the thread holding the lock.<br>Volta的独立线程调度机制使得，即便一个thread T0正持有node A的lock（正在使用node A的数据，其他线程不可访问，需等待T0使用完毕之后unlock），相同warp中的另一个线程T1也可以在不干扰线程T0的情况下等到lock解锁。<br>解释一下，这是由于独立线程调度允许在divergent branches之间交替执行，但也是屏蔽掉不在这条path上的线程。因此此时T0正在持有lock，而T1正在spinning on the lock，等待使用状态。正是由于这样的原因，当T1 spinning的时候，T0是被屏蔽了的，而T0执行的时候，T1是被屏蔽的。因此这里说spinning on a lock的线程会影响此时holding the lock的线程的性能。<br>若没有独立线程调度机制，这种算法无法实现，原因是同一warp中的线程只能执行相同的指令，要么就是被屏蔽掉了。当两线程同时access node A，一个成功hold the lock，另一个只能spin on the lock。而由于发生divergent时，不同分支是交替执行的，无法确保哪个优先执行，有可能执行到spinning状态，这时另一个线程是处于一直被屏蔽状态的，没有机会unlock，导致程序挂起。</p>
<p>It is also important to note that the use of a per-node lock in the above example is critical for performance on the GPU. Traditional doubly-linked list implementations may use a coarse-grained lock that provides exclusive access to the entire structure, rather than separately protecting individual nodes. This approach typically leads to poor performance in applications with many threads—Volta may have up to 163,840 concurrent threads—caused by extremely high contention for the lock. By using a fine-grained lock on each node, the average per-node contention in large lists will usually be low except under certain pathological node insertion patterns.</p>
<p>使用这种per-node lock对GPU执行性能收益很大（除非是那种病态访问情况：线程间访问的节点非常集中）。传统双向链表只能用更粗粒度的lock，提供对整个structure的独占访问权，而不是单独检测每个node。当有数量非常庞大的线程时，线程间竞争非常激烈，并行就完全退化为了串行。</p>
<p><a target="_blank" rel="noopener" href="https://images.nvidia.cn/content/volta-architecture/pdf/volta-architecture-whitepaper.pdf">Tesla V100 architecture white paper</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/16/ComSys-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/16/ComSys-1/" class="post-title-link" itemprop="url">计算机系统学习随记 原子操作是如何实现的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-16 01:46:36 / Modified: 01:53:28" itemprop="dateCreated datePublished" datetime="2022-02-16T01:46:36+08:00">2022-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">计算机系统学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原子操作是如何实现的"><a href="#原子操作是如何实现的" class="headerlink" title="原子操作是如何实现的"></a>原子操作是如何实现的</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33445834">知乎: 原子操作是如何实现的？</a></p>
<blockquote>
<p>X86架构(The X86 architecture)</p>
</blockquote>
<p>X86架构(The X86 architecture)是微处理器执行的计算机语言指令集，对应32位。而平时常说的x64，全称是x86-64，对应64位，是x86指令集的64位扩展超集，具备向下兼容的特点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jiang Shao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Shao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
