<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="WeChat: shaojiang9650Email: shao_study@163.com">
<meta property="og:type" content="website">
<meta property="og:title" content="邵大宝的学习Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="邵大宝的学习Blog">
<meta property="og:description" content="WeChat: shaojiang9650Email: shao_study@163.com">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jiang Shao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>邵大宝的学习Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">邵大宝的学习Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">最爱严小跳</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/16/ComputeLab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/16/ComputeLab/" class="post-title-link" itemprop="url">ComputeLab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-07-16 20:29:55 / Modified: 23:09:29" itemprop="dateCreated datePublished" datetime="2022-07-16T20:29:55+08:00">2022-07-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ComputeLab-Usage"><a href="#ComputeLab-Usage" class="headerlink" title="ComputeLab Usage"></a>ComputeLab Usage</h1><blockquote>
<p>Reference:<br><a target="_blank" rel="noopener" href="https://gitlab-master.nvidia.com/rjeng/devtech_new_hire_training">Rjeng’s Devtech New Hire Training</a></p>
</blockquote>
<h4 id="VSCode连接ComputeLab-非常的不好用总掉线！"><a href="#VSCode连接ComputeLab-非常的不好用总掉线！" class="headerlink" title="VSCode连接ComputeLab  (非常的不好用总掉线！)"></a>VSCode连接ComputeLab  (非常的不好用总掉线！)</h4><ol>
<li>VSCode端安装拓展Remote-SSH</li>
<li>设置-拓展-Remote-SSH-always reveal the SSH login terminal</li>
<li>ssh jiangs@computelab</li>
<li>卡住之后VSCode-Terminal-New Terminal</li>
</ol>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4><ul>
<li><p>连接ComputeLab：<br><code>ssh jiangs@computelab</code></p>
</li>
<li><p>个人500G云存储空间：<br><code>/home/scratch.jiangs_sw</code></p>
</li>
<li><p>查找可用的free nodes：<br><code>csm find &#39;chip=*&#39; -v -f</code></p>
</li>
<li><p>使用chip信息开始一个interactive job：<br><code>crun -q &#39;chip=gv100 and partition=all&#39; -i</code></p>
</li>
<li><p>使用node信息开始一个interactive job：<br><code>crun -q &#39;node=computelab-11&#39; -i</code></p>
</li>
<li><p>提交一个batch job<br><code>crun -q &#39;chip=tu102&#39; -b &quot;&lt;cmd/script to execute&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argn&gt;&quot;</code></p>
</li>
<li><p>提交一个时长无限的batch job<br><code>crun -q &#39;chip=gv100 and partition=all,longJob&#39; -t 0 -b &quot;&lt;cmd/script&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;argn&gt;&quot;</code></p>
</li>
<li><p>Run the following to get crun’s full help<br><code>crun -h|--help</code></p>
</li>
<li><p>Run the following to get more usage examples (这个|是或的意思，只留下前面的或者后面的就可以)<br><code>crun -ie|--interactive_examples</code><br><code>crun -be|--batch_examples</code><br><code>crun -de|--docker_examples</code> </p>
</li>
</ul>
<hr>
<h3 id="crun-interactive-examples"><a href="#crun-interactive-examples" class="headerlink" title="crun interactive_examples"></a>crun interactive_examples</h3><ul>
<li><p>Run nvidia-smi command on a specific free node that has a tu104 gpu<br><code>crun -q &#39;chip=tu104&#39; nvidia-smi</code></p>
</li>
<li><p>Start an interactive session on any random compute node<br><code>crun -q &#39;chip=*&#39; -i</code> <strong>进入交互式session！！！exit退出session</strong></p>
</li>
<li><p>Start an interactive session on a compute node which has gv100 chip<br><code>crun -q &#39;chip=gv100&#39; -i</code></p>
</li>
<li><p>Start an interactive session on a compute node which has gv100 chip, and wait if none is available yet<br><code>crun -q &#39;chip=gv100&#39; -i --wait</code> 如果暂时没有可用节点则等待节点可用</p>
</li>
<li><p>Start an interactive session on test partition 测试分区<br><code>crun -q &#39;chip=gv100 and partition=test&#39; -i</code></p>
</li>
<li><p>Run nvidia-smi command and then start an interactive session on a node that has gv100 chip<br><code>crun -q &#39;chip=gv100&#39; -i nvidia-smi</code></p>
</li>
<li><p>Install a specific driver before starting an interactive session on a node that has gv100 chip<br><code>crun -q &#39;chip=gv100&#39; -d /home/builds/release/display/x86_64/410.45/NVIDIA-Linux-x86_64-410.45.run -ex -i</code></p>
</li>
<li><p>Start an interactive session on a node with <strong>exclusive access 独占访问</strong><br><code>crun -q &#39;chip=*&#39; -i -ex</code></p>
</li>
<li><p>Run a prolog script and then start an interactive session<br><code>crun -q &#39;chip=*&#39; -p /home/scratch.computelab/csm/user_data/test.sh -i</code></p>
</li>
</ul>
<p>Following is the list of attributes you can use and combine in a query using<br>the logical ‘and’, ‘or’, and ‘not’ operators. You can also use * as a wildcard 通配符<br>and parentheses 圆括号 to group expressions in your query. Use csm to find nodes/GPUs<br>and their attributes.</p>
<h2 id="Attribute-Description"><a href="#Attribute-Description" class="headerlink" title="Attribute               : Description"></a>Attribute               : Description</h2><p>baseboard_name              : System Baseboard Name<br>cluster                     :<br>cpu_arch                    : CPU Architecture<br>cpu_cores_per_socket        : CPU Cores per socket<br>cpu_count                   : Total logical CPU (a.k.a. hardware thread) count<br>cpu_family                  : CPU Family<br>cpu_flags                   : CPU Flags<br>cpu_model_number            : CPU Model Number<br>cpu_product_name            : CPU Product Name<br>cpu_short_name              : CPU Shorter Name<br>cpu_stepping                : CPU Stepping<br>crun_hash                   :<br><strong>default_cuda_version        : max cuda version supported by the default driver</strong><br><strong>default_gpu_driver          : driver that is installed on the node unless overridden</strong><br>gpu_affine_numa_node        :<br><strong>gpu_arch                    : Architecture name (e.g., Volta, Turing, Ampere)</strong><br>gpu_board                   : Board type (e.g., pg133, pg136)<br>gpu_board_id                : Board ID in hex<br>gpu_board_name              : Full board name including the product name, board, SKU, and TS when available<br>gpu_board_pbr               : Board PBR (Prototype Build Request)<br>gpu_board_type              : One of “production”, “pre-production”, “engineering”<br><strong>gpu_chip                    : Chip name (e.g., gv100, ga100)</strong><br>gpu_chip_sku                : Chip SKU (Stock Keeping Unit)<br><strong>gpu_compute_capability      : GPU compute capability (eg. sm80)</strong><br>gpu_default_register        : registers that are set on the gpu unless overridden<br>gpu_default_vbios           : vbios driver that is installed on the gpu unless overridden<br>gpu_device_id               : PCIe device ID in hex<br>gpu_max_mem_clock           : Maximum GPU memory clock in MHz<br>gpu_max_sm_clock            : Maximum GPU SM clock in MHz<br>gpu_memory                  : GPU memory in bytes<br>gpu_memory_gb               : GPU memory in JEDEC GB (IEC GiB, or 1024^3)<br>gpu_nvidia_smi_index        : GPU device index<br>gpu_nvlink_peers            : Number of NVLink-connected GPUs requested<br>gpu_pcie_gen                : PCIe generation at which the device link is trained<br>gpu_pcie_link_width         : PCIe link width<br>gpu_pcie_peers              : Number of PCIe-connected to this GPU<br>gpu_peers                   : Number of GPUs connected in any way to this GPU<br>gpu_power_limit             : Power limit in Watts<br>gpu_product_name            : Product name (e.g., Tesla V100, Tesla P4, Titan V, Tesla P4)<br>gpu_product_variant_hash    :<br>gpu_serial_number           : GPU serial number<br>gpu_short_name              : Chip ID (e.g., ga100-a, ga100gl-a, ga100gl-b)<br><strong>gpu_sms                     : Number of SMs</strong><br>gpu_trainstop               : Device Train Stop (e.g. TSn, DVT, QSm, RCn, CR, MP)<br>gpu_uuid                    : Unique identifier for a gpu<br>gpu_vbios_ver               : VBIOS version<br>gpus                        : GPUs to allocate for the job, defaults to 1<br>host                        : Alias for “node”<br>hostname                    : Alias for “node”<br>is_soc                      : Boolean indicating an SOC system (eg. jetson)<br>node                        : Node name in computelab<br>num_gpus                    : Number of GPUs connected in the group that this GPU is a part of<br><strong>os_name                     : OS name</strong><br><strong>os_version                  : OS version</strong><br>partitions                  : Slurm partition name<br>system_memory               : System memory<br>system_memory_gb            : System memory in GB<br>system_product_name         : System product name (from DMI type 1 record)<br>system_short_name           : System short name</p>
<p>Note that you can’t really select a specific GPU using the uuid on a multi-GPU<br>node, so a job started from a query containing a positive uuid term will be<br>converted to an exclusive job and you will get all of the GPUs on the node where<br>the given GPU is hosted.  </p>
<hr>
<ul>
<li><p>Get a front-end computelab machine<br><code>ssh jiangs@computelab</code></p>
</li>
<li><p>To get a list of free nodes available to you in computelab -<br><code>csm find &#39;chip=*&#39; -v -f</code></p>
</li>
<li><p>To start an interactive job, using node information (use a free node listed in the previous list) -<br><code>crun -q &#39;node=computelab-11&#39; -i</code></p>
</li>
<li><p>Set the bash for a bash shell with clear environment variables<br><code>alias bash &#39;/usr/bin/env -i /bin/bash -l&#39;</code></p>
</li>
<li><p>Get a bash shell<br><code>bash</code></p>
</li>
<li><p>Get the relevant CUDA toolkit pointers. This is gotten from previous computelab users who needed to set their environment<br><code>source ~/computelab.sh</code></p>
</li>
<li><p>Build the code. Note that make clean is important otherwise there are weird environment issues that make spits out<br><code>make clean; make all</code></p>
</li>
<li><p>CUDA Path pointer in the Makefile that we need to set<br><code>CUDA_PATH ?= /home/scratch.svc_compute_arch/release/cuda_toolkit/r11.5/x86_64/latest/</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/07/VSCode-MarkDown-Hexo-Blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/07/VSCode-MarkDown-Hexo-Blog/" class="post-title-link" itemprop="url">VSCode_MarkDown_Hexo_Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-07 17:36:57" itemprop="dateCreated datePublished" datetime="2022-07-07T17:36:57+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-18 02:07:45" itemprop="dateModified" datetime="2022-07-18T02:07:45+08:00">2022-07-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MarkDown文件"><a href="#MarkDown文件" class="headerlink" title="MarkDown文件"></a>MarkDown文件</h1><h3 id="VS-Code-中-MarkDown-文件快捷键"><a href="#VS-Code-中-MarkDown-文件快捷键" class="headerlink" title="VS Code 中 MarkDown 文件快捷键"></a>VS Code 中 MarkDown 文件快捷键</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ctrl + B</td>
<td style="text-align:left">切换粗体</td>
</tr>
<tr>
<td style="text-align:left">ctrl + I</td>
<td style="text-align:left">切换斜体</td>
</tr>
<tr>
<td style="text-align:left">alt + S</td>
<td style="text-align:left">切换删除线</td>
</tr>
<tr>
<td style="text-align:left">ctrl + shift + [\/]</td>
<td style="text-align:left">切换标题级别</td>
</tr>
<tr>
<td style="text-align:left">alt + shift + F</td>
<td style="text-align:left">表格自动缩进</td>
</tr>
</tbody>
</table>
</div>
<h3 id="表格中内容对齐方式"><a href="#表格中内容对齐方式" class="headerlink" title="表格中内容对齐方式"></a>表格中内容对齐方式</h3><ul>
<li><code>-:</code> 设置内容和标题栏居右对齐。</li>
<li><code>:-</code> 设置内容和标题栏居左对齐。</li>
<li><code>:-:</code> 设置内容和标题栏居中对齐。</li>
</ul>
<h1 id="使用Hexo-GitHub搭建博客"><a href="#使用Hexo-GitHub搭建博客" class="headerlink" title="使用Hexo + GitHub搭建博客"></a>使用Hexo + GitHub搭建博客</h1><h1 id="Hexo免输入密码部署到github-亲测有效！！！"><a href="#Hexo免输入密码部署到github-亲测有效！！！" class="headerlink" title="Hexo免输入密码部署到github (亲测有效！！！)"></a>Hexo免输入密码部署到github (亲测有效！！！)</h1><p>1.设置SSH<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.sh </span><br><span class="line">sudo ssh-keygen -t rsa -C &quot;你的注册邮箱&quot; #生成ssh</span><br><span class="line">sudo gedit id_rsa.pub #打开id_rsa.pub文件</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>登录到github打开设置；<br>选择SSH and GPG keys，点New SSH，<br>然后配置SSH，点击Add SSH key完成。</p>
</li>
<li><p>接下来测试配置是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果出现以下内容即表示配置完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>4.修改_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xxxx/xxxx.github.io.git</span></span><br><span class="line">  <span class="comment">#格式必须是上述格式</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:StudyingShao/StudyingShao.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">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</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">StudyingShao</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">shao_study@163.com</span></span><br></pre></td></tr></table></figure>
<ol>
<li>最后<code>hexo d</code>部署即可</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/01/cuda-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/01/cuda-7/" class="post-title-link" itemprop="url">CUDA学习随记7 Asynchronous Barrier</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-01 22:56:18" itemprop="dateCreated datePublished" datetime="2022-07-01T22:56:18+08:00">2022-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-18 16:58:07" itemprop="dateModified" datetime="2022-07-18T16:58:07+08:00">2022-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CUDA学习随记7-B-25-Asynchronous-Barrier"><a href="#CUDA学习随记7-B-25-Asynchronous-Barrier" class="headerlink" title="CUDA学习随记7 B.25. Asynchronous Barrier"></a>CUDA学习随记7 B.25. Asynchronous Barrier</h1><ol>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/06/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e/">CUDA, 软件抽象的幻影背后</a></li>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/08/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%ba%8c/">CUDA, 软件抽象的幻影背后 之二</a></li>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/13/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%b8%89/">CUDA, 软件抽象的幻影背后 之三</a></li>
</ol>
<p>CUDA Samples里面有好多有意思的代码，多学多看</p>
<p>6_Advanced/jacobiCudaGraphs<br>0_Simple\cudaTensorCoreGemm</p>
<blockquote>
<p><strong>References:</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#aw-barrier">CUDA C++ Programming Guide: B.25. Asynchronous Barrier</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-mbarrier">PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier</a></li>
</ol>
</blockquote>
<h2 id="CUDA-C-Programming-Guide-B-25-Asynchronous-Barrier"><a href="#CUDA-C-Programming-Guide-B-25-Asynchronous-Barrier" class="headerlink" title="CUDA C++ Programming Guide: B.25. Asynchronous Barrier"></a>CUDA C++ Programming Guide: B.25. Asynchronous Barrier</h2><h2 id="异步barrier"><a href="#异步barrier" class="headerlink" title="异步barrier"></a>异步barrier</h2><p>std::barrier的GPU实现，允许用户指定barrier对象的范围。</p>
<p>Devices of compute capability 8.0 or higher provide <strong>hardware acceleration</strong> for barrier operations and integration of these barriers with the <strong>memcpy_async</strong> feature.<br>CC 8.0及以上的设备对barrier拥有硬件加速，且集成了memcpy_async的特性（用于异步拷贝的同步）。</p>
<p>On devices with compute capability below 8.0 but starting 7.0, these barriers are available without hardware acceleration.<br>介于CC 7.0与8.0之间的设备具有barrier指令，但没有硬件加速。</p>
<h3 id="B-25-1-Simple-Synchronization-Pattern-简单同步模式"><a href="#B-25-1-Simple-Synchronization-Pattern-简单同步模式" class="headerlink" title="B.25.1. Simple Synchronization Pattern 简单同步模式"></a>B.25.1. Simple Synchronization Pattern 简单同步模式</h3><p>Without the arrive/wait barrier, synchronization is achieved using __syncthreads() (to synchronize all threads in a block) or group.sync() when using Cooperative Groups.</p>
<p>不使用barrier时，GPU拥有两种同步方式：</p>
<ol>
<li>__syncthreads()：同步一个block中的所有threads。</li>
<li>group.sync()：同步整个Cooperative Groups。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">simple_sync</span><span class="params">(<span class="type">int</span> iteration_count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iteration_count; ++i) &#123;</span><br><span class="line">        <span class="comment">/* code before arrive */</span></span><br><span class="line">        block.<span class="built_in">sync</span>(); <span class="comment">/* wait for all threads to arrive here */</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Cooperative Groups进行block级别同步的例子。<br>In addition, memory updates that happened before the synchronization point are guaranteed to be visible to all threads in the block after the synchronization point, i.e., equivalent to atomic_thread_fence(memory_order_seq_cst, thread_scope_block) as well as the sync.<br>除此之外，还隐含了memory fence的作用，在同步点前发生的内存修改操作，对同步点之后的所有线程均可见。这个特性__syncthreads()与group.sync()都有。保证了线程内内存读写的先后顺序。</p>
<blockquote>
<p><strong>这种模式有三个阶段：</strong></p>
<ol>
<li>sync之前的代码执行内存更新操作，且将要在sync之后被读取</li>
<li>同步点Synchronization point</li>
<li>sync之后的代码，拥有对sync之前发生的内存更新操作的可见性</li>
</ol>
</blockquote>
<p>一个同步 + 一个Memory Fence</p>
<h3 id="B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-时间分割同步-与-同步的五个阶段"><a href="#B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-时间分割同步-与-同步的五个阶段" class="headerlink" title="B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段"></a>B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段</h3><p>The temporally-split synchronization pattern with the std::barrier is as follows.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">compute</span><span class="params">(<span class="type">float</span>* data, <span class="type">int</span> curr_iteration)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">split_arrive_wait</span><span class="params">(<span class="type">int</span> iteration_count, <span class="type">float</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> barrier = cuda::barrier&lt;cuda::thread_scope_block&gt;;</span><br><span class="line">    <span class="comment">// C++11引入，相当于typedef，定义类型别名</span></span><br><span class="line">    <span class="comment">// cuda::barrier&lt;cuda::thread_scope_block&gt;;作用范围为block级别的cuda::barrier类型</span></span><br><span class="line"></span><br><span class="line">    __shared__  barrier bar;</span><br><span class="line">    <span class="comment">// 放在shared mem中的cuda::barrier，作用于整个block</span></span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line">    <span class="comment">// 一个Cooperative Groups，定义范围为整个block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// block.thread_rank()，Cooperative Groups专用，返回线程的组内索引号</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用0号线程初始化存储于shared mem中的cuda::barrier</span></span><br><span class="line">        <span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Initialize the barrier with expected arrival count</span></span><br><span class="line">        <span class="comment">// expected arrival count这里为block size</span></span><br><span class="line">    &#125;</span><br><span class="line">    block.<span class="built_in">sync</span>();<span class="comment">// Cooperative Groups同步，其他线程等待0号线程初始化cuda::barrier结束，并在同步点之后对shared mem中的cuda::barrier拥有可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> curr_iter = <span class="number">0</span>; curr_iter &lt; iteration_count; ++curr_iter) &#123;</span><br><span class="line">        <span class="comment">/* code before arrive */</span></span><br><span class="line">       barrier::arrival_token token = bar.<span class="built_in">arrive</span>(); <span class="comment">/* this thread arrives. Arrival does not block a thread */</span></span><br><span class="line">       <span class="comment">// 先执行完的线程先开始其他工作，做完之后再bar.wait()等待其他线程到达bar.arrive()，从而减少每个线程等待的时间</span></span><br><span class="line">       <span class="built_in">compute</span>(data, curr_iter);</span><br><span class="line">       bar.<span class="built_in">wait</span>(std::<span class="built_in">move</span>(token)); <span class="comment">/* wait for all threads participating in the barrier to complete bar.arrive()*/</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>
<p>In this pattern, the synchronization point (<strong>block.sync()</strong>) is split into an arrive point (<strong>bar.arrive()</strong>) and a wait point (<strong>bar.wait(std::move(token))</strong>). A thread begins participating in a <strong>cuda::barrier</strong> with its first call to <strong>bar.arrive()</strong>.<br>此模式下原来的一个同步点block.sync()被分割为了一个到达点bar.arrive()与一个等待点bar.wait(std::move(token))。当一个线程首次执行到bar.arrive()时，视为其开始参与到cuda::barrier中。</p>
<p>When a thread calls bar.wait(std::move(token)) it will be blocked until participating threads have completed bar.arrive() the expected number of times as specified by the expected arrival count argument passed to init().<br>当一个线程执行到bar.wait(std::move(token))，此线程将被blocked，直到参与到cuda::barrier中的线程执行了期望次数的bar.arrive()。这个期望次数在一开始使用init()函数初始化cuda::barrier时指定。<br>比如示例代码中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Initialize the barrier with expected arrival count</span></span><br></pre></td></tr></table></figure><br>为使用block size初始化cuda::barrier，等于对block中所有线程的同步操作。</p>
<p><strong>Memory updates that happen before participating threads’ call to bar.arrive() are guaranteed to be visible to participating threads after their call to bar.wait(std::move(token)).</strong><br>这种方式也有memory fence的功能，区别是发生在bar.arrive()之前的内存修改将会对bar.wait()之后的代码可见。</p>
<p>Note that the call to bar.arrive() does not block a thread, it can proceed with other work that does not depend upon memory updates that happen before other participating threads’ call to bar.arrive().<br>bar.arrive()并不会阻塞一个线程继续执行，只有bar.wait()会，因此在线程到达bar.arrive()后，可以在等待其他线程到达bar.arrive()之前，继续执行一些不依赖于由其他参与线程到达bar.arrive()之前进行的内存修改的工作。</p>
<blockquote>
<p><strong>这种arrive之后wait的模式有五个阶段：</strong></p>
<ol>
<li>arrive之前的代码执行内存更新操作，且将会在wait之后被读取</li>
<li>arrive point 到达点，含有隐式的memory fence，等价于<br><strong>atomic_thread_fence(memory_order_seq_cst, thread_scope_block) 顺序一致模型</strong></li>
<li>arrive与wait之间的代码，一些不依赖其他线程在arrive之前进行的内存更新操作的工作。</li>
<li>wait point 等待点，等待执行arrive的数量满足要求。</li>
<li>wait之后的代码，拥有对arrive之前发生的内存更新操作的可见性。</li>
</ol>
</blockquote>
<h3 id="B-25-3-Bootstrap-Initialization-Expected-Arrival-Count-and-Participation-初始化、预期到达计数、参与性"><a href="#B-25-3-Bootstrap-Initialization-Expected-Arrival-Count-and-Participation-初始化、预期到达计数、参与性" class="headerlink" title="B.25.3. Bootstrap Initialization, Expected Arrival Count, and Participation 初始化、预期到达计数、参与性"></a>B.25.3. Bootstrap Initialization, Expected Arrival Count, and Participation 初始化、预期到达计数、参与性</h3><p>Initialization must happen before any thread begins participating in a cuda::barrier.<br>cuda::barrier的初始化必须happen before任意线程开始参与cuda::barrier。<br>happen before具有对内存状态的可见性，也就是说其他线程必须对初始化之后的结果可见。<br>cuda::barrier对线程participating的定义为线程调用bar.arrive()开始。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">init_barrier</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    __shared__ cuda::barrier&lt;cuda::thread_scope_block&gt; bar;</span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Single thread initializes the total expected arrival count.</span></span><br><span class="line">    &#125;</span><br><span class="line">    block.<span class="built_in">sync</span>();         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数init()来为cuda::barrier进行初始化，其第二个参数为expected arrival count (期望到达数量)，指期待参与线程执行bar.arrive()的次数，到达这个数量后，线程于bar.wait(std::move(token))处unblocked。</p>
<p>A cuda::barrier is flexible in specifying how threads participate (split arrive/wait) and which threads participate. In contrast this_thread_block.sync() from cooperative groups or <strong>syncthreads() is applicable to whole-thread-block and </strong>syncwarp(mask) is a specified subset of a warp. If the intention of the user is to synchronize a full thread block or a full warp we recommend using <strong>syncthreads() and </strong>syncwarp(mask) respectively for <strong>performance reasons</strong>.<br>cuda::barrier可以自由指定参与其中的线程与线程参与的方式，相比之下cooperative groups (指定为整个block) 或<strong>syncthreads()作用于整个block，而</strong>syncwarp(mask)作用于一个warp的子集 (具体参与其中的线程lane由mask对应bit位为 0/1 指定 不参与/参与)<br>如果希望对block或warp进行同步，使用<strong>syncthreads()与</strong>syncwarp(mask)性能更好。</p>
<h3 id="B-25-4-A-Barrier’s-Phase-Arrival-Countdown-Completion-and-Reset-Barrier的四种状态：到达、倒计时、完成、重置"><a href="#B-25-4-A-Barrier’s-Phase-Arrival-Countdown-Completion-and-Reset-Barrier的四种状态：到达、倒计时、完成、重置" class="headerlink" title="B.25.4. A Barrier’s Phase: Arrival, Countdown, Completion, and Reset Barrier的四种状态：到达、倒计时、完成、重置"></a>B.25.4. A Barrier’s Phase: Arrival, Countdown, Completion, and Reset Barrier的四种状态：到达、倒计时、完成、重置</h3><p>A cuda::barrier counts down from the expected arrival count to zero as participating threads call bar.arrive(). When the countdown reaches zero, a cuda::barrier is complete for the current phase. When the last call to bar.arrive() causes the countdown to reach zero, the countdown (计数器) is <strong>automatically</strong> and <strong>atomically</strong> reset. The reset assigns <strong>the countdown to the expected arrival count</strong>, and moves the cuda::barrier to the next phase.</p>
<p>A token object (记号对象) of class <strong>cuda::barrier::arrival_token</strong>, as <strong>returned from token=bar.arrive()</strong>, is associated with the current phase of the barrier. A call to bar.wait(std::move(token)) blocks the calling thread while the cuda::barrier is in the current phase, i.e., while <strong>the phase associated with the token matches the phase of the cuda::barrier</strong>. If the phase is advanced (because the countdown reaches zero) before the call to bar.wait(std::move(token)) then the thread does not block; if the phase is advanced while the thread is blocked in bar.wait(std::move(token)), the thread is unblocked.<br>bar.wait(std::move(token))函数会block其中cuda::barrier与其参数token处于相同阶段的线程，如果线程的阶段更超前，则unblocked。</p>
<blockquote>
<p>std::move语句的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用来使用该值，避免了使用左值对象赋值时，调用拷贝构造函数，具有更佳的性能。<br>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。</p>
<p>std::move，移动构造函数。<br>通过移动构造，<strong>b指向a的资源，a不再拥有资源 (资源所有权的转移) </strong>，这里的资源，可以是动态申请的内存，网络链接，打开的文件，也可以是本例中的string。<strong>这时候访问a的行为时未定义的</strong>，比如，如果资源是动态内存，a被移动之后，再次访问a的资源，根据移动构造函数的定义，可能是空指针，如果是资源上文的string，移动之后，a的资源为空字符串（string被移动之后，为空字符串）。</p>
<center><img src="/2022/07/01/cuda-7/1.jpg" width="100%" height="100%"></center>

</blockquote>
<ul>
<li>A thread’s calls to token=bar.arrive() and bar.wait(std::move(token)) must be <strong>sequenced</strong> such that token=bar.arrive() occurs during the cuda::barrier’s current phase, and bar.wait(std::move(token)) occurs during the same or next phase.<br><code>token=bar.arrive()</code>与<code>bar.wait(std::move(token))</code>必须有严格的先后顺序</li>
<li>A thread’s call to bar.arrive() must occur when the barrier’s counter is non-zero. After barrier initialization, if a thread’s call to bar.arrive() causes the countdown to reach zero then a call to bar.wait(std::move(token)) must happen before the barrier can be reused for a subsequent call to bar.arrive().<br>必须在<code>cuda::barrier</code>的countdown非0的时候才能调用<code>bar.arrive()</code>。在初始化<code>cuda::barrier</code>之后，如果任一线程调用<code>bar.arrive()</code>导致countdown到达0，则此时必须调用一次<code>bar.wait(std::move(token))</code>，才可将<code>cuda::barrier</code> reset，从而reuse这个<code>cuda::barrier</code>。</li>
<li>bar.wait() must only be called using a token object of the current phase or the immediately preceding phase. For any other values of the token object, the behavior is undefined.</li>
</ul>
<h3 id="B-25-5-Spatial-Partitioning-also-known-as-Warp-Specialization-空间划分-warp专用"><a href="#B-25-5-Spatial-Partitioning-also-known-as-Warp-Specialization-空间划分-warp专用" class="headerlink" title="B.25.5. Spatial Partitioning (also known as Warp Specialization)  空间划分 (warp专用)"></a>B.25.5. Spatial Partitioning (also known as Warp Specialization)  空间划分 (warp专用)</h3><p>A thread block can be spatially partitioned such that warps are specialized to <strong>perform independent computations</strong>. Spatial partitioning is used in a <strong>producer</strong> or <strong>consumer</strong> pattern, where one subset of threads produces data that is concurrently consumed by the other (disjoint) subset of threads.<br>block中线程按照warp划分，不同的warp间可独立执行不同的指令 (disjoint)。</p>
<p>A producer/consumer spatial partitioning pattern requires two one sided synchronizations to manage a data buffer between the producer and consumer.<br>producer/consumer空间划分方式需要在producer与consumer中分别进行单侧同步。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Producer</th>
<th>Consumer</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait for buffer to be ready to be filled</td>
<td>signal buffer is ready to be filled</td>
</tr>
<tr>
<td>produce data and fill the buffer</td>
<td></td>
</tr>
<tr>
<td>signal buffer is filled</td>
<td>wait for buffer to be filled</td>
</tr>
<tr>
<td></td>
<td>consume data in filled buffer</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> barrier = cuda::barrier&lt;cuda::thread_scope_block&gt;;</span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">producer</span><span class="params">(barrier ready[], barrier filled[], <span class="type">float</span>* buffer, <span class="type">float</span>* in, <span class="type">int</span> N, <span class="type">int</span> buffer_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (N/buffer_len); ++i) &#123;</span><br><span class="line">        ready[i%<span class="number">2</span>].<span class="built_in">arrive_and_wait</span>(); <span class="comment">/* wait for buffer_(i%2) to be ready to be filled */</span></span><br><span class="line">        <span class="comment">// 初始情况下所有producer线程执行一次arrive_and_wait，此函数为arrive之后wait，因此结合consumer中的线程，block中所有线程初始时均执行了一次arrive，此时ready[i%2] barrier的countdown由初始化的block size减至0，此时此处的arrive_and_wait中包含的wait不再block producer线程</span></span><br><span class="line">        <span class="comment">// 此时ready[i%2] barrier reset，其countdown重新恢复至block size</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* produce, i.e., fill in, buffer_(i%2)  */</span></span><br><span class="line">        <span class="comment">// producer线程填充 buffer</span></span><br><span class="line"></span><br><span class="line">        barrier::arrival_token token = filled[i%<span class="number">2</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_(i%2) is filled */</span></span><br><span class="line">        <span class="comment">// 线程填充过之后会将对应的filled[i%2] barrier的countdown减至warp size</span></span><br><span class="line">        <span class="comment">// 并++i进入下一循环，使得另一个ready barrier的countdown减至warpsize</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">consumer</span><span class="params">(barrier ready[], barrier filled[], <span class="type">float</span>* buffer, <span class="type">float</span>* out, <span class="type">int</span> N, <span class="type">int</span> buffer_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    barrier::arrival_token token1 = ready[<span class="number">0</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_0 is ready for initial fill */</span></span><br><span class="line">    barrier::arrival_token token2 = ready[<span class="number">1</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_1 is ready for initial fill */</span></span><br><span class="line">    <span class="comment">// 以上代码每个consumer线程都会执行一次，因此会使得两个ready barrier的countdown均减至一个warp size (block size = 2 * warp size)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (N/buffer_len); ++i) &#123;</span><br><span class="line">        filled[i%<span class="number">2</span>].<span class="built_in">arrive_and_wait</span>(); <span class="comment">/* wait for buffer_(i%2) to be filled */</span></span><br><span class="line">        <span class="comment">// 等待producer填充数据结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* consume buffer_(i%2) */</span></span><br><span class="line">        <span class="comment">// consumer使用buffer中已经填充好的数据</span></span><br><span class="line"></span><br><span class="line">        barrier::arrival_token token = ready[i%<span class="number">2</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_(i%2) is ready to be re-filled */</span></span><br><span class="line">        <span class="comment">// 提示对应buffer中的数据已经使用完毕，可以填充新的数据进来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N is the total number of float elements in arrays in and out</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">producer_consumer_pattern</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> buffer_len, <span class="type">float</span>* in, <span class="type">float</span>* out)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shared memory buffer declared below is of size 2 * buffer_len</span></span><br><span class="line">    <span class="comment">// so that we can alternatively work between two buffers. </span></span><br><span class="line">    <span class="comment">// buffer_0 = buffer and buffer_1 = buffer + buffer_len</span></span><br><span class="line">    __shared__ <span class="keyword">extern</span> <span class="type">float</span> buffer[];</span><br><span class="line">    <span class="comment">// 动态分配的shared memory，大小在launch kernel时指定，为 2 * buffer_len</span></span><br><span class="line">    <span class="comment">// double buffer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bar[0] and bar[1] track if buffers buffer_0 and buffer_1 are ready to be filled, </span></span><br><span class="line">    <span class="comment">// while bar[2] and bar[3] track if buffers buffer_0 and buffer_1 are filled-in respectively</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ping-Pong buffer，两个标记填充完毕，两个标记使用完毕</span></span><br><span class="line">    __shared__ barrier bar[<span class="number">4</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line">    <span class="comment">// block.thread_rank()函数返回cooperative_groups中线程Index</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="built_in">init</span>(bar + block.<span class="built_in">thread_rank</span>(), block.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 用四个线程，每个线程负责初始化一个cuda::barrier</span></span><br><span class="line">        <span class="comment">// barrier的countdown为block size</span></span><br><span class="line">    block.<span class="built_in">sync</span>();</span><br><span class="line">    <span class="comment">// block同步，顺便隐含一个memory fence，后续线程等待cuda::barrier初始化结束，并对初始化之后的结果可见</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// block size为两个warp，前32个作为producer，后32个为consumer</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() &lt; warpSize)</span><br><span class="line">        <span class="built_in">producer</span>(bar, bar+<span class="number">2</span>, buffer, in, N, buffer_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">consumer</span>(bar, bar+<span class="number">2</span>, buffer, out, N, buffer_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="/2022/07/01/cuda-7/1.png" width="100%" height="100%"></center>

<p>In this example the first warp is specialized as the producer and the remaining warps are specialized as the consumer. All producer and consumer threads participate (call <code>bar.arrive()</code> or <code>bar.arrive_and_wait()</code>) in each of the four <code>cuda::barriers</code> so the expected arrival counts are equal to <code>block.size()</code>.<br>在这个示例中，通过if语句，将第一个warp指定为producer，而其余warps指定为consumer。所有的线程都通过调用<code>bar.arrive()</code> or <code>bar.arrive_and_wait()</code>函数参与到了四个barriers中。所以四个barrier的expected arrival counts均设置为block size。</p>
<p>A producer thread waits for the consumer threads to <strong>signal</strong> that the shared memory buffer can be filled. In order to wait for a <code>cuda::barrier</code> a producer thread must first arrive on that <code>ready[i%2].arrive()</code> to get a <strong>token</strong> and then <code>ready[i%2].wait(token)</code> with that token. For simplicity <code>ready[i%2].arrive_and_wait()</code> combines these operations.<br>wait函数需要使用arrive函数返回的token进行配对，而<code>ready[i%2].arrive_and_wait()</code>简化了这个过程，其相当于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line"><span class="comment">/* is equivalent to */</span></span><br><span class="line">bar.<span class="built_in">wait</span>(bar.<span class="built_in">arrive</span>());</span><br></pre></td></tr></table></figure></p>
<p>Producer threads compute and fill the ready buffer, they then <strong>signal</strong> that the buffer is filled by arriving on the filled barrier, <code>filled[i%2].arrive()</code>. A producer thread does not wait at this point, instead it waits until the next iteration’s buffer (double buffering) is ready to be filled.<br>producer负责计算和填充已经ready的buffer，接着通过调用<code>filled[i%2].arrive()</code>发出buffer is filled的信号。producer不等待这个filled信号，而是等待consumer使用完毕之后发出的ready信号。</p>
<p>A consumer thread begins by signaling that both buffers are ready to be filled. A consumer thread does not wait at this point, instead it waits for this iteration’s buffer to be filled, <code>filled[i%2].arrive_and_wait()</code>. After the consumer threads consume the buffer they signal that the buffer is ready to be filled again, <code>ready[i%2].arrive()</code>, and then wait for the next iteration’s buffer to be filled.<br>consumer在一开始发出两个buffer均已经ready，可以进行填充的信号。而consumer不等待这个filled信号，而是等待producer发出的填充完毕的filled信号，通过调用函数<code>filled[i%2].arrive_and_wait()</code>。当consumer使用完毕一个buffer之后，其通过调用<code>ready[i%2].arrive()</code>，发出ready信号，告知producer可以对这个buffer进行填充，并等待下一个buffer to be filled。</p>
<p><strong>producer的循环流程为：</strong></p>
<ol>
<li>等待consumer的ready信号</li>
<li>填充ready的buffer</li>
<li>发出填充完毕的filled信号</li>
</ol>
<p><strong>consumer的循环流程为：</strong></p>
<ol>
<li>等待producer的filled信号</li>
<li>使用filled的buffer</li>
<li>发出使用完毕的ready信号</li>
</ol>
<h3 id="B-25-6-Early-Exit-Dropping-out-of-Participation-早退，提前退出barrier"><a href="#B-25-6-Early-Exit-Dropping-out-of-Participation-早退，提前退出barrier" class="headerlink" title="B.25.6. Early Exit (Dropping out of Participation) 早退，提前退出barrier"></a>B.25.6. Early Exit (Dropping out of Participation) 早退，提前退出barrier</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">bool</span> <span class="title">condition_check</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">early_exit_kernel</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> barrier = cuda::barrier&lt;cuda::thread_scope_block&gt;;</span><br><span class="line">    __shared__ barrier bar;</span><br><span class="line">    <span class="comment">// 依旧放在shared mem中</span></span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line">    <span class="comment">// 定义整个block为cooperative_groups</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">init</span>(&amp;bar , block.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//由0号线程完成barrier初始化工作，the expected arrival counts设置为block size </span></span><br><span class="line">    block.<span class="built_in">sync</span>();</span><br><span class="line">    <span class="comment">// block同步，同时隐含mem fence，使得其他线程对0号线程的初始化结果可见</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">condition_check</span>()) &#123;</span><br><span class="line">          bar.<span class="built_in">arrive_and_drop</span>();</span><br><span class="line">          <span class="comment">// arrive和drop函数的combination，线程先执行arrive参与到barrier中，随后drop早退</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 早退的线程直接return结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* other threads can proceed normally */</span></span><br><span class="line">        barrier::arrival_token token = bar.<span class="built_in">arrive</span>();</span><br><span class="line">        <span class="comment">/* code between arrive and wait */</span></span><br><span class="line">        bar.<span class="built_in">wait</span>(std::<span class="built_in">move</span>(token)); <span class="comment">/* wait for all threads to arrive */</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bar.arrive_and_drop();</code><br>This operation arrives on the <code>cuda::barrier</code> to fulfill the participating thread’s obligation to arrive in the current phase, and then decrements the expected arrival count for the next phase so that this thread is no longer expected to arrive on the barrier.<br>这个操作首先执行arrive，履行参与线程的义务，使barrier计数达到the expected arrival count，从而进入下一phase，接下来执行drop操作，退出barrier的参与，同时<strong>减少barrier在下一个phase中的the expected arrival count</strong>，因为此线程退出了，永远不会arrive。</p>
<h3 id="B-25-7-Memory-Barrier-Primitives-Interface-内存barrier原语接口-mbarrier"><a href="#B-25-7-Memory-Barrier-Primitives-Interface-内存barrier原语接口-mbarrier" class="headerlink" title="B.25.7. Memory Barrier Primitives Interface  内存barrier原语接口 (mbarrier)"></a>B.25.7. Memory Barrier Primitives Interface  内存barrier原语接口 (mbarrier)</h3><blockquote>
<p><strong>Primitives 原语</strong><br>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中<strong>不可被中断</strong>。原语一旦开始执行，就要连续执行完，不允许中断，否则就会出现操作错误，造成系统混乱。</p>
</blockquote>
<ul>
<li>需要include头文件<code>&lt;cuda_awbarrier_primitives.h&gt;</code></li>
</ul>
<h4 id="B-25-7-1-Data-Types-数据类型"><a href="#B-25-7-1-Data-Types-数据类型" class="headerlink" title="B.25.7.1. Data Types 数据类型"></a>B.25.7.1. Data Types 数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="comment">/* implementation defined */</span> <span class="type">__mbarrier_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="comment">/* implementation defined */</span> <span class="type">__mbarrier_token_t</span>;  </span><br></pre></td></tr></table></figure>
<h4 id="B-25-7-2-Memory-Barrier-Primitives-API-原语API"><a href="#B-25-7-2-Memory-Barrier-Primitives-API-原语API" class="headerlink" title="B.25.7.2. Memory Barrier Primitives API 原语API"></a>B.25.7.2. Memory Barrier Primitives API 原语API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> __mbarrier_maximum_count();</span><br><span class="line"><span class="type">void</span> __mbarrier_init(<span class="type">__mbarrier_t</span>* bar, <span class="type">uint32_t</span> expected_count); </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化函数的原语函数</strong></li>
<li>bar must be a pointer to <strong>shared</strong> memory.  <strong>bar指针指向的mbarrier对象必须放在shared mem中！</strong></li>
<li>expected_count &lt;= __mbarrier_maximum_count()  </li>
<li>Initialize *bar expected arrival count for the current and next phase to expected_count.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __mbarrier_inval(<span class="type">__mbarrier_t</span>* bar); </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能：使mbarrier失效！</strong></li>
<li>bar must be a pointer to the mbarrier object residing in shared memory.  <strong>bar必须为指向放在shared mem中的mbarrier对象的指针</strong></li>
<li>Invalidation of <em>bar is required before the corresponding shared memory can be repurposed.  <em>*在重新将mbarrier所占用的shared mem分配出去之前必须先使mbarrier失效</em></em></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__mbarrier_token_t</span> __mbarrier_arrive(<span class="type">__mbarrier_t</span>* bar);    </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>bar.arrive()函数的原语函数</strong></li>
<li>Initialization of *bar must happen before this call.</li>
<li>Pending count must not be zero.</li>
<li>Atomically decrement the pending count for the current phase of the barrier.  <strong>以原子方式做countdown</strong></li>
<li>Return an arrival token associated with the barrier state immediately prior to the decrement.  <strong>返回计数-1之前反映barrier状态的token</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__mbarrier_token_t</span> __mbarrier_arrive_and_drop(<span class="type">__mbarrier_t</span>* bar);   </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>arrive_and_drop函数的原语函数，由于包含arrive函数，因此含有arrive函数的所有特性，此外还含有drop函数的特性</strong></li>
<li>Initialization of *bar must happen before this call.</li>
<li>Pending count must not be zero.</li>
<li>Atomically decrement <strong>the pending count for the current phase</strong> and <strong>expected count for the next phase</strong> of the barrier.  <strong>除了arrive会将做countdown之外，drop函数还会使线程早退，并使得the expected arrival count -1</strong></li>
<li>Return an arrival token associated with the barrier state immediately prior to the decrement.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __mbarrier_test_wait(<span class="type">__mbarrier_t</span>* bar, <span class="type">__mbarrier_token_t</span> token);  </span><br></pre></td></tr></table></figure>
<ul>
<li>token must be associated with <strong>the immediately preceding phase</strong> or <strong>current phase</strong> of *this.</li>
<li>Returns true if token is associated with the immediately preceding phase of <em>bar, otherwise returns false.  <em>*如果token为前一阶段，则返回true (还需继续等待)，使得线程wait；如果token为当前阶段，则返回false (无需继续等待)，unblock线程。</em></em></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This API has been deprecated in CUDA 11.1 </span></span><br><span class="line"><span class="comment">// 从CUDA 11.1开始，__mbarrier_pending_count函数被弃用</span></span><br><span class="line"><span class="type">uint32_t</span> __mbarrier_pending_count(<span class="type">__mbarrier_token_t</span> token);</span><br></pre></td></tr></table></figure>
<h2 id="PTX-ISA-9-7-12-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier"><a href="#PTX-ISA-9-7-12-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier" class="headerlink" title="PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier"></a>PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier</h2><h2 id="并行同步通讯指令：mbarrier"><a href="#并行同步通讯指令：mbarrier" class="headerlink" title="并行同步通讯指令：mbarrier"></a>并行同步通讯指令：mbarrier</h2><p><code>mbarrier</code> is a barrier created in <strong>shared memory</strong> that supports :</p>
<ul>
<li>Synchronizing any subset of threads within a CTA<br>同步一个block中的任意线程子集 (mbarrier本身位于shared mem中，因此只能作用于block范围内)</li>
<li>Waiting for completion of asynchronous <code>cp.async</code> operations initiated by a thread and <strong>making them visible to other threads</strong>.<br>等待线程发起的异步数据拷贝结束(cp.async，global mem to shared mem的异步数据拷贝)，并使得拷贝的结果对其他线程可见。</li>
</ul>
<blockquote>
<p>CTA (Cooperative Thread Array), CUDA程序的任务分发单位，CTA与block是同一事物在<strong>执行模型</strong>和<strong>编程模型</strong>中的表述。</p>
</blockquote>
<p>An mbarrier object is an <strong>opaque object</strong> in memory which can be initialized and invalidated using :</p>
<ul>
<li><code>mbarrier.init</code> <strong>initialize</strong></li>
<li><code>mbarrier.inval</code> <strong>invalidate</strong></li>
</ul>
<blockquote>
<p>C++ opaque object，不透明对象，其没有对外可见的属性和方法，只能 pass these objects to related functions that know how to work with them.</p>
</blockquote>
<p>Operations supported on mbarrier objects are :</p>
<ul>
<li><code>mbarrier.arrive</code></li>
<li><code>mbarrier.arrive_drop</code></li>
<li><code>mbarrier.test_wait</code></li>
<li><code>mbarrier.pending_count</code> // 按照 <a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#memory_barrier_primitives_interface">CUDA C++ Programming Guide</a> 的说法，这个在CUDA 11.1中被弃用了</li>
<li><code>cp.async.mbarrier.arrive</code> //与异步拷贝函数cp.async相关</li>
</ul>
<p>未经<code>mbarrier.init</code>初始化就对mbarrier施加操作会导致undefined behavior。</p>
<p>mbarrier operations enable threads to perform useful work <strong>after the arrival at the mbarrier</strong> and <strong>before waiting for the mbarrier to complete</strong>. The wait operation test_wait performs a <strong>non blocking test</strong> of mbarrier completion.</p>
<h3 id="9-7-12-11-1-Size-and-alignment-of-mbarrier-object"><a href="#9-7-12-11-1-Size-and-alignment-of-mbarrier-object" class="headerlink" title="9.7.12.11.1. Size and alignment of mbarrier object"></a>9.7.12.11.1. Size and alignment of mbarrier object</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Type</th>
<th style="text-align:center">Alignment (bytes)</th>
<th style="text-align:center">Memory space</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.b64</td>
<td style="text-align:center">8</td>
<td style="text-align:center">.shared</td>
</tr>
</tbody>
</table>
</div>
<h3 id="9-7-12-11-2-Contents-of-the-mbarrier-object"><a href="#9-7-12-11-2-Contents-of-the-mbarrier-object" class="headerlink" title="9.7.12.11.2. Contents of the mbarrier object"></a>9.7.12.11.2. Contents of the mbarrier object</h3><p>An opaque mbarrier object keeps track of the following information :</p>
<ul>
<li>Current phase of the mbarrier object<br>当前phase</li>
<li>Count of pending arrivals for the current phase of the mbarrier object<br>等待arrive的数量</li>
<li>Count of expected arrivals for the next phase of the mbarrier object<br>下一phase的expected arrivals count</li>
</ul>
<p>An mbarrier object progresses through a sequence of phases where each phase is defined by <strong>threads performing an expected number of arrive-on operations</strong>.<br>phase of the mbarrier: 线程进行expected number的arrive-on operation。</p>
<p>The valid range of pending arrival count and expected arrival count is [1, 220 -1].<br>pending arrival count: 待arrive的数量<br>expected arrival count: 期望arrive的数量<br>expected arrival count - pending arrival count = 已经arrive的数量</p>
<h3 id="9-7-12-11-3-Lifecycle-of-the-mbarrier-object"><a href="#9-7-12-11-3-Lifecycle-of-the-mbarrier-object" class="headerlink" title="9.7.12.11.3. Lifecycle of the mbarrier object"></a>9.7.12.11.3. Lifecycle of the mbarrier object</h3><p>The mbarrier object must be initialized prior to use.<br>使用前必须先进行初始化，不然会导致undefined behavior。</p>
<p>An mbarrier object is used to <strong>synchronize threads (within a block)</strong> and <strong>cp.async operations (除了等待完成还会使得结果对block内其他线程可见)</strong>.</p>
<p>An mbarrier object may be used to perform a sequence of such synchronizations.<br>mbarrier可重复使用，每一段使用过程对应一个phase。</p>
<p>An mbarrier object must be invalidated to repurpose its memory.<br>在重新分配mbarrier所占用的内存之前，必须先将其invalidated。</p>
<h3 id="9-7-12-11-4-Phase-of-the-mbarrier-object"><a href="#9-7-12-11-4-Phase-of-the-mbarrier-object" class="headerlink" title="9.7.12.11.4. Phase of the mbarrier object"></a>9.7.12.11.4. Phase of the mbarrier object</h3><p>The phase of an mbarrier object is <strong>the number of times the mbarrier object has been used</strong> to synchronize threads and cp.async operations. In each phase {0, 1, 2, …}, threads perform in program order :</p>
<ul>
<li>arrive-on operations to <strong>complete the current phase</strong> and</li>
<li>test-wait operations to <strong>check for the completion of the current phase</strong>.</li>
</ul>
<p>An mbarrier object is <strong>automatically reinitialized upon completion of the current phase</strong> for immediate use in the next phase. The current phase is incomplete and all prior phases are complete.<br>当前phase完成时自动初始化，以便立即开始下一phase的重复使用。</p>
<h3 id="9-7-12-11-5-Arrive-on-operation-on-mbarrier-object"><a href="#9-7-12-11-5-Arrive-on-operation-on-mbarrier-object" class="headerlink" title="9.7.12.11.5. Arrive-on operation on mbarrier object"></a>9.7.12.11.5. Arrive-on operation on mbarrier object</h3><p>An arrive-on operation, with <strong>an optional count argument (不指定默认为1)</strong>, on an mbarrier object consists of the following 2 steps :</p>
<ul>
<li><p>mbarrier signalling :<br>Signals <strong>the arrival of the executing thread</strong> OR <strong>completion of the asynchronous copy operations initiated by the executing thread</strong> on the mbarrier object. As a result of this, the pending arrival count is decremented by <strong>count</strong>. If the count argument is not specified, then <strong>it defaults to 1</strong>.<br>发出信号宣布当前执行线程arrive-on 或 当前执行线程发出的异步拷贝操作已经完成。通过将the pending arrival count减少count的方式发出这个信号，如果不指定count默认为1。</p>
</li>
<li><p>mbarrier completing the current phase :<br>If the count of <strong>the pending arrivals has reached zero</strong> then :</p>
<ul>
<li>the mbarrier object <strong>completes the current phase</strong> and <strong>transitions to the next phase</strong> and</li>
<li><strong>the pending arrival count is reinitialized to the expected arrival count</strong></li>
</ul>
<p>In other words, if all the pending arrivals of the mbarrier object have happened, the mbarrier object gets reinitialized so that it can be immediately reused and the mbarrier object transitions to the next phase.<br>如果所有的pending arrivals都arrive-on了，那么mbarrier自动初始化 (the pending arrivel count 由0重新变为 the expected arrival count)，当前phase完成，进入下一phase。</p>
</li>
</ul>
<h3 id="9-7-12-11-6-Parallel-Synchronization-and-Communication-Instructions-mbarrier-init"><a href="#9-7-12-11-6-Parallel-Synchronization-and-Communication-Instructions-mbarrier-init" class="headerlink" title="9.7.12.11.6. Parallel Synchronization and Communication Instructions: mbarrier.init"></a>9.7.12.11.6. Parallel Synchronization and Communication Instructions: mbarrier.init</h3><p><strong>mbarrier.init</strong><br>Initialize the mbarrier object.</p>
<p><strong>Syntax 语法</strong><br><code>mbarrier.init&#123;.shared&#125;.b64 [addr], count;</code><br>.shared: 存储空间为shared mem<br>.b64: 数据类型<br>count: the expected arrival count</p>
<p><strong>Description</strong><br><code>mbarrier.init</code> initializes the mbarrier object at the location specified by the address operand <code>addr</code> with the unsigned 32-bit integer <code>count</code>. The value of operand <code>count</code> must be in the range as specified in Contents of the mbarrier object.</p>
<p>Initialization of the mbarrier object involves :</p>
<ul>
<li><strong>Initializing the current phase to 0.</strong><br>所以我猜current phase其实就是当前phase中arrive-on的count</li>
<li>Initializing the expected arrival count to count.</li>
<li>Initializing the pending arrival count to count.</li>
</ul>
<p>If no state space is specified then Generic Addressing is used. If the address specified by <code>addr</code> does not fall within the address window of <code>.shared</code> state space then the behavior is undefined.<br>如果没有使用<code>.share</code>操作数指定state space，则使用Generic Addressing通用地址，此时就要求<code>addr</code>指向的地址必须位于shared mem中，否则会导致undefined behavior。</p>
<p>Supported addressing modes for operand <code>addr</code> is as described in Addresses as Operands.<br>Alignment for operand addr is as described in the Size and alignment of mbarrier object.<br><strong>8 bytes, 64 bits</strong></p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.shared .b64 shMem, shMem2;</span><br><span class="line">.reg    .b64 addr;</span><br><span class="line">.reg    .b32 %r1;</span><br><span class="line"></span><br><span class="line">cvta.shared.u64          addr, shMem2;</span><br><span class="line">mbarrier.init.b64        [addr],   %r1;</span><br><span class="line">bar.sync                 0;</span><br><span class="line">// ... other mbarrier operations on addr</span><br><span class="line">// 这里cvta.shared.u64保证了addr指向的空间位于.share state space。因此mbarrier.init.b64指令没有添加.shared。</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem], 12;</span><br><span class="line">bar.sync                 0;</span><br><span class="line">// ... other mbarrier operations on shMem</span><br></pre></td></tr></table></figure></p>
<h3 id="9-7-12-11-7-Parallel-Synchronization-and-Communication-Instructions-mbarrier-inval"><a href="#9-7-12-11-7-Parallel-Synchronization-and-Communication-Instructions-mbarrier-inval" class="headerlink" title="9.7.12.11.7. Parallel Synchronization and Communication Instructions: mbarrier.inval"></a>9.7.12.11.7. Parallel Synchronization and Communication Instructions: mbarrier.inval</h3><p><strong>mbarrier.inval</strong><br>Invalidates the mbarrier object.</p>
<p><strong>Syntax</strong><br><code>mbarrier.inval&#123;.shared&#125;.b64 [addr];</code></p>
<p><strong>Description</strong><br><code>mbarrier.inval</code> invalidates the mbarrier object at the location specified by the address operand <code>addr</code>.</p>
<p>An mbarrier object must be invalidated before using its memory location for any other purpose.<br>在将mbarrier所占用内存用作其他用途之前，必须先将mbarrier无效处理。</p>
<p>Performing any mbarrier operation except mbarrier.init on an invalidated mbarrier object results in undefined behaviour.</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.shared .b64 shmem;</span><br><span class="line">.reg    .b64 addr;</span><br><span class="line">.reg    .b32 %r1;</span><br><span class="line">.reg    .pred t0;</span><br><span class="line"></span><br><span class="line">// Example 1 :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.init.b64     [addr], %r1;</span><br><span class="line">// ... other mbarrier operations on addr</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.inval.b64    [addr];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Example 2 :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">mbarrier.init.shared.b64      [shmem], 12;</span><br><span class="line">// ... other mbarrier operations on shmem</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.inval.shared.b64 [shmem];</span><br><span class="line"></span><br><span class="line">// shmem can be reused here for unrelated use :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">st.shared.b64                 [shmem], ...;</span><br><span class="line"></span><br><span class="line">// shmem can be re-initialized as mbarrier object :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.init.shared.b64  [shmem], 24;</span><br><span class="line">// ... other mbarrier operations on shmem</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.inval.shared.b64 [shmem];</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-8-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive"><a href="#9-7-12-11-8-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive" class="headerlink" title="9.7.12.11.8. Parallel Synchronization and Communication Instructions: mbarrier.arrive"></a>9.7.12.11.8. Parallel Synchronization and Communication Instructions: mbarrier.arrive</h3><p><strong>mbarrier.arrive</strong><br>Performs <strong>arrive-on operation</strong> on the mbarrier object.</p>
<p><strong>Syntax</strong><br><code>mbarrier.arrive&#123;.shared&#125;.b64 state, [addr];</code><br><code>mbarrier.arrive.noComplete&#123;.shared&#125;.b64 state, [addr], count;</code></p>
<p><strong>Description</strong><br>A thread executing <code>mbarrier.arrive</code> performs an <strong>arrive-on operation</strong> on the mbarrier object at the location specified by the address operand <code>addr</code>. The 32-bit unsigned integer operand <code>count</code> specifies the count argument to the arrive-on operation.<br>count操作数指定实行arrive-on operation时，从the pending arrival count中减去的值。</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p>When the argument count is specified, the modifier <code>.noComplete</code> is required. A <code>mbarrier.arrive</code> operation with <code>.noComplete</code> qualifier <strong>must not cause the mbarrier to complete its current phase</strong>, otherwise the behavior is undefined.<br>当不使用默认为1的count数，而是人为指定count数值的时候，必须为<code>mbarrier.arrive</code>操作加上说明符<code>.noComplete</code>，这样的操作<strong>不能导致mbarrier完成当前phase</strong> (指the pending arrival count减去count数后变为0)，否则会导致undefined behavior。</p>
<p>The value of the operand count must be in the range as specified in Contents of the mbarrier object.</p>
<p><code>mbarrier.arrive</code> returns <strong>an opaque 64-bit register capturing the phase of the mbarrier object prior to the arrive-on operation</strong> in the destination operand (输出操作数) <code>state</code>. Contents of the <code>state</code> operand are implementation specific. Optionally, sink symbol ‘_’ can be used for the state argument.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p>Support for sink symbol ‘_’ as the destination operand is introduced in PTX ISA version 7.1.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.reg .b32 cnt;</span><br><span class="line">.reg .b64 %r&lt;3&gt;, addr;</span><br><span class="line">.shared .b64 shMem, shMem2;</span><br><span class="line"></span><br><span class="line">cvta.shared.u64          addr, shMem2;</span><br><span class="line"></span><br><span class="line">mbarrier.arrive.shared.b64     %r0, [shMem];</span><br><span class="line"></span><br><span class="line">mbarrier.arrive.noComplete.b64 %r1, [addr], 2;</span><br><span class="line">mbarrier.arrive.noComplete.b64 %r2, [addr], cnt;</span><br><span class="line">// 后两个指定了count，因此必须加上.noComplete说明符</span><br><span class="line">// 且后两个操作不能造成当前phase完成！</span><br></pre></td></tr></table></figure></p>
<h3 id="9-7-12-11-9-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive-drop"><a href="#9-7-12-11-9-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive-drop" class="headerlink" title="9.7.12.11.9. Parallel Synchronization and Communication Instructions: mbarrier.arrive_drop"></a>9.7.12.11.9. Parallel Synchronization and Communication Instructions: mbarrier.arrive_drop</h3><p><strong>mbarrier.arrive_drop</strong><br>Decrements <strong>the expected count</strong> of the mbarrier object and performs <strong>arrive-on operation</strong>.</p>
<p><strong>Syntax</strong><br><code>mbarrier.arrive_drop&#123;.shared&#125;.b64 state, [addr];</code><br><code>mbarrier.arrive_drop.noComplete&#123;.shared&#125;.b64 state, [addr], count;</code></p>
<p><strong>Description</strong><br>A thread executing <code>mbarrier.arrive_drop</code> on the mbarrier object at the location specified by the address operand <code>addr</code> performs the following steps:</p>
<ul>
<li>Decrements <strong>the expected arrival count</strong> of the mbarrier object by the value specified by the 32-bit integer operand <code>count</code>. If count operand is not specified, it defaults to 1.</li>
<li>Performs <strong>an arrive-on operation</strong> on the mbarrier object. The operand <code>count</code> specifies the <code>count</code> argument to the arrive-on operation.</li>
</ul>
<p><strong>The decrement done in the expected arrivals count of the mbarrier object will be for all the subsequent phases of the mbarrier object.</strong><br>调用mbarrier.arrive_drop后，使得the expected arrival count永久减少，这对后续phases均产生影响。</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p>When the argument count is specified, the modifier .noComplete is required. A mbarrier.arrive_drop with .noComplete qualifier must not complete the mbarrier, otherwise the behavior is undefined.<br>这个特性与arrive相同，指定了count后需要添加说明符<code>.noComplete</code>，且此操作不能完成当前阶段，否则导致undefined behavior。</p>
<p>The value of the operand count must be in the range as specified in Contents of the mbarrier object.</p>
<p>A thread that wants to either <strong>exit</strong> or opt (选择) <strong>out of participating</strong> in the arrive-on operation can use <code>mbarrier.arrive_drop</code> to drop itself from the mbarrier.<br>必须先arrive-on之后才能drop！因为当前mbarrier的the expected arrival count是包含此线程的，换句话说mbarrier在期待此线程arrive-on，如果没有arrive-on直接drop，会使得mbarrier永远等不到此线程导致死锁。</p>
<p><code>mbarrier.arrive_drop</code> returns <strong>an opaque 64-bit register capturing the phase of the mbarrier object prior to the arrive-on operation</strong> in the destination operand <code>state</code>. Contents of the returned <code>state</code> are implementation specific. Optionally, sink symbol ‘_’ can be used for the state argument.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.reg .b64 %r1;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">@p mbarrier.arrive_drop.shared.b64 _, [shMem];</span><br><span class="line">@p exit;</span><br><span class="line">@p2 mbarrier.arrive_drop.noComplete.shared.b64 _, [shMem], %a;</span><br><span class="line">// 指定了count，因此添加了.noComplete</span><br><span class="line">@p2 exit;</span><br><span class="line">..</span><br><span class="line">@!p mbarrier.arrive.shared.b64   %r1, [shMem];</span><br><span class="line">@!p mbarrier.test_wait.shared.b64  q, [shMem], %r1;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-10-Parallel-Synchronization-and-Communication-Instructions-cp-async-mbarrier-arrive"><a href="#9-7-12-11-10-Parallel-Synchronization-and-Communication-Instructions-cp-async-mbarrier-arrive" class="headerlink" title="9.7.12.11.10. Parallel Synchronization and Communication Instructions: cp.async.mbarrier.arrive"></a>9.7.12.11.10. Parallel Synchronization and Communication Instructions: cp.async.mbarrier.arrive</h3><p><strong>cp.async.mbarrier.arrive</strong><br>Makes the mbarrier object track <strong>all prior <code>cp.async</code> operations initiated by the executing thread</strong>.<br>追踪执行线程先前所有的<code>cp.async</code> operations。</p>
<p><strong>Syntax</strong><br><code>cp.async.mbarrier.arrive&#123;.noinc&#125;&#123;.shared&#125;.b64 [addr];</code></p>
<p><strong>Description</strong><br>Causes an arrive-on operation to be triggered by the system on the mbarrier object upon <strong>the completion of all prior cp.async operations initiated by the executing thread</strong>. The mbarrier object is at the location specified by the operand <code>addr</code>. The arrive-on operation is asynchronous to execution of cp.async.mbarrier.arrive.</p>
<p>When <code>.noinc</code> modifier is not specified, <strong>the pending count of the mbarrier object is incremented by 1 prior to the asynchronous arrive-on operation</strong>. This results in a zero-net change for the pending count from the asynchronous arrive-on operation during the current phase. The pending count of the mbarrier object after the increment should not exceed the limit as mentioned in Contents of the mbarrier object. Otherwise, the behavior is undefined.</p>
<p>When the <code>.noinc</code> modifier is specified, <strong>the increment to the pending count of the mbarrier object is not performed</strong>. Hence the decrement of the pending count done by the asynchronous arrive-on operation must be accounted for in the initialization of the mbarrier object.</p>
<blockquote>
<p>由于线程的arrive-on与cp.async的asynchronous arrive-on均会导致the pending arrival count减少。因此cp.async.mbarrier.arrive额外增加了一个<code>.noinc</code>修饰符，当不添加这个修饰符时，cp.async.mbarrier.arrive操作默认会在asynchronous arrive-on操作前先将the pending count + 1，这样在初始化mbarrier时，就不需要额外计算asynchronous arrive-on的数量，再将这个数量加到the expected arrival count中了。如果不指定<code>.noinc</code>修饰符，那么cp.async.mbarrier.arrive就不会在asynchronous arrive-on操作前对the pending count + 1，那么在mbarrier初始化的时候，就需要额外考虑由the asynchronous arrive-on operation带来的the pending count的减少。</p>
</blockquote>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Example 1: no .noinc</span><br><span class="line">mbarrier.init.shared.b64 [shMem], threadCount;</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard1], [gbl1], 4;</span><br><span class="line">cp.async.cg.shared.global [shard2], [gbl2], 16;</span><br><span class="line">// 这里initiate了两次cp.async异步数据拷贝操作</span><br><span class="line">....</span><br><span class="line">// Absence of .noinc accounts for arrive-on from completion of prior cp.async operations.</span><br><span class="line">// So mbarrier.init must only account for arrive-on from mbarrier.arrive.</span><br><span class="line">// 不添加.noinc modifier使得由completion of prior cp.async operations带来的arrive-on操作不被计数，因此mbarrier.init只需要考虑由mbarrier.arrive所带来的arrive-on即可。</span><br><span class="line"></span><br><span class="line">cp.async.mbarrier.arrive.shared.b64 [shMem];</span><br><span class="line">// 这里不会导致the pending count - 1</span><br><span class="line">....</span><br><span class="line">mbarrier.arrive.shared.b64 state, [shMem];</span><br><span class="line">// 这里会导致the pending count - 1</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64 p, [shMem], state;</span><br><span class="line">@!p bra waitLoop;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Example 2: with .noinc</span><br><span class="line">// Tracks arrive-on from mbarrier.arrive and cp.async.mbarrier.arrive.</span><br><span class="line">// 添加了 .noinc modifier，此时需要追踪来自mbarrier.arrive与cp.async.mbarrier.arrive所带来的arrive-on操作</span><br><span class="line"></span><br><span class="line">// All threads participating in the mbarrier perform cp.async</span><br><span class="line">mov.b32 copyOperationCnt, threadCount;</span><br><span class="line">// copyOperationCnt = threadCount</span><br><span class="line"></span><br><span class="line">// 3 arrive-on operations will be triggered per-thread</span><br><span class="line">mul.lo.u32 copyArrivalCnt, copyOperationCnt, 3;</span><br><span class="line">// copyArrivalCnt = copyOperationCnt * 3</span><br><span class="line"></span><br><span class="line">add.u32 totalCount, threadCount, copyArrivalCnt;</span><br><span class="line">// totalCount = threadCount + copyArrivalCnt</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem], totalCount;</span><br><span class="line">// 这里初始化时给定的the expected arrival count既考虑了mbarrier.arrival，也考虑了cp.async.mbarrier.arrival所带来的arrive-on</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard1], [gbl1], 4;</span><br><span class="line">cp.async.cg.shared.global [shard2], [gbl2], 16;</span><br><span class="line">// 每个线程initiate两次cp.async操作</span><br><span class="line">...</span><br><span class="line">// Presence of .noinc requires mbarrier initalization to have accounted for arrive-on from cp.async</span><br><span class="line">cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 1st instance</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard3], [gbl3], 4;</span><br><span class="line">cp.async.ca.shared.global [shard4], [gbl4], 16;</span><br><span class="line">cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 2nd instance</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard5], [gbl5], 4;</span><br><span class="line">cp.async.cg.shared.global [shard6], [gbl6], 16;</span><br><span class="line">cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 3rd and last instance</span><br><span class="line">....</span><br><span class="line">mbarrier.arrive.shared.b64 state, [shMem];</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64 p, [shMem], state;</span><br><span class="line">@!p bra waitLoop;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier-test-wait"><a href="#9-7-12-11-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier-test-wait" class="headerlink" title="9.7.12.11.11. Parallel Synchronization and Communication Instructions: mbarrier.test_wait"></a>9.7.12.11.11. Parallel Synchronization and Communication Instructions: mbarrier.test_wait</h3><p><strong>mbarrier.test_wait</strong><br>Checks whether the mbarrier object has completed the phase.<br>检测当前phase是否已经完成</p>
<p><strong>Syntax</strong><br><code>mbarrier.test_wait&#123;.shared&#125;.b64 waitComplete, [addr], state;</code><br><code>mbarrier.test_wait.parity&#123;.shared&#125;.b64 waitComplete, [addr], phaseParity;</code></p>
<p><strong>Description</strong><br>The <strong>test_wait</strong> operation tests for <strong>the completion of the current or the immediately preceding phase</strong> of an mbarrier object at the location specified by the operand <code>addr</code>. The test_wait operation <strong>does not block</strong> the executing thread.</p>
<ul>
<li>如果执行到此处时，当前phase还未完成，那么部份先到达的线程执行test_wait后等待，test_wait检查当前phase是否完成，如果完成就unblock这部分等待的线程。</li>
<li>如果执行到此处时，当前phase已经完成，the pending arrival count已经降至0，那么test_wait就不会阻塞这部分线程</li>
</ul>
<p><code>mbarrier.test_wait</code> instruction tests for the completion of <strong>the phase specified by the operand <code>state</code></strong>, which was <strong>returned by an <code>mbarrier.arrive</code> instruction</strong> on the same mbarrier object during the current or the immediately preceding phase.</p>
<p><code>mbarrier.test_wait.parity</code> instruction tests for the completion of <strong>the phase indicated by the operand <code>phaseParity</code></strong>, which is the integer parity (整型奇偶校验) of either the current phase or the immediately preceding phase of the mbarrier object. An even phase (偶数phase) has <strong>integer parity 0</strong> and an odd phase (奇数phase) has <strong>integer parity of 1</strong>. So the valid values of phaseParity operand are 0 and 1.</p>
<p>Note: the use of the mbarrier.test_wait.parity requires tracking the phase of an mbarrier object throughout its lifetime.</p>
<p>The test_wait operations are valid only for :</p>
<ul>
<li>the current incomplete phase, for which <code>waitComplete</code> returns False.</li>
<li>the immediately preceding phase, for which <code>waitComplete</code> returns True.<blockquote>
<p>这里指的是由state指定的phase是the current incomplete phase还是the immediately preceding phase</p>
</blockquote>
</li>
</ul>
<p>For each phase of the mbarrier object, at least one test_wait operation must be performed which returns True for <code>waitComplete</code> before an arrive-on operation in the subsequent phase.</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p>The following ordering of memory operations hold for the executing thread when mbarrier.test_wait returns True (表征当前phase已完成) :</p>
<ol>
<li>All memory accesses (except cp.async ) requested prior, in program order, to <code>mbarrier.arrive</code> during the completed phase are performed and are <strong>visible to the executing thread</strong>.</li>
<li>All <code>cp.async</code> operations requested prior, in program order, to <code>cp.async.mbarrier.arrive</code> during the completed phase are performed and made <strong>visible to the executing thread</strong>.<br>arrive之前的所有访存对执行线程可见</li>
<li>All memory accesses requested <strong>after</strong> the mbarrier.test_wait, in program order, are <strong>not performed</strong> and <strong>not visible</strong> to memory accesses performed prior to mbarrier.arrive, in program order, by other threads participating in the mbarrier.<br>本线程test_wait之后的访存，对其他参与到mbarrier的线程在arrive之前的访存不可见</li>
<li>There is no ordering and visibility guarantee for memory accesses requested by the thread <strong>after <code>mbarrier.arrive</code> and prior to <code>mbarrier.test_wait</code></strong>, in program order.<br>arrive与test_wait之间的访存顺序与可见性没有保证</li>
</ol>
<p>相当于具有一个arrive之前与test_wait之后的memory fence，且这个memory fence对cp.async这种异步拷贝操作有效。</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p>Modifier .parity is introduced in PTX ISA version 7.1.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Example 1, thread synchronization :</span><br><span class="line">// block内参与mbarrier线程的同步</span><br><span class="line"></span><br><span class="line">.reg .b64 %r1;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem], N;  // N threads participating in the mbarrier.</span><br><span class="line">...</span><br><span class="line">mbarrier.arrive.shared.b64  %r1, [shMem]; // N threads executing mbarrier.arrive</span><br><span class="line"></span><br><span class="line">// computation not requiring mbarrier synchronization...</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64    complete, [shMem], %r1;</span><br><span class="line">@!complete nanosleep.u32 20;</span><br><span class="line">@!complete bra waitLoop;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Example 2, thread synchronization using phase parity :</span><br><span class="line">// 使用phase奇偶校验的线程同步</span><br><span class="line"></span><br><span class="line">.reg .b32 i, parArg;</span><br><span class="line">.reg .b64 %r1;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">mov.b32 i, 0;</span><br><span class="line">mbarrier.init.shared.b64 [shMem], N;  // N threads participating in the mbarrier.</span><br><span class="line">...</span><br><span class="line">loopStart :                           // One phase per loop iteration</span><br><span class="line">    ...</span><br><span class="line">    mbarrier.arrive.shared.b64  %r1, [shMem]; // N threads</span><br><span class="line">    ...</span><br><span class="line">    and.b32 parArg, i, 1;</span><br><span class="line">    waitLoop:</span><br><span class="line">    mbarrier.test_wait.parity.shared.b64  complete, [shMem], parArg;</span><br><span class="line">    @!complete nanosleep.u32 20;</span><br><span class="line">    @!complete bra waitLoop;</span><br><span class="line">    ...</span><br><span class="line">    add.u32 i, i, 1;</span><br><span class="line">    setp.lt.u32 p, i, IterMax;</span><br><span class="line">@p bra loopStart;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Example 3, Asynchronous copy completion waiting :</span><br><span class="line">// 等待异步数据传输完成</span><br><span class="line"></span><br><span class="line">.reg .b64 state;</span><br><span class="line">.shared .b64 shMem2;</span><br><span class="line">.shared .b64 shard1, shard2;</span><br><span class="line">.global .b64 gbl1, gbl2;</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem2], threadCount;</span><br><span class="line">...</span><br><span class="line">cp.async.ca.shared.global [shard1], [gbl1], 4;</span><br><span class="line">cp.async.cg.shared.global [shard2], [gbl2], 16;</span><br><span class="line"></span><br><span class="line">// Absence of .noinc accounts for arrive-on from prior cp.async operation</span><br><span class="line">// 没添加.noinc modifier，因此初始化mbarrier时无需考虑cp.async导致的arrive-on</span><br><span class="line">cp.async.mbarrier.arrive.shared.b64 [shMem2];</span><br><span class="line">...</span><br><span class="line">mbarrier.arrive.shared.b64 state, [shMem2];</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64 p, [shMem2], state;</span><br><span class="line">@!p bra waitLoop;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-12-Parallel-Synchronization-and-Communication-Instructions-mbarrier-pending-count"><a href="#9-7-12-11-12-Parallel-Synchronization-and-Communication-Instructions-mbarrier-pending-count" class="headerlink" title="9.7.12.11.12. Parallel Synchronization and Communication Instructions: mbarrier.pending_count"></a>9.7.12.11.12. Parallel Synchronization and Communication Instructions: mbarrier.pending_count</h3><blockquote>
<p>按照 <a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#memory_barrier_primitives_interface">CUDA C++ Programming Guide</a> 的说法，这个对应于函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> __mbarrier_pending_count(<span class="type">__mbarrier_token_t</span> token);</span><br></pre></td></tr></table></figure><br>此函数从CUDA 11.1开始被弃用了</p>
</blockquote>
<p><strong>mbarrier.pending_count</strong><br>Query <strong>the pending arrival count</strong> from the opaque mbarrier state.<br>查询当前mbarrier的the pending arrival count</p>
<p><strong>Syntax</strong><br><code>mbarrier.pending_count.b64 count, state;</code><br>// 输入state对应的mbarrier phase，由参数count返回当前phase的the pending arrival count</p>
<p><strong>Description</strong><br>The pending count can be queried from the opaque mbarrier state using mbarrier.pending_count.</p>
<p>The <code>state</code> operand is a 64-bit register that must be <strong>the result of a prior mbarrier.arrive.noComplete or mbarrier.arrive_drop.noComplete instruction</strong>. Otherwise, the behavior is undefined.<br>要求arrive操作必须带有.noComplete说明符，意味着对应的arrive操作中count没有使用默认的1，而是人为指定的，且这个arrive操作不能导致当前phase complete。</p>
<p>The destination register <code>count</code> is a 32-bit unsigned integer representing the pending count of the mbarrier object <strong>prior to the arrive-on operation from which the <code>state</code> register was obtained</strong>.<br>返回的不是调用mbarrier.pending_count时的the pending count，而是传入参数state所对应的arrive-on操作之前的the pending count。</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.reg .b32 %r1;</span><br><span class="line">.reg .b64 state;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">mbarrier.arrive.noComplete.b64 state, [shMem], 1;</span><br><span class="line">mbarrier.pending_count.b64 %r1, state;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/23/Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/23/Git/" class="post-title-link" itemprop="url">Git</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-23 18:16:26" itemprop="dateCreated datePublished" datetime="2022-06-23T18:16:26+08:00">2022-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-16 23:15:53" itemprop="dateModified" datetime="2022-07-16T23:15:53+08:00">2022-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git用户名和邮箱的配置"><a href="#Git用户名和邮箱的配置" class="headerlink" title="Git用户名和邮箱的配置"></a>Git用户名和邮箱的配置</h2><p>安装Git之后首先配置用户名和邮箱</p>
<blockquote>
<p>git config —global user.name “XXX”<br>git config —global user.email XXX</p>
</blockquote>
<p>—global表示全局设置，所有本地Git库使用相同的设置，如果希望在不同的项目中使用不同的配置，可在项目中配置并去掉—global符号。</p>
<blockquote>
<p>git config —list</p>
</blockquote>
<p>用于查看本地Git配置</p>
<h2 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a>Git基本理论</h2><p>Git有三个本地工作区域：<br>1、工作目录（Working Directory）<br>2、暂存区（Stage/Index）<em>实际上是一个文件</em><br>3、资源库（Repository/Git Directory）<br>还有一个远程Git仓库（Remote Directory）<br>一共<strong>四个工作区域</strong></p>
<center><img src="/2022/06/23/Git/1.png" width="50%" height="50%"></center>
<center><font color="#708090" size="2">Two types of LDGSTS: access and bypass.</font></center>

<h3 id="提交改动"><a href="#提交改动" class="headerlink" title="提交改动"></a>提交改动</h3><p>1、在工作目录下，使用git add命令，将改动提交到暂存区，此时并未永久保存。<br>2、此时使用git commit命令，将暂存区的改动永久提交到本地仓库<br>3、使用git push命令，将本地仓库的改动提交到远程仓库</p>
<h3 id="从远程仓库获取"><a href="#从远程仓库获取" class="headerlink" title="从远程仓库获取"></a>从远程仓库获取</h3><p>1、使用git pull命令</p>
<h3 id="从本地仓库回滚"><a href="#从本地仓库回滚" class="headerlink" title="从本地仓库回滚"></a>从本地仓库回滚</h3><p>1、使用git reset命令，此命令从本地仓库将之前保存的版本回滚到暂存区</p>
<h3 id="从暂存区回滚到工作目录"><a href="#从暂存区回滚到工作目录" class="headerlink" title="从暂存区回滚到工作目录"></a>从暂存区回滚到工作目录</h3><p>1、使用git checkout命令，将暂存区中未提交的版本回滚到本地目录中</p>
<blockquote>
<ul>
<li><strong>Workspace</strong>：工作区，就是你平时存放<strong>项目代码</strong>的地方</li>
<li><strong>Index / Stage</strong>：暂存区，用于临时存放你的改动，事实上它<strong>只是一个文件</strong>，保存即将提交到文件列表信息</li>
<li><strong>Repository</strong>：仓库区（或本地仓库），就是<strong>安全存放数据</strong>的位置，这里面有你提交到所有版本的数据。其中<strong>HEAD指向最新放入仓库的版本</strong></li>
<li><strong>Remote</strong>：远程仓库，<strong>托管代码的服务器</strong>，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
</blockquote>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><code>docker image ls</code> or <code>docker images</code>查看所有已装载的image<br><code>docker login -u 519844778 -p azaz123122</code> docker用户登陆<br><code>docker load -i xxx.tgz</code> load image文件<br><code>service docker start</code> 开启docker的守护进程 (后台运行)</p>
<h4 id="docker创建一个容器"><a href="#docker创建一个容器" class="headerlink" title="docker创建一个容器:"></a>docker创建一个容器:</h4><p><code>docker run --network=host --gpus=all --cap-add=SYS_ADMIN -id -v /home/jiangs/classT:/classT --name=classT physion:0.4Cuda11.4 /bin/bash</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--network=host</code></td>
<td>容器使用主机网络</td>
</tr>
<tr>
<td><code>--gpus all</code></td>
<td>使用所有的GPU设备</td>
</tr>
<tr>
<td><code>--cap-add=SYS_ADMIN</code></td>
<td>为容器赋予Linux系统下的SYS_ADMIN权限 (for nsys/GDB/ncu…)</td>
</tr>
<tr>
<td><code>--privileged=true</code></td>
<td>同上，赋予容器root权限 (for nsys/GDB/ncu…)</td>
</tr>
<tr>
<td><code>--rm</code></td>
<td>退出容器时不保留用户数据，容器也会消失，而不是仅关闭</td>
</tr>
<tr>
<td><code>-it</code></td>
<td>交互式容器并分配终端，退出时停止运行</td>
</tr>
<tr>
<td><code>-id</code></td>
<td>守护式容器，创建时自动运行，退出不会自动关闭，可以使用<code>docker stop [name]</code>来关闭容器</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>守护式容器，仅创建不自动运行，创建后为关闭状态</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>挂载数据卷(宿主机的一个目录)</td>
</tr>
<tr>
<td><code>--name=classT</code></td>
<td>容器的名称设置为classT</td>
</tr>
<tr>
<td><code>physion:0.4Cuda11.4</code></td>
<td>创建容器所使用的image名称physion，版本0.4Cuda11.4</td>
</tr>
<tr>
<td><code>/bin/bash</code></td>
<td>创建容器时初始化操作</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>关闭守护式容器 (仅关闭容器不消失)<br><code>docker stop [name]</code><br><code>docker kill [容器名]</code> 同上</li>
<li>启动已关闭的守护式容器<br><code>docker start [容器名]</code> </li>
<li>进入<strong>正在运行</strong>的守护式容器，进入容器执行<code>/bin/bash</code>初始化操作，<code>-it</code>分配终端<br><code>docker exec -it [容器名] /bin/bash</code> </li>
<li>删除容器<br><code>docker rm [容器名]</code> </li>
<li>退出容器，交互式容器消失，守护式转后台运行<br><code>exit</code> </li>
<li>查看当前所有容器与容器状态<br><code>docker ps -a</code> </li>
</ul>
<h4 id="创建一个自己的镜像"><a href="#创建一个自己的镜像" class="headerlink" title="创建一个自己的镜像"></a>创建一个自己的镜像</h4><ol>
<li><strong>首先使用现有镜像创建一个守护式容器，并exec进入容器按照需求修改</strong></li>
<li><strong>exit退出容器</strong></li>
<li><strong>提交更新后的副本 (使用现有容器创建镜像)</strong><br><code>docker commit -a=&quot;作者&quot; -m=&quot;提交的描述信息&quot; 容器id 要创建的目标镜像名:[Tag]</code><br><code>docker commit -a &quot;Jiang Shao&quot; -m &quot;CUDA-11.4 &amp; Nsight&quot; 4c6b1488512c physion:0.4Cuda11.4</code></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-m &quot;CUDA-11.4 &amp; Nsight&quot;</code></td>
<td>#提交的说明和信息</td>
</tr>
<tr>
<td><code>-a &quot;Jiang Shao&quot;</code></td>
<td>#提交的用户信息</td>
</tr>
<tr>
<td><code>4c6b1488512c</code></td>
<td>#修改后的容器的ID</td>
</tr>
<tr>
<td><code>physion:0.4Cuda11.4</code></td>
<td>#要更新的镜像名：版本号</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Failed to initialize NVML: Driver/library version mismatch<br>原因：NVIDIA 内核驱动版本与系统驱动不一致，ubuntu自动更新导致<br><code>cat /proc/driver/nvidia/version</code> 查看显卡内核版本<br><code>cat /var/log/dpkg.log | grep nvidia</code> 查看电脑驱动版本历史<br>解决方案：<code>sudo reboot</code></p>
</blockquote>
<ul>
<li><p>保存镜像physion:0.4Cuda11.4，name=physion, tag=0.4Cuda11.4, 到文件docker_image_cuda11_4_shao.tar中<br><code>docker save -o docker_image_cuda11_4_shao.tar physion:0.4Cuda11.4</code> </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.nvidia.cn/gpu-cloud/containers/">NVIDIA GPU 加速的容器</a></p>
</li>
<li><p>将docker image文件由台式机拷贝到ComputeLab个人空间上<br><code>scp root@10.19.203.137:/home/jiangs/shao_physion/docker_image/docker_image_cuda11_4_shao.tar /home/scratch.jiangs_sw/docker_image/</code></p>
</li>
<li><p>在ComputeLab上找一个芯片为A100的node，开启交互式任务<br><code>crun -q &#39;chip=ga100&#39; -i</code></p>
</li>
<li><p>由文件加载docker image<br><code>docker load -i docker_image_cuda11_4_shao.tar</code></p>
</li>
</ul>
<blockquote>
<p>最终找到了node=cl1-3001</p>
<ul>
<li>在ComputeLab上找到node=cl1-3001，开启交互式任务，如果非空闲就等待<br><code>crun -q &#39;node=cl1-3001&#39; -i --wait</code><br>重新登陆后发现刚才load的docker image已经没有了，看来只要exit退出就删除所有痕迹，每次使用都需要重新load docker image</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/PC-Problem-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/PC-Problem-2/" class="post-title-link" itemprop="url">Word中Mathtype公式变形问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-07 21:10:16" itemprop="dateCreated datePublished" datetime="2022-04-07T21:10:16+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-20 15:05:09" itemprop="dateModified" datetime="2022-04-20T15:05:09+08:00">2022-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E5%A4%84%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机疑难杂症处理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Word中Mathtype公式变形问题"><a href="#Word中Mathtype公式变形问题" class="headerlink" title="Word中Mathtype公式变形问题"></a>Word中Mathtype公式变形问题</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34146849/article/details/116099673">关于word中插入的mathtype公式变形问题的解决方案</a></p>
<h2 id="单个公式解决方案"><a href="#单个公式解决方案" class="headerlink" title="单个公式解决方案"></a>单个公式解决方案</h2><ol>
<li>选中公式，右键，图片</li>
<li>大小选项卡，缩放，高度宽度设置为100 %，点击下方重新设置</li>
</ol>
<h2 id="批量解决方案"><a href="#批量解决方案" class="headerlink" title="批量解决方案"></a>批量解决方案</h2><ol>
<li>文件，选项，自定义功能区，启用开发工具</li>
<li>开发工具，Visual Basic，对应Project中右键，插入模块</li>
<li>添加代码<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> ResizeEquations()</span><br><span class="line">    <span class="keyword">For</span> <span class="keyword">Each</span> Field <span class="keyword">In</span> ActiveDocument.Fields</span><br><span class="line">        <span class="keyword">If</span> Trim(Field.Code) = <span class="string">&quot;EMBED Equation.DSMT4&quot;</span> <span class="keyword">Then</span></span><br><span class="line">            <span class="keyword">With</span> Field.InlineShape</span><br><span class="line">                .LockAspectRatio = msoFalse</span><br><span class="line">                .ScaleWidth = <span class="number">100</span></span><br><span class="line">                .ScaleHeight = <span class="number">100</span></span><br><span class="line">            <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">        <span class="keyword">End</span> <span class="keyword">If</span></span><br><span class="line">    <span class="keyword">Next</span> Field</span><br><span class="line">    MsgBox (<span class="string">&quot;完成&quot;</span>) <span class="comment">&#x27;操作完成的提示框</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure></li>
<li>保存，另存为启用宏的文档</li>
<li>开发工具，宏，ResizeEquations，运行</li>
</ol>
<h2 id="Word里有设置的域，有些内容进行了手动修改，导出PDF后自动更新的解决方法"><a href="#Word里有设置的域，有些内容进行了手动修改，导出PDF后自动更新的解决方法" class="headerlink" title="Word里有设置的域，有些内容进行了手动修改，导出PDF后自动更新的解决方法"></a>Word里有设置的域，有些内容进行了手动修改，导出PDF后自动更新的解决方法</h2><p>Crtl+A  全选<br>Crtl+F11  锁定域<br>再导出PDF就不会自动更新了，点右键更新域也变成了灰色。<br>Ctrl + Shift + F11  解除锁定</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/PC-Problem-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/PC-Problem-1/" class="post-title-link" itemprop="url">闲置状态下播放音频，音频延迟1s出现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-01 14:26:03" itemprop="dateCreated datePublished" datetime="2022-03-01T14:26:03+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-23 18:58:15" itemprop="dateModified" datetime="2022-06-23T18:58:15+08:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E5%A4%84%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机疑难杂症处理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="闲置状态下播放音频，音频延迟1s出现"><a href="#闲置状态下播放音频，音频延迟1s出现" class="headerlink" title="闲置状态下播放音频，音频延迟1s出现"></a>闲置状态下播放音频，音频延迟1s出现</h1><blockquote>
<p><strong>问题描述：</strong><br>惠普暗影精灵4插上耳机后，看视频暂停后在播放，会过几秒钟后才有声音。 </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1452616740669491660.html">百度知道</a><br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/audio/audio-device-class-inactivity-timer-implementation">微软官网: 音频设备类不活动计时器实现</a><br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/kernel/device-power-states">微软官网: 设备电源状态</a></p>
<p>声音延迟是因为声卡驱动有一个省电管理，导致每一次暂停都会重启。</p>
<p>声音延迟2s的具体原因是Realtek的省电管理出现问题，为了节省电量Realtek在不工作时会自动关闭，导致每次启动Realtek时都需要重新加载，所以说会出现声音延迟1~2s的问题。解决思路是关闭Realtk的省电管理功能。具体解决方法是：</p>
<ul>
<li>使用windows+R键调出运行窗口，输入regedit打开注册表编辑器</li>
<li>按照路径寻找 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\\{4d36e96c-e325-11ce-bfc1-08002be10318}\xxxx\PowerSettings</li>
<li>其中’xxxx’是个四位数字，不同型号的电脑数字可能不一样，在暗影精灵4 win10系统中’xxxx’即’0000’。验证方法为点击某个’xxxx’，右侧窗口的键值中有DriverDesc，若该DriverDesc的值为 ‘Realtk High Definition Audio’，则此’xxxx’就是我们要找的路径</li>
<li>找到PowerSettings中的三个二进制值并将它们修改为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConservationIdleTime = ff ff ff ff <span class="comment">//电池供电下音频空闲等待时间最大</span></span><br><span class="line">IdlePowerState = <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//超出空闲等待时间后，设置电源状态为D0（完全）</span></span><br><span class="line">PerformanceIdleTime = ff ff ff ff <span class="comment">//电源供电下音频空闲等待时间最大</span></span><br></pre></td></tr></table></figure>
这些二进制值的默认值都是 00 00 00 00，有些其他的声卡驱动可能是0a 00 00 00</li>
<li><strong>重启电脑生效</strong>（重启资源管理器不行，必须重启电脑）</li>
</ul>
<p>这样就可以关闭Realtek省电管理。</p>
<p><strong>三个键值含义：</strong><br>注册表中的驱动程序根密钥：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\xxxx\yyyy</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>ConservationIdleTime</p>
<p>此参数指定系统在<strong>断电模式</strong>下运行时的空闲时间间隔。 这是系统<strong>以电池电源运行时</strong>通常使用的模式。 此参数的默认值为 0，这会在睡眠模式下禁用电源空闲计时器。 硬件供应商可以通过将 DWORD 值写入到以下特定于驱动程序的注册表项来替代默认值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\xxxx\yyyy\PowerSettings\ConservationIdleTime</span><br></pre></td></tr></table></figure>
<p>请注意 ，xxxx 表示媒体类 GUID (请参阅 系统 提供的设备安装程序类) 和 yyyyy 表示媒体类 GUID 下的驱动程序子项的名称。 键的值指定<strong>以秒为单位</strong>的时间间隔。</p>
</li>
<li><p>PerformanceIdleTime</p>
<p>此参数指定系统在<strong>性能模式</strong>下运行时的空闲时间间隔。 这是系统<strong>在交流电源上运行时</strong>通常使用的模式。 此参数的默认值为 0，这会在性能模式下禁用电源空闲计时器。 硬件供应商可以通过将 DWORD 值写入到以下特定于驱动程序的注册表项来替代默认值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\xxxx\yyyy\PowerSettings\PerformanceIdleTime</span><br></pre></td></tr></table></figure>
<p>同样 ，xxxx 表示 Media 类 GUID，yyyy 表示 驱动程序的子项的名称。 键的值指定<strong>以秒为单位</strong>的时间间隔。</p>
</li>
<li><p>IdlePowerState</p>
<p>此参数指定<strong>当空闲超时期限到期时设备将置于的电源状态</strong>。 此参数的默认值为 0，对应于设备电源状态 D0 (完全) 。 硬件供应商可以通过将 DWORD 值写入到以下特定于驱动程序的注册表项来替代默认值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\xxxx\yyyy\PowerSettings\IdlePowerState</span><br></pre></td></tr></table></figure>
<p>同样 ，xxxx 表示 Media 类 GUID，yyyy 表示 驱动程序的子项的名称。 放置在键中的值应为 0、1、2 或 3，分别对应于设备电源状态 D0、D1、D2 或 D3。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>例如，硬件供应商可能想要为音频设备指定以下电源空闲参数：为 Audio 设备指定 0x0000001e (30 秒) ，PerformanceIdleTime = 0x0000012c ( 300 秒) ，IdlePowerState = 0x00000003 (设备电源状态 D3) 。 若要启用这些设置，设备安装文件可以包含包含以下指令的 INF AddReg 节：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[MyAudioDevice.AddReg]</span><br><span class="line">HKR,PowerSettings,ConservationIdleTime,<span class="number">1</span>,<span class="number">1</span>e,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span></span><br><span class="line">HKR,PowerSettings,PerformanceIdleTime,<span class="number">1</span>,<span class="number">2</span>c,<span class="number">01</span>,<span class="number">00</span>,<span class="number">00</span></span><br><span class="line">HKR,PowerSettings,IdlePowerState,<span class="number">1</span>,<span class="number">03</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span></span><br></pre></td></tr></table></figure><br>HKR 表示注册表中的驱动程序根密钥：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class\xxxx\yyyy</span><br></pre></td></tr></table></figure><br>同样 ，xxxx 表示 Media 类 GUID，yyyy 表示 驱动程序的子项的名称。 PowerSettings子项是相对于根键的路径名称指定的。</p>
<center><img src="/2022/03/01/PC-Problem-1/1.png" width="100%"></center>

<p>改为</p>
<center><img src="/2022/03/01/PC-Problem-1/2.png" width="100%"></center>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/GAMES101-RayTracing-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/GAMES101-RayTracing-2/" class="post-title-link" itemprop="url">GAMES101 RayTracing Part 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-28 17:21:15" itemprop="dateCreated datePublished" datetime="2022-02-28T17:21:15+08:00">2022-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-02 17:01:18" itemprop="dateModified" datetime="2022-03-02T17:01:18+08:00">2022-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-RayTracing-Part-2"><a href="#GAMES101-RayTracing-Part-2" class="headerlink" title="GAMES101 RayTracing Part 2"></a>GAMES101 RayTracing Part 2</h1><h2 id="Using-Axis-Aligned-Bounding-Boxes-AABBs-to-accelerate-ray-tracing"><a href="#Using-Axis-Aligned-Bounding-Boxes-AABBs-to-accelerate-ray-tracing" class="headerlink" title="Using Axis-Aligned Bounding Boxes (AABBs) to accelerate ray tracing"></a>Using Axis-Aligned Bounding Boxes (AABBs) to accelerate ray tracing</h2><h3 id="Uniform-Grids-均匀网格预处理"><a href="#Uniform-Grids-均匀网格预处理" class="headerlink" title="Uniform Grids 均匀网格预处理"></a>Uniform Grids 均匀网格预处理</h3><center><img src="/2022/02/28/GAMES101-RayTracing-2/1.png" width="100%"></center>

<ol>
<li>找到整个空间的包围盒</li>
<li>创建均匀网格</li>
<li>存储所有与空间中物体表面相交的单元</li>
</ol>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/2.png" width="100%"></center>

<ol>
<li>从光线进入包围盒的第一个位置开始，逐个cell寻找与光线相交的cell（下一个cell一定是<strong>光线方向上的与当前cell相邻的cell</strong>，对于图中光线来说一定是当前cell的右侧cell或上方cell）</li>
<li>若当前cell中没有物体则继续下一个cell</li>
<li>若当前cell中存在物体则判断光线是否与cell中的物体相交</li>
</ol>
<p>对于均匀网格来说，cell数目太少不起作用，cell数目太多则用于判断cell与光线相交的计算太多。那么使用经验公式：3D中cell数目 = 场景中物体数目 * 27</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/3.png" width="100%"></center>

<p>这种Uniform Grid方法适用于场景中<strong>存在大量物体</strong>，<strong>且物体均匀的分布在空间中</strong>的情况。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/4.png" width="100%"></center>

<h3 id="Spatial-Partitions-空间划分"><a href="#Spatial-Partitions-空间划分" class="headerlink" title="Spatial Partitions 空间划分"></a>Spatial Partitions 空间划分</h3><p>用于弥补uniform grids方法在物体空间分布稀疏情况下的不足。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/5.png" width="100%"></center>

<p><strong>八叉树</strong>：每个cell均匀分裂成8个子cell in 3D、4个子cell in 2D（对应树结构每个父节点具有8/4个子节点）<br><strong>KD树</strong>：每个cell沿着某一个轴切分为2个子cell（对应结构为二叉树），每次切分方向都在三个轴之间切换，保证切分空间的匀称性，使子cell接近立方体。<br><strong>BSP树</strong>：每次选一个特殊方向切分空间。由于axis-aligned有便于计算的特性，因此主要使用KD树。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/6.png" width="100%"></center>

<p><strong>KD-Tree 空间划分示意</strong><br>示例原因每次仅切分两个子节点中的一个，而实际情况下每个子节点都要进行切分，除非遇到递归基（满足一定条件无需继续切分）。</p>
<p><strong>Data Structure for KD-Trees</strong><br>Internal nodes store 内部节点</p>
<ul>
<li>split axis: x-, y-, or z-axis 切分方向每次在三个轴之间切换</li>
<li>split position: coordinate of split plane along axis 切分位置没有固定要求，一般沿着中间切分</li>
<li>children: pointers to child nodes 每个中间节点具有指向两个子节点的指针</li>
<li>No objects are stored in internal nodes 中间节点不存储场景中的物体信息<br>Leaf nodes store 叶节点（没有子节点）</li>
<li>list of objects 存储对应区域所包含的场景中的物体信息</li>
</ul>
<p><strong>KD-Tree查找交点示意</strong></p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/7.png" width="100%"></center>

<p>假设最终生成的KD-Tree就如图所示，对123节点并不继续划分，彩色的都是叶节点，对应图中一块区域。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/8.png" width="100%"></center>

<p>首先判断光线是否与根节点所对应的整个场景的最大的包围盒相交。如果相交那么遍历它的两个子节点，首先到节点1。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/9.png" width="100%"></center>

<p>首先判断是否与节点1所围成的<strong>包围盒相交</strong>，是则由于1是叶节点，那么遍历1中包含的所有物体，判断光线是否与<strong>物体相交</strong>。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/10.png" width="100%"></center>

<p>发现节点1中并无交点，转而判断节点B，发现与B的包围盒相交。而B是内部节点，那么继续判断B的子节点2。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/11.png" width="100%"></center>

<p>与节点2所围成的包围盒求交发现有交点，而节点2是一个叶节点，转而与节点2中包含的所有物体求交。发现没有，转而判断B的两一个子节点C。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/12.png" width="100%"></center>

<p>发现与C的包围盒有交点，继续判断C的子节点。由于子节点间并没有严格顺序。这里转而判断节点3。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/13.png" width="100%"></center>

<p>与3的包围盒求交-&gt;有交点。<br>3为叶节点-&gt;与3中所有物体求交-&gt;有交点-&gt;记录交点对应的 t_hit。<br><strong>此时转而判断C的另一个子节点D</strong>，再继续这个过程，找到所有的交点对应的 t_hit，永远记录一个为正的最小的 t，即为真实交点对应的 t。</p>
<center><img src="/2022/02/28/GAMES101-RayTracing-2/14.png" width="100%"></center>

<p>KD-Tree两个缺点：</p>
<ol>
<li>实际物体为三角形网格，很难判断一个三角形是否处于一个节点所对应的包围盒中。</li>
<li>同一个物体可能横跨了多个包围盒，被多个节点所记录。</li>
</ol>
<h3 id="Object-Partitions-物体划分-gt-Bounding-Volume-Hierarchy-BVH"><a href="#Object-Partitions-物体划分-gt-Bounding-Volume-Hierarchy-BVH" class="headerlink" title="Object Partitions 物体划分 -&gt; Bounding Volume Hierarchy (BVH)"></a>Object Partitions 物体划分 -&gt; Bounding Volume Hierarchy (BVH)</h3><p>把物体分为两堆（一个节点两个子节点），并重新计算这两堆物体的包围盒。</p>
<center>
<img src="/2022/02/28/GAMES101-RayTracing-2/15-1.png" width="100%">
<img src="/2022/02/28/GAMES101-RayTracing-2/15-2.png" width="100%">
<img src="/2022/02/28/GAMES101-RayTracing-2/15-3.png" width="100%">
<img src="/2022/02/28/GAMES101-RayTracing-2/15-4.png" width="100%">
</center>

<blockquote>
<p><strong>优点</strong>：</p>
<ol>
<li>场景中每个object只存储于一个叶节点中，不会被多个叶节点同时存储。</li>
<li>避免了KD-Tree中对子节点包围盒中所包含object的计算，直接利用分类后堆中的所有object求其包围盒。</li>
</ol>
</blockquote>
<p><strong>KD-Tree是对空间的划分</strong>，之后再把objects归类到相应的区域中。<strong>而BVH是对物体进行划分</strong>。</p>
<blockquote>
<p><strong>如何切分节点（将一堆objects划分为两堆）？</strong></p>
</blockquote>
<p>How to subdivide a node?</p>
<ul>
<li>Choose a dimension to split</li>
<li>Heuristic #1: Always choose the longest axis in node<br>选择节点最长的一个轴进行切分（空间切分），好处是切分之后两个子节点空间大小均匀。</li>
<li>Heuristic #2: Split node at location of median object<br>选择中间的物体进行切分（物体个数划分），好处是划分之后，两个子节点物体个数均匀，从而形成的二叉树较为平衡（二叉树深度较小，有利于缩短查找时间）。</li>
</ul>
<blockquote>
<p>选择物体进行切分时，需要找到第K个物体（Top K 问题），传统方法是对所有物体进行排序，时间复杂度O(nlogn)。而实际无需对所有节点都排序。<br><strong>基于快速排序的思维实现</strong>，时间复杂度为o(n)：</p>
<ol>
<li>选一个枢轴点（主元），用快排的方法将数组分为两部分，位于枢轴点左边的数都比它大，位于枢轴点右边的数都比它小。</li>
<li>划分后查看枢轴点索引值。如果恰好为k-1，则枢轴点即为第k大的数；否则若索引比k-1大，说明第k大的数位于左边部分；否则位于右边部分。</li>
<li>递归地再在左或右某一部分中选取一个主元，进行下一次划分。</li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/28/GAMES101-Geometry-Assignment4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/GAMES101-Geometry-Assignment4/" class="post-title-link" itemprop="url">GAMES101 Geometry Assignment4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-28 14:23:33 / Modified: 17:47:45" itemprop="dateCreated datePublished" datetime="2022-02-28T14:23:33+08:00">2022-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-Geometry-Assignment4"><a href="#GAMES101-Geometry-Assignment4" class="headerlink" title="GAMES101 Geometry Assignment4"></a>GAMES101 Geometry Assignment4</h1><h2 id="cv-Mat数据类型"><a href="#cv-Mat数据类型" class="headerlink" title="cv::Mat数据类型"></a>cv::Mat数据类型</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/czsnooker/article/details/118345494">OpenCV基础类型4—cv::Mat详解</a><br>cv::Mat是OpenCV定义的用于表示任意维度的稠密数组，OpenCV使用它来存储和传递图像。</p>
<p>由于cv::Mat要用于存储图像，它里面的元素可以是“像素”，对于像素，OpenCV定义了专门的数据格式来描述它们。<br>基本数据类型 + 通道数<br>CV_{8U, 16S, 16U, 32S, 32F, 64F}C{1, 2, 3}</p>
<p>数据类型前面的数字，对应数据类型的bit数。<br>8U:unsigned char;<br>16S: short int;<br>16U: unsigned short int;<br>32F: float;<br>64F: double.</p>
<p>{1，2，3}代表通道数。<br>彩色图像每个像素需要存储B、G、R（蓝、绿、红）3个信息，需要3个位置， 每一个称为一个“颜色通道”。<br>灰度图像无颜色，只有一个通道，故常为CV_8UC1。由黑到白。</p>
<p>作业中cv::Mat构造函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat window = cv::<span class="built_in">Mat</span>(<span class="number">700</span>, <span class="number">700</span>, CV_8UC3, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><br>对应图像高（行数）700-row，宽（列数）700-col， 数据类型：CV_8UC3（unsigned char，彩色三通道），初始值为cv::Scalar(0)代表纯黑色。</p>
<p><strong>访问元素</strong><br>直接访问，使用模板函数at&lt;&gt;()</p>
<p>单通道, 尖括号里面的类型照着文章开头介绍的类型对应关系输入<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里数据类型为CV_32FC1，对应float，单通道，所以使用at&lt;float&gt;</span></span><br><span class="line">cv::Mat img = cv::Mat::<span class="built_in">ones</span>(<span class="number">240</span>, <span class="number">320</span>, CV_32FC1);</span><br><span class="line"><span class="type">float</span> elem = img.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>多通道，Vec3b代表固定向量类。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/czsnooker/article/details/118314514?spm=1001.2014.3001.5501">利用固定向量类访问</a><br>OpenCV中固定向量模板类cv::Vec&lt;&gt;别名命名规则：<br>cv::Vec{2,3,4,6}{b, s ,w , i, f, d}<br>{2,3,4,6}代表向量的长度。<br>{b, s ,w , i, f, d}表示向量内数据类型。分别对应：<br>b：unsigned char;<br>s：short int;<br>w：unsigned short;<br>i：int;<br>f：float;<br>d：double.</p>
<p>注意类型之间的对应，固定向量与Mat的代表字母有一点差异<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cv::Mat元素类型CV_8UC3，对应unsigned char彩色三通道，因此使用固定向量类型cv::Vec3b，长度3向量，数据类型unsigned char</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">img1</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, CV_8UC3, cv::Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">cv::Vec3b elem = img1.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">elem_B = elem[<span class="number">0</span>]; <span class="comment">//蓝色通道数值---255</span></span><br><span class="line">elem_G = elem[<span class="number">1</span>]; <span class="comment">//绿色通道数值---255</span></span><br><span class="line">elem_R = elem[<span class="number">2</span>]; <span class="comment">//红色通道---0</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>要求你的实现将Bézier 曲线绘制为绿色。</p>
</blockquote>
<p>绿色对应RGB(0, 255, 0)。</p>
<h2 id="作业代码"><a href="#作业代码" class="headerlink" title="作业代码"></a>作业代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> t_step 0.001f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTROL_POINTS_NUM 6</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;cv::Point2f&gt; control_points;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_handler</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> flags, <span class="type">void</span> *userdata)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event == cv::EVENT_LBUTTONDOWN &amp;&amp; control_points.<span class="built_in">size</span>() &lt; CONTROL_POINTS_NUM) </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Left button of the mouse is clicked - position (&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">        &lt;&lt; y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        control_points.<span class="built_in">emplace_back</span>(x, y);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">naive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_0 = points[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_1 = points[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_2 = points[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">auto</span> &amp;p_3 = points[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> t = <span class="number">0.0</span>; t &lt;= <span class="number">1.0</span>; t += <span class="number">0.001</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> point = std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">3</span>) * p_0 + <span class="number">3</span> * t * std::<span class="built_in">pow</span>(<span class="number">1</span> - t, <span class="number">2</span>) * p_1 +</span><br><span class="line">                 <span class="number">3</span> * std::<span class="built_in">pow</span>(t, <span class="number">2</span>) * (<span class="number">1</span> - t) * p_2 + std::<span class="built_in">pow</span>(t, <span class="number">3</span>) * p_3;</span><br><span class="line"></span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point.y, point.x)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Factorial</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> result = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            result *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Point2f <span class="title">recursive_bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, <span class="type">float</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Implement de Casteljau&#x27;s algorithm</span></span><br><span class="line">    <span class="function">cv::Point2f <span class="title">point_</span><span class="params">(<span class="number">0.f</span>, <span class="number">0.f</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = control_points.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//贝塞尔曲线阶数为控制点个数-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//伯恩斯坦多项式</span></span><br><span class="line">        <span class="type">float</span> Bni = <span class="built_in">Factorial</span>(n) / <span class="built_in">Factorial</span>(i) / <span class="built_in">Factorial</span>(n - i) * <span class="built_in">powf</span>(t, i) * <span class="built_in">pow</span>(<span class="number">1</span> - t, n - i);</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; Bni &lt;&lt; std::endl;</span></span><br><span class="line">        point_ += Bni * control_points[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> point_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bezier</span><span class="params">(<span class="type">const</span> std::vector&lt;cv::Point2f&gt; &amp;control_points, cv::Mat &amp;window)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau&#x27;s </span></span><br><span class="line">    <span class="comment">// recursive Bezier algorithm.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> t = <span class="number">0</span>; t &lt; <span class="number">1</span>; t+=t_step)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Point2f point_ = <span class="built_in">recursive_bezier</span>(control_points, t);</span><br><span class="line">        window.<span class="built_in">at</span>&lt;cv::Vec3b&gt;(point_.y, point_.x)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat window = cv::<span class="built_in">Mat</span>(<span class="number">700</span>, <span class="number">700</span>, CV_8UC3, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>));<span class="comment">//黑色屏幕</span></span><br><span class="line">    <span class="comment">//cv::Mat window = cv::Mat(700, 700, CV_8UC3, cv::Scalar(0,255,0));//绿色屏幕</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">cvtColor</span>(window, window, cv::COLOR_BGR2RGB);</span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Bezier Curve&quot;</span>, cv::WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">setMouseCallback</span>(<span class="string">&quot;Bezier Curve&quot;</span>, mouse_handler, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (key != <span class="number">27</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point : control_points) </span><br><span class="line">        &#123;</span><br><span class="line">            cv::<span class="built_in">circle</span>(window, point, <span class="number">3</span>, &#123;<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>&#125;, <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (control_points.<span class="built_in">size</span>() == CONTROL_POINTS_NUM) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//naive_bezier(control_points, window);</span></span><br><span class="line">            <span class="built_in">bezier</span>(control_points, window);</span><br><span class="line"></span><br><span class="line">            cv::<span class="built_in">imshow</span>(<span class="string">&quot;Bezier Curve&quot;</span>, window);</span><br><span class="line">            cv::<span class="built_in">imwrite</span>(<span class="string">&quot;my_bezier_curve.png&quot;</span>, window);</span><br><span class="line">            key = cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Bezier Curve&quot;</span>, window);</span><br><span class="line">        key = cv::<span class="built_in">waitKey</span>(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/25/GAMES101-Geometry-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/GAMES101-Geometry-1/" class="post-title-link" itemprop="url">GAMES101 Geometry part1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 17:05:59" itemprop="dateCreated datePublished" datetime="2022-02-25T17:05:59+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 14:24:03" itemprop="dateModified" datetime="2022-02-28T14:24:03+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-Geometry-part1"><a href="#GAMES101-Geometry-part1" class="headerlink" title="GAMES101 Geometry part1"></a>GAMES101 Geometry part1</h1><p><strong>表示几何形状的方式：</strong></p>
<p>隐式表示：</p>
<ol>
<li>algebraic surface 代数曲面</li>
<li>level set 水平集</li>
<li>distance functions 距离函数</li>
<li>…</li>
</ol>
<p>显式表示：</p>
<ol>
<li>point cloud 点云</li>
<li>polygon mesh 多边形网格</li>
<li>subdivision, NURBS 样条曲线</li>
<li>…</li>
</ol>
<p><strong>隐式表示</strong>基于对点的划分。所有的点满足特定的关系。<br>缺点：Sampling Can Be Hard，由于只知道点所满足的关系，因此想要知道组成几何的点比较困难。<br>优点：Inside/Outside Tests Easy，判断空间中一个点是否在曲面内很容易，直接代入到几何的约束关系中。</p>
<p><strong>显示表示</strong>是直接给出所有组成几何的点，或者依据参数映射给出所有点。<br>优点：Sampling Is Easy<br>缺点：Inside/Outside Test Hard</p>
<h2 id="Implicit-Representations-in-Computer-Graphics-计算机图形学中几何的隐式表示方法"><a href="#Implicit-Representations-in-Computer-Graphics-计算机图形学中几何的隐式表示方法" class="headerlink" title="Implicit Representations in Computer Graphics 计算机图形学中几何的隐式表示方法"></a>Implicit Representations in Computer Graphics 计算机图形学中几何的隐式表示方法</h2><h3 id="Algebraic-Surfaces-Implicit-代数表面"><a href="#Algebraic-Surfaces-Implicit-代数表面" class="headerlink" title="Algebraic Surfaces (Implicit) 代数表面"></a>Algebraic Surfaces (Implicit) 代数表面</h3><p>Surface is zero set of a polynomial in x, y, z.<br>表面为多项式的零集。（使得一个多项式等于0的所有值的集合）</p>
<p>${ {x}^{2} }+{ {y}^{2} }+{ {z}^{2} }-1=0$<br>${ {\left( R-\sqrt{ { {x}^{2} }+{ {y}^{2} } } \right)}^{2} }+{ {z}^{2} }-{ {r}^{2} }=0$<br>${ {\left( { {x}^{2} }+\frac{9}{4}{ {y}^{2} }+{ {z}^{2} }-1 \right)}^{3} }-{ {x}^{2} }{ {z}^{3} }-\frac{9}{80}{ {y}^{2} }{ {z}^{3} }=0$</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/1.png" width="100%" height="100%"></center>

<h3 id="Constructive-Solid-Geometry-Implicit-构造实体几何"><a href="#Constructive-Solid-Geometry-Implicit-构造实体几何" class="headerlink" title="Constructive Solid Geometry (Implicit) 构造实体几何"></a>Constructive Solid Geometry (Implicit) 构造实体几何</h3><p>Combine implicit geometry via Boolean operations.<br>通过布尔运算构造几何。并集、交集、差集</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/2.png" width="100%" height="100%"></center>

<h3 id="Distance-Functions-Implicit-距离函数"><a href="#Distance-Functions-Implicit-距离函数" class="headerlink" title="Distance Functions (Implicit) 距离函数"></a>Distance Functions (Implicit) 距离函数</h3><p>Gradually blend surfaces together using Distance functions. 使用距离函数逐渐混合表面。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/3.png" width="100%" height="100%"><img src="/2022/02/25/GAMES101-Geometry-1/3_1.png" width="100%" height="100%"></center>

<p><strong>Distance functions: 距离函数</strong><br>giving minimum distance (could be signed distance)<br>from anywhere to object.<br>给出任意位置到物体的最小距离（垂直于表面），可以是有符号的距离，为负代表在物体内部。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/4.png" width="100%" height="100%"></center>

<p>逐渐混合的原理是，如图例所示，对于区域中一个边界来说，边界左侧为负（视为边界内部）右侧为正（视为边界外部）。<strong>SDF为0代表边界</strong>，图AB正负所占区域各不相同，blend之后相当于对AB中边界的一个线性插值（对0的位置的插值）。</p>
<h3 id="Level-Set-Methods-implicit-水平集"><a href="#Level-Set-Methods-implicit-水平集" class="headerlink" title="Level Set Methods (implicit) 水平集"></a>Level Set Methods (implicit) 水平集</h3><p>对于复杂形状来说，描述边界的方程很难得到，因此对空间进行采样，给出空间中各个点的距离值。这样边界就可以通过插值方式得到（距离为0的地方）。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-1/5.png" width="100%" height="100%"></center>

<h3 id="Fractals-Implicit-分形"><a href="#Fractals-Implicit-分形" class="headerlink" title="Fractals (Implicit) 分形"></a>Fractals (Implicit) 分形</h3><p>Exhibit self-similarity, detail at all scales.<br>自相似特性 </p>
<h3 id="隐式描述几何形状的优缺点"><a href="#隐式描述几何形状的优缺点" class="headerlink" title="隐式描述几何形状的优缺点"></a>隐式描述几何形状的优缺点</h3><p>优点：</p>
<ol>
<li>紧凑的表示方法（比如一个函数）</li>
<li>对于特定的查询非常方便（比如在物体内外、点到边界的距离）</li>
<li>方便表面与光线求交点</li>
<li>对于一些简单形状，描述准确、无采样误差</li>
<li>易于处理拓扑结构的变化（比如流体：拓扑结构多变且多样）</li>
</ol>
<p>缺点：</p>
<ol>
<li>对复杂形状来说隐式描述相对困难</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/25/GAMES101-Geometry-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/25/GAMES101-Geometry-2/" class="post-title-link" itemprop="url">GAMES101 Geometry part2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-25 17:03:43" itemprop="dateCreated datePublished" datetime="2022-02-25T17:03:43+08:00">2022-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-28 14:24:13" itemprop="dateModified" datetime="2022-02-28T14:24:13+08:00">2022-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GAMES101-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/" itemprop="url" rel="index"><span itemprop="name">GAMES101-现代计算机图形学入门</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GAMES101-Geometry-part2"><a href="#GAMES101-Geometry-part2" class="headerlink" title="GAMES101 Geometry part2"></a>GAMES101 Geometry part2</h1><h2 id="Explicit-Representations-in-Computer-Graphics-计算机图形学中几何的显式表示方法"><a href="#Explicit-Representations-in-Computer-Graphics-计算机图形学中几何的显式表示方法" class="headerlink" title="Explicit Representations in Computer Graphics 计算机图形学中几何的显式表示方法"></a>Explicit Representations in Computer Graphics 计算机图形学中几何的显式表示方法</h2><p><strong>Curves</strong></p>
<ul>
<li>Bezier curves 贝塞尔曲线<br>— De Casteljau’s algorithm 德卡斯特里奥算法</li>
<li>B-splines, etc. B样条曲线</li>
</ul>
<p><strong>Surfaces</strong></p>
<ul>
<li>Bezier surfaces 贝塞尔曲面</li>
<li>Triangles &amp; quads 三角形网格与四边形网格<br>— Subdivision, simplification, regularization 细化，粗化，正则化</li>
</ul>
<h3 id="Point-Cloud-Explicit-点云"><a href="#Point-Cloud-Explicit-点云" class="headerlink" title="Point Cloud (Explicit) 点云"></a>Point Cloud (Explicit) 点云</h3><ol>
<li>Easiest representation: list of points (x,y,z)<br>最简单的表示方法，点列表</li>
<li>Easily represent any kind of geometry<br>很容易表示任何形状</li>
<li>Useful for LARGE datasets (&gt;&gt;1 point/pixel)<br>适用于于大型数据集，每个像素都有远大于1个点</li>
<li>Often converted into polygon mesh<br>经常被转化为多边形网络</li>
<li>Difficult to draw in undersampled regions<br>对采样不足的区域很难绘制（指点比较稀疏的区域，每个像素包含的点太少、甚至可能没有）</li>
</ol>
<center><img src="/2022/02/25/GAMES101-Geometry-2/1.png" width="50%" height="50%"></center>

<h3 id="Polygon-Mesh-Explicit-多边形网络"><a href="#Polygon-Mesh-Explicit-多边形网络" class="headerlink" title="Polygon Mesh (Explicit) 多边形网络"></a>Polygon Mesh (Explicit) 多边形网络</h3><ol>
<li>Store vertices &amp; polygons (often triangles or quads)<br>存储顶点和多边形（三角形、四边形居多）</li>
<li>Easier to do processing / simulation, adaptive sampling<br>易于处理、模拟、自适应采样</li>
<li>More complicated data structures<br>更复杂的数据结构</li>
<li>Perhaps most common representation in graphics<br>图形学中目前最常用的表示方法</li>
</ol>
<center><img src="/2022/02/25/GAMES101-Geometry-2/2.png" width="100%" height="100%"></center>

<h4 id="The-Wavefront-Object-File-obj-Format"><a href="#The-Wavefront-Object-File-obj-Format" class="headerlink" title="The Wavefront Object File (.obj) Format"></a>The Wavefront Object File (.obj) Format</h4><p>描述多边形网格的文件格式。<br>Commonly used in Graphics research.<br>Just a text file that specifies vertices, normals, texture<br>coordinates and their connectivities.<br>是一个txt文件，指定了多边形网络的<strong>顶点</strong>、<strong>法线</strong>、<strong>纹理坐标</strong>与<strong>顶点之间的连接关系</strong>。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/3.png" width="100%" height="100%"></center>

<p>文件中：<br>v代表vertices顶点坐标<br>vt代表各个顶点对应的纹理坐标<br>vn代表各个顶点对应的法线方向<br>f则代表face，指顶点之间的连接方式从而组成一个面，格式为v/vt/vn</p>
<h3 id="Bezier-Curves-贝塞尔曲线"><a href="#Bezier-Curves-贝塞尔曲线" class="headerlink" title="Bézier Curves 贝塞尔曲线"></a>Bézier Curves 贝塞尔曲线</h3><p>Defining Cubic Bézier Curve With Tangents<br>使用切线定义三次贝塞尔曲线</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/4.png" width="70%" height="70%"></center>

<p>P为一系列控制点，用于定义曲线。指明了曲线要满足的一些性质。</p>
<ol>
<li>曲线由P0开始，到P3结束</li>
<li>在P0处曲线沿着P0P1为切线，切线长度为t0</li>
<li>在P3处曲线沿着P2P3为切线，切线程度为t1</li>
</ol>
<h4 id="de-Casteljau-Algorithm"><a href="#de-Casteljau-Algorithm" class="headerlink" title="de Casteljau Algorithm"></a>de Casteljau Algorithm</h4><p>用于绘制贝塞尔曲线</p>
<p>Consider three points (quadratic Bezier)<br>考虑三个控制点的情况（二次贝塞尔曲线）</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/5_1.png" width="50%"><img src="/2022/02/25/GAMES101-Geometry-2/5_2.png" width="50%"></center>

<p>三次线性插值，根据同一个t得到对应位置。<br>$b_{0}^{1}={ {b}_{0} }+({ {b}_{1} }-{ {b}_{0} })<em>t$<br>$b_{1}^{1}={ {b}_{1} }+({ {b}_{2} }-{ {b}_{1} })</em>t$<br>$b_{0}^{2}=b_{0}^{1}+(b_{1}^{1}-b_{0}^{1})*t$</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45333934/article/details/108274320">公式渲染错误：Nunjucks Error 解决方案</a></p>
<script type="math/tex; mode=display">b_{0}^{2}={ {(1-t)}^{2} }{ {b}_{0} }+2t(1-t){ {b}_{1} }+{ {t}^{2} }{ {b}_{2} }</script><p>Four input points in total (Cubic Bézier Curve)<br>相同的递归线性插值</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/9.png" width="90%"></center>

<center><img src="/2022/02/25/GAMES101-Geometry-2/6.png" width="100%"></center>
<center><img src="/2022/02/25/GAMES101-Geometry-2/7.png" width="50%"><img src="/2022/02/25/GAMES101-Geometry-2/7_2.png" width="50%"></center>

<p><strong>通用贝塞尔曲线公式</strong><br><strong>Bernstein polynomial 伯恩斯坦多项式</strong></p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/8.png" width="50%"></center>

<script type="math/tex; mode=display">\left( \begin{align}
  & n \nonumber \\
 & i \nonumber \\
\end{align} \right)=\frac{n!}{i!(n-i)!}</script><p><strong>Bernstein form of a Bézier curve of order n:</strong><br><strong>n阶贝塞尔曲线伯恩斯坦形式（n+1个控制点）：</strong></p>
<script type="math/tex; mode=display">{ {b}^{n} }(t)=\sum\limits_{i=0}^{n}{ { {b}_{i} }B_{i}^{n}(t)}</script><center><img src="/2022/02/25/GAMES101-Geometry-2/11.png" width="50%"></center>
伯恩斯坦多项式在t的任何位置，各个多项式的和都为1，是对所有控制点的线性插值。可以看到在t=0和1的位置，多项式其他项都是0，只有首项/末项为1，对应插值结果为首个/最后一个控制点。

#### Properties of Bézier Curves 贝塞尔曲线特性

1. Interpolates endpoints 插值端点
   曲线端点为首末控制点，对于3次贝塞尔曲线，曲线端点为b0, b3
2. Tangent to end segments 
   曲线在首末位置正切于控制点组成的线段，同上${b}'(0)=3({ {b}_{1} }-{ {b}_{0} })$, ${b}'(1)=3({ {b}_{3} }-{ {b}_{2} })$括号中为插值变量t。系数3只是因为三阶曲线有四个控制点，其他阶数并不严格是3。
3. Affine transformation property 
   Transform curve by transforming control points
   对控制点进行仿射变换，再使用变换后的控制点绘制贝塞尔曲线，与直接对贝塞尔曲线进行仿射变换等效。（仅对仿射变换有效，对投影等变换无效）
4. Convex hull property 凸包性质
   Curve is within convex hull of control points
   贝塞尔曲线一定在控制点所围成的凸包内（凸包，板上钉钉子，用个橡皮筋围一下，都是凸角）
<center><img src="/2022/02/25/GAMES101-Geometry-2/12.png" width="50%"></center>
<center><font color="#708090" size="2">10阶贝塞尔曲线，11个控制点。</font></center>

<h4 id="Piecewise-Bezier-Curves-分段贝塞尔曲线"><a href="#Piecewise-Bezier-Curves-分段贝塞尔曲线" class="headerlink" title="Piecewise Bézier Curves 分段贝塞尔曲线"></a>Piecewise Bézier Curves 分段贝塞尔曲线</h4><p>对于高阶贝塞尔曲线来说，要控制曲线的形状非常困难，控制点之间都是互相耦合的。因此要实现一个较长的贝塞尔曲线，可以将低阶的贝塞尔曲线连接起来实现 -&gt; Piecewise Bézier Curves。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/13.png" width="50%"></center>
<center><font color="#708090" size="2">Piecewise Bézier Curves.</font></center>

<p>逐段贝塞尔曲线：每四个控制点，定义一段三阶贝塞尔曲线。对于图中第一段来说，控制点为1234，曲线起止与14控制点。</p>
<h5 id="Piecewise-Bezier-Curve-–-Continuity-连续性"><a href="#Piecewise-Bezier-Curve-–-Continuity-连续性" class="headerlink" title="Piecewise Bézier Curve – Continuity 连续性"></a>Piecewise Bézier Curve – Continuity 连续性</h5><p>如何使两端曲线连接处光滑，起止点连接（值连续），起止点处切线方向一致，且切线大小相同（导数连续）。</p>
<p><strong>C0连续</strong>：起止点连接</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/14.png" width="100%"></center>

<p><strong>C1连续</strong>：切线连续，两端切线方向相反，长度相同。</p>
<center><img src="/2022/02/25/GAMES101-Geometry-2/15.png" width="100%"></center>

<h3 id="Bezier-Surfaces-贝塞尔曲面"><a href="#Bezier-Surfaces-贝塞尔曲面" class="headerlink" title="Bézier Surfaces 贝塞尔曲面"></a>Bézier Surfaces 贝塞尔曲面</h3><center><img src="/2022/02/25/GAMES101-Geometry-2/16.png" width="100%"></center>
<center><font color="#708090" size="2">Bicubic Bézier Surface Patch.</font></center>

<p>通过双线性插值方法得到，双三次贝塞尔曲面，一共4*4个控制点。</p>
<ol>
<li>每行拿出四个控制点，在所有时间u上插值，得到一条贝塞尔曲线。</li>
<li>在每个时间u，又能在对应四条贝塞尔曲线上得到四个曲线上的点。</li>
<li>在每个时间u，以这四个点为控制点，在所有时间v上插值，又能画出一条贝塞尔曲线，则不同时间u的这条曲线构成了一个贝塞尔曲面。</li>
<li>对应两个插值时间(u, v)，这两个参数可以映射到曲面上的每个点，参数映射-&gt;所以贝塞尔曲面是显示表示方法。</li>
</ol>
<center><img src="/2022/02/25/GAMES101-Geometry-2/17.png" width="100%"></center>
<center><img src="/2022/02/25/GAMES101-Geometry-2/18.png" width="100%"></center>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiang Shao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiang Shao</p>
  <div class="site-description" itemprop="description">WeChat: shaojiang9650<br>Email: shao_study@163.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Shao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
