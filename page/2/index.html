<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="WeChat: shaojiang9650Email: shao_study@163.com">
<meta property="og:type" content="website">
<meta property="og:title" content="邵大宝的学习Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="邵大宝的学习Blog">
<meta property="og:description" content="WeChat: shaojiang9650Email: shao_study@163.com">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jiang Shao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>邵大宝的学习Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">邵大宝的学习Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">最爱严小跳</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/23/cuda-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/23/cuda-6/" class="post-title-link" itemprop="url">CUDA学习随记6 C++11中的内存模型 std::memory_order</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-23 21:41:50" itemprop="dateCreated datePublished" datetime="2022-02-23T21:41:50+08:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-06 21:57:32" itemprop="dateModified" datetime="2022-07-06T21:57:32+08:00">2022-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CUDA学习随记6-C-11中的内存模型-std-memory-order"><a href="#CUDA学习随记6-C-11中的内存模型-std-memory-order" class="headerlink" title="CUDA学习随记6  C++11中的内存模型 std::memory_order"></a>CUDA学习随记6  C++11中的内存模型 std::memory_order</h1><p>来自陌生网友最真挚的情感抒发：</p>
<center><img src="/2022/02/23/cuda-6/0.png" width="50%" height="50%"></center>

<p>&lt; !—more—&gt;</p>
<blockquote>
<p><strong>References:</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++11 std::memory_order</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45566448">内存顺序（Memory Order）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codedump.info/post/20191214-cxx11-memory-model-1/">C++11中的内存模型上篇 - 内存模型基础</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codedump.info/post/20191214-cxx11-memory-model-2/">C++11中的内存模型下篇 - C++11支持的几种内存模型</a></li>
</ol>
</blockquote>
<h2 id="std-memory-order-C-11"><a href="#std-memory-order-C-11" class="headerlink" title="std::memory_order (C++11)"></a>std::memory_order (C++11)</h2><p>Defined in header \<atomic\><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// since C++11 until C++20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><br><strong>std::memory_order</strong> specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation.<br>std::memory_order指定如何围绕一个atomic操作对内存访问（包括常规的非原子访存）进行排序。</atomic\></p>
<p>Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.<br>多核系统中由于缺少任何限制，当多个线程同时读写少量变量时，一个线程观察到的某个变量的值的改变可能与对这个变量进行写入操作的线程的写入顺序不同，甚至多个线程观察到的变量的值的改变顺序可能都存在差异。对于单核系统，由于在memory model允许下编译器对代码的优化，一些类似的现象也会发生。</p>
<p>The default behavior of all atomic operations in the library provides for <strong>sequentially consistent ordering</strong> (see discussion below). That default can <strong>hurt performance</strong>, but the library’s atomic operations can be given an additional <strong>std::memory_order</strong> argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.<br>所有atomic操作默认是顺序一致的排序（全序，memory_order_seq_cst），虽然保证了内存读写的顺序，但影响程序性能，损失了并行性。因此，可通过额外指定std::memory_order来规定编译器和处理器在操作中必须遵守的内存顺序。</p>
<blockquote>
<ul>
<li><h4 id="memory-order-relaxed"><a href="#memory-order-relaxed" class="headerlink" title="memory_order_relaxed"></a>memory_order_relaxed</h4>Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation’s atomicity is guaranteed (see Relaxed ordering below)</li>
</ul>
<ol>
<li>仅保证当前原子操作的原子性，除此之外<strong>不加任何同步与顺序约束</strong>。</li>
</ol>
<ul>
<li><h4 id="memory-order-release"><a href="#memory-order-release" class="headerlink" title="memory_order_release"></a>memory_order_release</h4>A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and <strong>writes that carry a dependency into the atomic variable</strong> become visible in other threads that consume the same atomic (see Release-Consume ordering below).</li>
</ul>
<ol>
<li>使用此内存序的<strong>写入操作</strong>对所写入的内存执行<strong>release</strong> operation。</li>
<li>当前线程中，代码中本写入操作之前的所有对这块内存的读写操作都不可重排到这次写入之后。（保证本写入操作的代码顺序正确，不会在写入前被读取到，不会在后续被错误覆盖。）</li>
<li>当前线程中<strong>release之前的所有写操作</strong>，对于其他对这个原子变量进行acquire操作的线程可见。</li>
<li>当前线程中<strong>release之前的所有与这块内存有关的写入操作（依赖此原子变量的写入操作）</strong>，对于其他对这个原子变量进行consume的线程可见。</li>
</ol>
<ul>
<li><h4 id="memory-order-acquire"><a href="#memory-order-acquire" class="headerlink" title="memory_order_acquire"></a>memory_order_acquire</h4>A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)</li>
</ul>
<ol>
<li>使用此内存序的<strong>读取操作</strong>对所读取的内存执行<strong>acquire</strong> operation。</li>
<li>当前线程中，代码中本读取操作其后所有对这块内存读写的操作都不可重排到这次读取之前。（保证本读取操作的代码顺序正确，不会在读取前被错误修改，也保证了当前读取操作的优先级）</li>
<li>对于其他对这个原子变量进行release的线程，其<strong>在release之前的所有写入操作</strong>对当前线程可见。</li>
</ol>
<ul>
<li><h4 id="memory-order-consume"><a href="#memory-order-consume" class="headerlink" title="memory_order_consume"></a>memory_order_consume</h4>A load operation with this memory order performs a consume operation on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see Release-Consume ordering below)</li>
</ul>
<ol>
<li>使用此内存序的<strong>读取操作</strong>对所读取的内存执行<strong>consume</strong> operation。</li>
<li>当前线程中，对所读取的内存施加<strong>acquire</strong>语义，在代码中这条语句后面所有<strong>与这块内存有关的读写操作 (carries a dependency)</strong> 都无法被重排到这个操作之前。（保证读取操作的代码顺序正确）</li>
<li>其他对这个原子变量进行release的线程，其<strong>在release之前与这块内存有关的所有写操作（依赖此原子变量的写入操作, carries a dependency）</strong> 对当前线程可见。（data-dependent variables，数据依赖型变量，其值依赖当前原子变量的值）</li>
</ol>
<ul>
<li><h4 id="memory-order-acq-rel"><a href="#memory-order-acq-rel" class="headerlink" title="memory_order_acq_rel"></a>memory_order_acq_rel</h4>A read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before the load, nor after the store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</li>
</ul>
<ol>
<li>使用此内存序的<strong>读后写操作(read-modify-write operation)</strong> 对内存执行<strong>acquire and release</strong> operation。同时具备acquire与release的特性。</li>
<li>acquire: 不可前置于load前;<br>release: 不可后置于store后;<br>acquire_release: <strong>前后顺序均不可变</strong>。</li>
<li>acquire特性：其他对本原子变量进行release操作的线程，在release前的所有写操作对本线程可见。</li>
<li>release特性：本线程在release前的所有写操作，对其他对本原子变量进行acquire的线程可见。</li>
</ol>
<ul>
<li><h4 id="memory-order-seq-cst"><a href="#memory-order-seq-cst" class="headerlink" title="memory_order_seq_cst"></a>memory_order_seq_cst</h4>A load operation with this memory order performs an acquire operation, a store performs a release operation, and read-modify-write performs both an acquire operation and a release operation, plus a single total order exists in which all threads observe all modifications in the same order (see Sequentially-consistent ordering below)</li>
</ul>
<ol>
<li>顺序一致性模型，不会出现重排导致的错误问题。<strong>默认的内存模型</strong>。</li>
<li>读操作: acquire operation;<br>写操作: release operation;<br>读后写操作: acquire and release operation。</li>
<li>所有使用此内存序的线程可观察到对所有内存修改的一个相同的顺序（<strong>统一的全局顺序</strong>）。依靠对所有参与线程<strong>对齐原子操作</strong>实现。</li>
<li>会在多个线程间切换，达到多个线程仿佛在一个线程内顺序执行的效果。即单线程中按照代码顺序，多线程之间按照一个全局统一顺序。</li>
</ol>
</blockquote>
<p>对于release-consume pattern，与release-acquire pattern不同的是，此内存序下不会限制线程中其他变量的重排，仅影响本原子变量和与本原子变量具有依赖关系的变量 (carries a dependency)的指令顺序，相比之下开销更小。</p>
<center><img src="/2022/02/23/cuda-6/1.png" width="100%" height="100%"><font color="#708090" size="2">C++11开始支持的集中内存模型</font></center>

<h2 id="C-Order-of-evaluation-C-求值顺序"><a href="#C-Order-of-evaluation-C-求值顺序" class="headerlink" title="C++ Order of evaluation C++ 求值顺序"></a>C++ Order of evaluation C++ 求值顺序</h2><p>Order of evaluation of any part of any expression, including order of evaluation of function arguments is unspecified (with some exceptions listed below). The compiler can evaluate operands and other subexpressions in any order, and may choose another order when the same expression is evaluated again.<br>C++中表达式任意部份的求值顺序，包括函数的各个参数的求值顺序是不确定的（有一些例外）。编译器可以以任意顺序对表达式中的操作数和其他子表达式求值，对同一表达式进行两次求值可能会以不同的顺序进行。<br>There is no concept of left-to-right or right-to-left evaluation in C++. This is not to be confused with left-to-right and right-to-left associativity of operators: the expression a() + b() + c() is parsed as (a() + b()) + c() due to left-to-right associativity of operator +, but c() may be evaluated first, last, or between a() or b() at run time.<br>C++中没有从左至右或者从右至左求值的概念。不能将这个概念与操作符的左右结合性混淆。由于 + 运算符由左至右的结合性，a() + b() + c()会以(a() + b()) + c()的顺序计算，但其中a()、b()、c()三个子表达式哪个首先求值，这个顺序不确定。</p>
<h4 id="Sequenced-before-rules-since-C-11"><a href="#Sequenced-before-rules-since-C-11" class="headerlink" title="Sequenced-before rules (since C++11)"></a>Sequenced-before rules (since C++11)</h4><p><strong>Evaluation of Expressions 表达式的求值</strong><br>Evaluation of each expression includes:</p>
<ol>
<li><strong>value computations</strong>: calculation of the value that is returned by the expression. This may involve determination of the identity of the object (glvalue evaluation, e.g. if the expression returns a reference to some object) or reading the value previously assigned to an object (prvalue evaluation, e.g. if the expression returns a number, or some other value)<br>计算表达式的返回值。可能涉及到glvalue evaluation，确定返回值的类型，或prvalue evaluation，获取先前分配给对象的值。</li>
<li><strong>Initiation of side effects</strong>: access (read or write) to an object designated by a volatile glvalue, modification (writing) to an object, calling a library I/O function, or calling a function that does any of those operations.<br>side effects的开始。对volatile glvalue对象的访问，调用I/O库函数，或调用具有上述操作的其他函数。实际改变了一个变量的值，而不仅仅是求值的计算过程。</li>
</ol>
<blockquote>
<p><strong>在C ++中，什么是左值lvalues，右值rvalues，x值xvalues，glvalue和prvalue？</strong></p>
<ul>
<li>左值 lvalues 具有程序可以访问的地址。左值表达式的示例包括变量名称，包括const变量，数组元素，返回左值引用的函数调用，位字段，并集和类成员。</li>
<li>将亡值 xvalue (expiring value) 表达式没有地址，表达式在执行完赋值任务后就会结束它的生命周期。可用于初始化右值引用，该引用提供对表达式的访问。示例包括返回右值引用的函数调用，数组下标等。</li>
<li>泛左值 glvalue (generalized left value) 是xvalues和左值lvalues的统称。</li>
<li>右值 rvalues，右值总有一个唯一的可读的值，其临时对象或子对象或与对象不相关的值。</li>
<li>纯右值 prvalue (pure right value)，即字面值，表达式没有程序可访问的地址。prvalue表达式的示例包括文字，返回非引用类型的函数调用。</li>
</ul>
<p><strong>什么是side effect?</strong></p>
<ul>
<li>每个表达式都会被evaluate，而这会产生一个值 (value computations) 同时可能包含side effects，而side effect指的就是执行状态（这里指的是状态机）被改变了。</li>
<li>如果函数调用f(x)在一次计算的结果为a，那么下次计算f(x)的结果也必须为a。能够保证这样结果的函数，就是没有side effect的函数。</li>
<li>例如表达式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
其evaluate的部份为<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
而该表达式的side effect即为将i + 1的值赋值给了变量 i，改变了变量 i 的状态，即为有一个side effect。</li>
<li>参考: <ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jffifa/p/3292465.html">C++的顺序点(sequence point)和副作用(side effect)</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/garfee_guan/article/details/12403987">C/C++中的side effect</a></li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>Sequenced-before Ordering</strong><br>“sequenced-before” is an asymmetric, transitive, pair-wise relationship between evaluations within the same thread.<br>sequenced-before用于表示<strong>单线程</strong>之间，两个操作上的先后顺序，可以进行传递。<br><strong>同一线程内</strong>，求值过程间的非对称、可传递、成对的关系。</p>
<ul>
<li>If A is sequenced before B, then evaluation of A will be complete before evaluation of B begins.<br>A的求值过程会在B的求值过程开始前完成。</li>
<li>If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins.<br>反之B的求值过程会在A的求值过程开始前完成。</li>
<li>If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:<br>若AB之前互相不具备sequenced before的关系，则有两种可能情况：<ul>
<li>evaluations of A and B are unsequenced: they may be performed in any order and may overlap (within a single thread of execution, the compiler may interleave the CPU instructions that comprise A and B)<br>二者为非排序关系，可以任意顺序进行，甚至重叠计算，乱序执行。</li>
<li>evaluations of A and B are indeterminately sequenced: they may be performed in any order but may not overlap: either A will be complete before B, or B will be complete before A. The order may be the opposite the next time the same expression is evaluated.<br>二者为不确定的顺序关系，可以按照任意顺序先后执行，但不可重叠。</li>
</ul>
</li>
</ul>
<p>两个操作A和操作B，如果有A sequenced-before B，除了表示<strong>操作A的顺序在B之前</strong>，还表示了<strong>操作A的结果操作B可见</strong>。因为A的求值过程已完成。</p>
<p><strong>Sequenced-before Rules</strong><br>我个人理解是由于C++中，在evaluate一个表达式时，由于不能确定对表达式每个部份evaluate的先后顺序，具有一个随记性。<br>而Sequenced-before指的就是evaluation order，指的是evaluate的先后顺序，一个完整的表达式结束后，其所有evaluation均已完成，此表达式一定Sequenced-before后续表达式。<br>而这种发生在evaluate过程中的随机性仅发生在一个完整的表达式内部。</p>
<h4 id="synchronizes-with"><a href="#synchronizes-with" class="headerlink" title="synchronizes-with"></a>synchronizes-with</h4><p>synchronizes-with关系强调的是<strong>变量被修改之后的传播关系</strong>（propagate），即如果一个线程修改某变量的之后的<strong>结果能被其它线程可见</strong>，那么就是满足synchronizes-with关系的。</p>
<h4 id="Modification-order"><a href="#Modification-order" class="headerlink" title="Modification order"></a>Modification order</h4><p>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.<br>针对<strong>某一特定原子变量</strong>的所有修改都将以一个指定到该原子变量的<strong>全局顺序</strong>进行。由于是原子变量，因此对其的所有操作都不可重叠，因此会有一个全局顺序。这个全局顺序被称为modification order。这就是原子变量的顺序一致性sequential consistency。<br>The following four requirements are guaranteed for all atomic operations:<br>所有原子操作都遵循以下四个条件：<br>1) <strong>Write-write coherence 写-写一致性</strong>: If evaluation A that modifies some atomic M (a write) <strong>happens-before</strong> evaluation B that modifies M, then A appears earlier than B in the modification order of M<br>A、B均为写入操作，且A happens-before B，则全局顺序modification order中A在B前面。</p>
<p>2) <strong>Read-read coherence 读-读一致性</strong>: if a value computation A of some atomic M (a read) happens-before a value computation B on M, and if the value of A comes from a write X on M, then the value of B is either the value stored by X, or the value stored by a side effect Y on M that appears later than X in the modification order of M.<br>A、B为值的计算，且均需要读取原子变量M。A happens-before B，且A的值来源于一个对原子变量M的写入操作X，B的值也来源于X或者来源于一个在modification order of M中晚于X的side effect Y。则全局顺序modification order中A在B前面。<br>简单来说就是A、B都是read操作，且A happens-before B，且A的值在modification order中会先于B得到。</p>
<p>3) <strong>Read-write coherence 读-写一致性</strong>: if a value computation A of some atomic M (a read) happens-before an operation B on M (a write), then the value of A comes from a side-effect (a write) X that appears earlier than B in the modification order of M<br>A是read，B是write，A happens-before B on M，且A的值来源于modification order of M中先于B的一个side-effect (a write)操作<br>简单来说就是，A是读，一个值计算操作，需要输入值，B是写操作，不需要输入值，A happens-before B，且A需要用到的值在modification order中先于B得到。</p>
<p>4) <strong>Write-read coherence 写-读一致性</strong>: if a side effect (a write) X on an atomic object M happens-before a value computation (a read) B of M, then the evaluation B shall take its value from X or from a side effect Y that follows X in the modification order of M<br>B是读，值计算，X是写，B需要用到X写入的值，或由在modification order中位于X后面的side effect Y写入的值。</p>
<h4 id="Release-sequence"><a href="#Release-sequence" class="headerlink" title="Release sequence"></a>Release sequence</h4><p>After a release operation A is performed on an atomic object M, the longest continuous subsequence of the <a href="#modification-order">modification order</a> of M that consists of<br>在对原子对象M施加一个release operation A后，由以下条件组成的对原子对象M的最长修改子序列</p>
<ol>
<li>Writes performed by the same thread that performed A<br>(until C++20)<br>执行A的线程中，后续发生的所有写入操作</li>
<li>Atomic read-modify-write operations made to M by any thread<br>其他线程对原子对象M施加的<strong>Atomic read-modify-write operations</strong><br>is known as release sequence headed by A<br>组成以A为head的release sequence。意为release sequence中的所有操作均为在A之后进行且A的结果对其可见</li>
</ol>
<h4 id="Carries-dependency（具有依赖关系）"><a href="#Carries-dependency（具有依赖关系）" class="headerlink" title="Carries dependency（具有依赖关系）"></a>Carries dependency（具有依赖关系）</h4><p>Within the same thread, evaluation A that is sequenced-before evaluation B may also carry a dependency into B (that is, B depends on A), if any of the following is true</p>
<ol>
<li>The value of A is used as an operand of B, except  <strong>A是B的操作数</strong><br>a) if B is a call to std::kill_dependency<br>b) if A is the left operand of the built-in <strong>&amp;&amp;</strong>, <strong>||</strong>, <strong>?:</strong>, or <strong>,</strong> operators. (left operand，左操作数，左值。在这三个运算符中，A、B为并列关系，其值不会互相影响，因此不存在依赖关系。如A ? B : 2<em>B，在此运算中A的取值只影响运算的返回值，而不会影响B的值。**为什么+-\</em>/之类的运算符没有这种性质？？逗号我能理解，前两个因为C++短路求值？三目运算符呢？是因为相当于一个if再加一个赋值号=？先求条件表达式的值，之后再决定求后面哪个表达式的值，未必一定执行到，与短路求值相似所以没有依赖关系吗？**)</li>
<li>A writes to a scalar object M, B reads from M  <strong>A写入对象M中，而B从M中读取数据</strong></li>
<li>A carries dependency into another evaluation X, and X carries dependency into B  <strong>X依赖于A，而B依赖于X，依赖关系的传递</strong></li>
</ol>
<h4 id="Dependency-ordered-before"><a href="#Dependency-ordered-before" class="headerlink" title="Dependency-ordered before"></a>Dependency-ordered before</h4><p>Between threads, evaluation A is dependency-ordered before evaluation B if any of the following is true<br><strong>线程间</strong>，求值过程A dependency-ordered before 求值过程B，当满足以下任一条件时：</p>
<ol>
<li>A performs a release operation on some atomic M, and, in a different thread, B performs a consume operation on the same atomic M, and B reads a value written by any part of the release sequence headed (until C++20) by A.<br>A对原子变量M实施了一个release operation，另一线程中，B对同一原子变量M实施了一个consume operation，且B读取了一个由以A为head的release sequence中的任一部份写入的值。</li>
<li>A is dependency-ordered before X and X <a href="#carries-dependency具有依赖关系">carries a dependency</a> into B.<br>dependency-ordered的传递，A —&gt; X —&gt; B</li>
</ol>
<blockquote>
<p><strong>条件1</strong>：</p>
<ul>
<li>value由以A为head的release sequence中的一部分写入，因此对value的写入操作必在A之后。</li>
<li>release-consume模型，使得两次原子操作对齐，且对与原子对象M有关的内存操作具有约束。本线程中，consume operation后的与变量M有关的读写操作不可前置。</li>
<li>由于value是B的参数，B的执行需要先读取value，因此二者有一个dependency，而写入value的操作在A之后。因此A dependency-ordered before B。</li>
</ul>
</blockquote>
<h4 id="Data-Dependency"><a href="#Data-Dependency" class="headerlink" title="Data Dependency"></a>Data Dependency</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qls315/article/details/120721892">C++11多线程 内存序(std::memory_order_consume)</a></p>
<center><img src="/2022/02/23/cuda-6/2.png" width="100%" height="100%"><font color="#708090" size="2">carries-a-dependency-to (发生于同一线程内部)</font></center>

<center><img src="/2022/02/23/cuda-6/3.png" width="100%" height="100%"><font color="#708090" size="2">dependency-ordered-before (发生于不同线程之间)</font></center>

<h4 id="Inter-thread-happens-before"><a href="#Inter-thread-happens-before" class="headerlink" title="Inter-thread happens-before"></a>Inter-thread happens-before</h4><p>Between threads, evaluation A inter-thread happens before evaluation B if any of the following is true<br><strong>线程间</strong>，某一线程中的求值过程A在另一线程中的求值过程B之前发生，当满足以下任一条件时：</p>
<ol>
<li>A synchronizes-with B<br><strong>A的结果对B可见</strong></li>
<li>A is <strong>dependency-ordered before</strong> B</li>
<li>A synchronizes-with some evaluation X, and X is sequenced-before B<br><strong>A的结果对X可见，X sequenced-before B，传递过程</strong></li>
<li>A is sequenced-before some evaluation X, and X inter-thread happens-before B<br><strong>A sequenced-before X (同一线程中)，而X inter-thread happens-before B (不同线程中)，跨线程传递</strong></li>
<li>A inter-thread happens-before some evaluation X, and X inter-thread happens-before B<br><strong>happens-before的传递</strong></li>
</ol>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>happens-before关系表示的为<strong>同线程/不同线程之间</strong>的操作先后顺序，同样的也是非对称、可传递的关系。</p>
<p>如果A happens-before B，则A的内存状态将在B操作执行之前就可见。某些情况下一个写操作只是简单的写入Cache就返回了（没有真正的写入内存中），其他核心上的操作不一定能马上见到操作的结果，这样的关系是不满足happens-before的。</p>
<p>Regardless of threads, evaluation A happens-before evaluation B if any of the following is true:</p>
<p>1) A is sequenced-before B <strong>同线程</strong><br>2) A inter-thread happens before B <strong>跨线程</strong><br>The implementation is required to ensure that the happens-before relation is acyclic (非循环的、非周期的), by introducing additional synchronization if necessary (it can only be necessary if a consume operation is involved, see Batty et al)</p>
<p>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a <strong>data race</strong>) unless there exists a happens-before relationship between these two evaluations.</p>
<p>如果两个操作存在内存竞争或两个操作至少一个为非原子操作，则会导致undefined behavior，除非存在一个happens-before的关系。</p>
<h4 id="Visible-side-effects"><a href="#Visible-side-effects" class="headerlink" title="Visible side-effects"></a>Visible side-effects</h4><p>The side-effect A on a scalar M (a write) is visible with respect to value computation B on M (a read) if both of the following are true:<br>value computation B，值计算过程需要读取数据，是read操作<br>side-effect A，是对状态机的修改，修改了变量，是write操作<br>如果下列两个条件均成立，则对变量M的side-effect A对对变量M的value computation B可见：</p>
<p>1) A happens-before B<br>   此时在B之前A已经完成，且A的结果对B可见<br>2) There is no other side effect X to M where A happens-before X and X happens-before B<br>   A、B之间没有其他的对变量M的side effect X。因为会修改变量M的值，导致side effect A的结果被覆盖。</p>
<p>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset (最长连续子集) of the side-effects to M, in modification order, where B does not happen-before it is known as <strong>the visible sequence of side-effects</strong>. (the value of M, determined by B, will be the value stored by one of these side effects)</p>
<p>Note: inter-thread synchronization boils down to (归根结底是) preventing data races (by establishing happens-before relationships) and defining which side effects become visible under what conditions</p>
<h4 id="memory-order-seq-cst-顺序一致性模型示例代码"><a href="#memory-order-seq-cst-顺序一致性模型示例代码" class="headerlink" title="memory_order_seq_cst 顺序一致性模型示例代码"></a>memory_order_seq_cst 顺序一致性模型示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x为false时自旋</span></span><br><span class="line">    <span class="keyword">while</span>(!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="comment">// 若y为true，++z</span></span><br><span class="line">    <span class="keyword">if</span>(y.<span class="built_in">load</span>(std::memory_order_seq_cst))</span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_seq_cst))</span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="literal">false</span>;</span><br><span class="line">    y=<span class="literal">false</span>;</span><br><span class="line">    z=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// std::thread，c++ 11之后的标准线程库</span></span><br><span class="line">    <span class="comment">// 初始化构造函数</span></span><br><span class="line">    <span class="comment">// template &lt;class Fn, class... Args&gt; </span></span><br><span class="line">    <span class="comment">// explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;... args);</span></span><br><span class="line">    <span class="comment">// 新产生的线程会调用fn函数，该函数的参数由args给出</span></span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;<span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    <span class="comment">// join(): 阻塞调用线程，让调用线程等待子线程执行完毕，然后再往下执行。</span></span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">    d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// void assert(int expression);</span></span><br><span class="line">    <span class="comment">// assert的执行是判断expression是否为假，只有在表达式为假时，才会调用abort报警。</span></span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于采用了顺序一致性模型，因此最后的断言assert不可能发生，即在程序结束时不可能出现z为0的情况。<br>所有线程共享一个执行顺序，就是代码顺序。</p>
<h4 id="memory-order-relaxed-松散内存模型示例代码"><a href="#memory-order-relaxed-松散内存模型示例代码" class="headerlink" title="memory_order_relaxed 松散内存模型示例代码"></a>memory_order_relaxed 松散内存模型示例代码</h4><p>Atomic operations tagged memory_order_relaxed are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee <strong>atomicity</strong> and <strong>modification order (指的是对相应原子操作进行修改的全局顺序)</strong> consistency.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1:</span></span><br><span class="line">r1 = y.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// A</span></span><br><span class="line">x.<span class="built_in">store</span>(r1, std::memory_order_relaxed); <span class="comment">// B</span></span><br><span class="line"><span class="comment">// Thread 2:</span></span><br><span class="line">r2 = x.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// C </span></span><br><span class="line">y.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed); <span class="comment">// D</span></span><br></pre></td></tr></table></figure>
<p>A is sequenced-before B within thread 1. A的side effect修改了变量r1，而B需要读取r1的值。<br>A -&gt; B<br>其余操作之间则没有任何顺序约束。因此可能有r1 = r1 = 42，此种情况下，执行顺序为<br>D -&gt; A -&gt; B -&gt; C</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);<span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// y为false时自旋</span></span><br><span class="line">    <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));<span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 若x为true，++z</span></span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))<span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="literal">false</span>;</span><br><span class="line">    y=<span class="literal">false</span>;</span><br><span class="line">    z=<span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用memory_order_relaxed模型，导致最后的断言有可能发生，即z可能为0。<br>此时的执行顺序为:<br>2(y = true), 3, 4(x = false), 1(x = true)</p>
<h4 id="Acquire-Release-模型示例代码"><a href="#Acquire-Release-模型示例代码" class="headerlink" title="Acquire-Release 模型示例代码"></a>Acquire-Release 模型示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.<span class="built_in">load</span>(std::memory_order_acquire)));<span class="comment">// 空指针会自旋</span></span><br><span class="line">    <span class="comment">// acquire操作，保证本线程中本次原子读正确，后续读写不许前置。</span></span><br><span class="line">    <span class="comment">// 与producer中对于ptr的原子release写操作对齐，可见release之前所有写操作</span></span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="comment">// 此处由于本线程内acquire的约束，两次assert一定发生在ptr.load之后，而此时producer中ptr.store及其之前所有写操作对本线程可见，因此此处两个断言中表达式均为真，断言不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();<span class="comment">// 阻塞当前调用线程，等待两个线程执行结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Acquire-Release的传递示例代码"><a href="#Acquire-Release的传递示例代码" class="headerlink" title="Acquire-Release的传递示例代码"></a>Acquire-Release的传递示例代码</h4><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">std::atomic<T>::compare_exchange_weak, std::atomic<T>::compare_exchange_strong</T></T></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">( T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::memory_order failure )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">( T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::memory_order order = std::memory_order_seq_cst )</span></span></span><br><span class="line"><span class="function"><span class="comment">// compare_exchange_strong函数默认使用std::memory_order_seq_cst内存模型。</span></span></span><br></pre></td></tr></table></figure>
<p>将*this与expected进行比对:</p>
<ul>
<li>如果二者bitwise-equal (按位相等)，将*this替换为desired (read-modify-write operation)。</li>
<li>否则，将*this存储于expected中 (load operation)。</li>
</ul>
<p>The memory models for the read-modify-write and load operations are success and failure respectively.<br>success与failure分别是:</p>
<ul>
<li>比对成功时read-modify-write operation的内存模型</li>
<li>比对失败时load operation的内存模型</li>
</ul>
<p>order is used for both read-modify-write and load operations.<br>另一版本中两种操作都是用order作为内存模型，除非</p>
<ul>
<li>order == std::memory_order_acq_rel (读-修改-写)，那么load operation使用std::memory_order_acquire</li>
<li>order == std::memory_order_release (读-修改-写)，那么load operation使用std::memory_order_relaxed</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">    <span class="comment">// 由于这里是release operation，因此data已经被置为42。</span></span><br><span class="line">    <span class="comment">// flag被置为1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> expected=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// memory_order_relaxed is okay because this is an RMW,</span></span><br><span class="line">    <span class="comment">// and RMWs (with any ordering) following a release form a release sequence</span></span><br><span class="line">    <span class="comment">// RMW：Read-Modify-Write，读-修改-写操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比对flag与expected，如果相等，则将flag赋值为2，否则将flag中的值存储于expected中</span></span><br><span class="line">    <span class="comment">// 这里由于compare_exchange_strong操作使用memory_order_relaxed，松散内存模型，因此上面的expected=1未必一定在之前完成，expected值不确定。</span></span><br><span class="line">    <span class="comment">// compare_exchange_strong与flag.store(1, std::memory_order_release)形成release sequence，此时flag = 1</span></span><br><span class="line">    <span class="comment">// compare_exchange_strong如果判断为flase (expected != 1)，将会一直处于自旋状态，直到expected = 1时，将flag赋值为2</span></span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_relaxed)) &#123;</span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// acquire operation，与flag.store(1, std::memory_order_release)形成release sequence，且由于thread_2()有可能将flag置为2，因此此时flag可能为1或2，而data则必为42。</span></span><br><span class="line">    <span class="comment">// 若flag为1则保持自旋，若为2则继续，执行到此时，data[0]必为42。</span></span><br><span class="line">    <span class="comment">// 且由于acquire内存模型限制，本线程内acquire operation后面的所有读写操作不可前置。</span></span><br><span class="line">    <span class="comment">// 因此assert中条件恒为真，assert不会执行。</span></span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// if we read the value 2 from the atomic flag, we see 42 in the vector</span></span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ByteDanceTech/article/details/120984767">深入理解一致性与 C++ 内存模型</a>中写道：</p>
<blockquote>
<p><a href="#release-sequence">Release sequence</a><br>对于一个变量 M，evaluation A 是作用在 M 的一个 release operation，那么在 A 之后由下面两种情况：</p>
<ul>
<li>同一线程内以任意 memory_order 执行的原子操作，</li>
<li>不同线程内 <strong>read-modify-write</strong> 类的所有原子操作，比如 fetch_add、cas 等</li>
</ul>
<p>构成的 modification order(包括 A) 称之为 以 A 为 head 的 release sequence。</p>
<p>比如对于 M，A 是一个 release operation，之后本线程内有 relaxed 的任意操作 B，其他线程有 <strong>read-modify-write</strong> 类操作如 fetch_add C、D，那么 A -&gt; {B、C、D } 是以 A 为 head 的 release sequence。由于 B、C、D 顺序不确定，所以这里放到了一个大括号内。具体为什么这么设计，可以参考 &lt;<C++ concurrency in action>&gt; 5.3.4 一节。</C++></p>
</blockquote>
<p>上面程序中，thread_2()中的compare_exchange_strong即包含read-modify-write 类的atomic operation，因此会与thread_1()中的flag.store(1, std::memory_order_release)，一个release operation，形成一个以flag.store(1, std::memory_order_release)为head的release sequence，使得compare_exchange_strong会在其后执行，并可见thread_1()中flag.store(1, std::memory_order_release)之前的所有写操作。</p>
<blockquote>
<p>对应程序中的注释:<br>RMWs (with any ordering) following a release form a release sequence.<br>这个following a release的release指的就是thread_1()中的flag.store(1, std::memory_order_release)</p>
</blockquote>
<ul>
<li><strong>release sequence 1</strong>:<br>data.push_back(42)  —&gt;  flag.store(1, std::memory_order_release)</li>
<li><strong>release sequence 2</strong>:<br>flag.store(1, std::memory_order_release)  —&gt;  flag.compare_exchange_strong(expected, 2, std::memory_order_relaxed)<br>flag.store(1, std::memory_order_release)  —&gt;  flag.load(std::memory_order_acquire)</li>
</ul>
<p>可见release传递了两次。</p>
<ul>
<li><strong>acquire operation</strong><br>flag.load(std::memory_order_acquire)  —&gt;  assert(data.at(0) == 42)</li>
</ul>
<h4 id="Release-Consume模型示例代码"><a href="#Release-Consume模型示例代码" class="headerlink" title="Release-Consume模型示例代码"></a>Release-Consume模型示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">    <span class="comment">// 需要读取指针p，carries a dependency情况，因此*p必为&quot;Hello&quot;</span></span><br><span class="line">    <span class="comment">// 而data的写入与原子变量ptr无关，在Release-Consume内存模型下，这个操作有可能被重排到原子操作之后</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.<span class="built_in">load</span>(std::memory_order_consume)));</span><br><span class="line">    <span class="comment">// consume operation，本线程内其后所有与ptr有关的读写不可前置</span></span><br><span class="line">    <span class="comment">// 与release operation构成Release-Consume内存模型</span></span><br><span class="line">    <span class="comment">// 这里ptr是p2的操作数，p2依赖于ptr，二者有关联，因此下一条指令不可前置，ptr carries a dependency into p2.</span></span><br><span class="line">    <span class="comment">// consume只保证有carries dependency的读写操作的顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires: *p2 carries dependency from ptr</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// may or may not fire: data does not carry dependency from ptr</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Sequentially-consistent-ordering模型示例代码"><a href="#Sequentially-consistent-ordering模型示例代码" class="headerlink" title="Sequentially-consistent ordering模型示例代码"></a>Sequentially-consistent ordering模型示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; y = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="comment">// 若x为true则检查y，若y为true则z+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="comment">// 若y为true则检查x，若x为true则z+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123;</span><br><span class="line">        ++z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 全序模型下所有线程共用一套顺序，因此调用线程看到的顺序就是实际线程执行顺序，在xy读取之前xy的写入操作均已完成。z一定为2</span></span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>(); d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>() != <span class="number">0</span>);  <span class="comment">// will never happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/22/cuda-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/cuda-5/" class="post-title-link" itemprop="url">CUDA学习随记5 Asynchronous copy cp.async</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-22 21:51:12" itemprop="dateCreated datePublished" datetime="2022-02-22T21:51:12+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-28 22:18:33" itemprop="dateModified" datetime="2022-06-28T22:18:33+08:00">2022-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CUDA 11新特性，Ampere架构支持，Asynchronous copy异步数据拷贝</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/22/cuda-5/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/20/cuda-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/20/cuda-4/" class="post-title-link" itemprop="url">CUDA学习随记4 Volta’s Independent Thread Scheduling</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-20 20:09:48" itemprop="dateCreated datePublished" datetime="2022-02-20T20:09:48+08:00">2022-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-28 22:15:35" itemprop="dateModified" datetime="2022-06-28T22:15:35+08:00">2022-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Volta架构NVIDIA GPU的独立线程调度，Under Warp级别的线程调度</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/20/cuda-4/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/16/ComSys-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/16/ComSys-1/" class="post-title-link" itemprop="url">计算机系统学习随记 原子操作是如何实现的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-16 01:46:36 / Modified: 01:53:28" itemprop="dateCreated datePublished" datetime="2022-02-16T01:46:36+08:00">2022-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">计算机系统学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原子操作是如何实现的"><a href="#原子操作是如何实现的" class="headerlink" title="原子操作是如何实现的"></a>原子操作是如何实现的</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33445834">知乎: 原子操作是如何实现的？</a></p>
<blockquote>
<p>X86架构(The X86 architecture)</p>
</blockquote>
<p>X86架构(The X86 architecture)是微处理器执行的计算机语言指令集，对应32位。而平时常说的x64，全称是x86-64，对应64位，是x86指令集的64位扩展超集，具备向下兼容的特点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/11/cuda-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/11/cuda-3/" class="post-title-link" itemprop="url">CUDA学习随记3 Memory Fence与Synchronization</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-11 17:13:37" itemprop="dateCreated datePublished" datetime="2022-02-11T17:13:37+08:00">2022-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-28 22:14:32" itemprop="dateModified" datetime="2022-06-28T22:14:32+08:00">2022-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CUDA中用于保证多线程内存数据安全读写的Memory Fence与线程同步Synchronization</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/11/cuda-3/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/10/cuda-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/cuda-2/" class="post-title-link" itemprop="url">CUDA学习随记2 关于Warp Shuffle Functions *_sync 首个参数mask的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-10 22:22:15" itemprop="dateCreated datePublished" datetime="2022-02-10T22:22:15+08:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-28 22:12:47" itemprop="dateModified" datetime="2022-06-28T22:12:47+08:00">2022-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CUDA Warp Shuffle Functions的mask参数，用于指定参与到Shuffle的lane</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/10/cuda-2/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/10/cuda-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/10/cuda-1/" class="post-title-link" itemprop="url">CUDA学习随记1 Using CUDA Warp-Level Primitives</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-10 13:55:56" itemprop="dateCreated datePublished" datetime="2022-02-10T13:55:56+08:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-28 22:11:58" itemprop="dateModified" datetime="2022-06-28T22:11:58+08:00">2022-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CUDA Warp级别的函数与操作</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/10/cuda-1/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/09/NVIDIA-intern-paper-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/09/NVIDIA-intern-paper-md/" class="post-title-link" itemprop="url">NVIDIA Intern Paper 1 Smoke Simulation Method</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-09 23:02:28" itemprop="dateCreated datePublished" datetime="2022-02-09T23:02:28+08:00">2022-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-11 15:11:38" itemprop="dateModified" datetime="2022-02-11T15:11:38+08:00">2022-02-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cuda-Performance-Optimization-of-a-Multigrid-Poisson-Solver-for-Smoke-Simulation/" itemprop="url" rel="index"><span itemprop="name">Cuda Performance Optimization of a Multigrid Poisson Solver for Smoke Simulation</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cuda-Performance-Optimization-of-a-Multigrid-Poisson-Solver-for-Smoke-Simulation/1-Smoke-Simulation-Method/" itemprop="url" rel="index"><span itemprop="name">1 Smoke Simulation Method</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Cuda-Performance-Optimization-of-a-Multigrid-Poisson-Solver-for-Smoke-Simulation"><a href="#Cuda-Performance-Optimization-of-a-Multigrid-Poisson-Solver-for-Smoke-Simulation" class="headerlink" title="Cuda Performance Optimization of a Multigrid Poisson Solver for Smoke Simulation"></a>Cuda Performance Optimization of a Multigrid Poisson Solver for Smoke Simulation</h1><h2 id="1-Smoke-Simulation-Method"><a href="#1-Smoke-Simulation-Method" class="headerlink" title="1. Smoke Simulation Method"></a>1. Smoke Simulation Method</h2><h3 id="1-1-Operator-Splitting-Method"><a href="#1-1-Operator-Splitting-Method" class="headerlink" title="1.1. Operator-Splitting Method"></a>1.1. Operator-Splitting Method</h3><p><strong>Reference:</strong> Harris M J. Fast fluid dynamics simulation on the GPU[J]. SIGGRAPH Courses, 2005, 220(10.1145): 1198555-1198790.<br>&ensp;&ensp;The smoke simulation solves an incompressible NS equation expressed as</p>
<script type="math/tex; mode=display">\frac{\partial \mathbf{u} }{\partial t}=-\left( \mathbf{u}\cdot \nabla  \right)\mathbf{u}-\frac{1}{\rho }\nabla p+\nu { {\nabla }^{2} }\mathbf{u}+\mathbf{F} \tag {1.1.1}</script><p>, where <strong>u</strong> is the velocity field and for an incompressible fluid, it satisfies</p>
<script type="math/tex; mode=display">\nabla \cdot \mathbf{u}=0. \tag {1.1.2}</script><p>With the Operator-Splitting Method, the solution of the NS equation is calculated via composition of transformations on the state. In other words, each component of the NS equation is a step that takes a field as input, and produces a new field as output. $\color{red}{[Fast Fluid Dynamics Simulation on the GPU.]}$ Define an operator <strong>S</strong> that is equivalent to the solution of NS equation over a single time step. Then, the operator S can be decomposed into the operators for advection <strong>A</strong>, diffusion <strong>D</strong>, force application <strong>F</strong>, and projection <strong>P</strong>.</p>
<center><img src="/2022/02/09/NVIDIA-intern-paper-md/1.1.1_1.png" width="50%" height="50%"></center>

<p>&ensp;&ensp;After <strong>F</strong>, <strong>D</strong>, and <strong>A</strong> operations, we can get a divergent velocity field <strong>w</strong>. Then we can get the velocity field <strong>u</strong> with zero divergence by adopting the Helmholtz-Hodge Decomposition Theorem.</p>
<script type="math/tex; mode=display">\mathbf{w}=\mathbf{u}+\nabla p \tag {1.1.3}</script><p>This process is called the projection corresponding to <strong>P</strong>. A projection operation is always needed to guarantee the incompressibility of the fluid.<br>&ensp;&ensp;If we apply the divergence operator to both sides of the above equation, we obtain</p>
<script type="math/tex; mode=display">\nabla \cdot \mathbf{u}+{ {\nabla }^{2} }p={ {\nabla }^{2} }p=\nabla \cdot \mathbf{w}. \tag {1.1.4}</script><p>Note that for an incompressible fluid, we have $\nabla \cdot \mathbf{u}=0$. Then, it becomes a Poisson equation for the pressure of the fluid, sometimes called the Poisson-pressure equation. With this equation, we can get the pressure p, and then use <strong>w</strong> and p to compute the new divergence-free velocity field <strong>u</strong> by</p>
<script type="math/tex; mode=display">\mathbf{w}=\mathbf{u}+\nabla p. \tag {1.1.5}</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/1970/01/01/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/1970/01/01/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 1970-01-01 08:00:00" itemprop="dateCreated datePublished" datetime="1970-01-01T08:00:00+08:00">1970-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-09 19:43:51" itemprop="dateModified" datetime="2022-02-09T19:43:51+08:00">2022-02-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiang Shao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiang Shao</p>
  <div class="site-description" itemprop="description">WeChat: shaojiang9650<br>Email: shao_study@163.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Shao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
