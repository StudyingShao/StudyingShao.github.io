<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="原子操作中的内存顺序std::memory_order与CUDA中的异步barrier">
<meta property="og:type" content="article">
<meta property="og:title" content="CUDA学习随记6 Asynchronous Barrier">
<meta property="og:url" content="http://example.com/2022/02/23/cuda-6/index.html">
<meta property="og:site_name" content="邵大宝的学习Blog">
<meta property="og:description" content="原子操作中的内存顺序std::memory_order与CUDA中的异步barrier">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/02/23/cuda-6/1.png">
<meta property="article:published_time" content="2022-02-23T13:41:50.000Z">
<meta property="article:modified_time" content="2022-06-30T15:46:01.093Z">
<meta property="article:author" content="Jiang Shao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/02/23/cuda-6/1.png">

<link rel="canonical" href="http://example.com/2022/02/23/cuda-6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CUDA学习随记6 Asynchronous Barrier | 邵大宝的学习Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">邵大宝的学习Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">最爱严小跳</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/23/cuda-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CUDA学习随记6 Asynchronous Barrier
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-23 21:41:50" itemprop="dateCreated datePublished" datetime="2022-02-23T21:41:50+08:00">2022-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-30 23:46:01" itemprop="dateModified" datetime="2022-06-30T23:46:01+08:00">2022-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          
            <div class="post-description">原子操作中的内存顺序std::memory_order与CUDA中的异步barrier</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CUDA学习随记6-std-memory-order-amp-B-25-Asynchronous-Barrier"><a href="#CUDA学习随记6-std-memory-order-amp-B-25-Asynchronous-Barrier" class="headerlink" title="CUDA学习随记6  std::memory_order &amp; B.25. Asynchronous Barrier"></a>CUDA学习随记6  std::memory_order &amp; B.25. Asynchronous Barrier</h1><ol>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/06/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e/">CUDA, 软件抽象的幻影背后</a></li>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/08/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%ba%8c/">CUDA, 软件抽象的幻影背后 之二</a></li>
<li><p><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/13/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%b8%89/">CUDA, 软件抽象的幻影背后 之三</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#aw-barrier">CUDA C++ Programming Guide: B.25. Asynchronous Barrier</a></p>
</li>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-mbarrier">PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier</a></li>
</ol>
<p>CUDA Samples里面有好多有意思的代码，多学多看</p>
<p>6_Advanced/jacobiCudaGraphs<br>0_Simple\cudaTensorCoreGemm</p>
<blockquote>
<p><strong>References:</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++11 std::memory_order</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45566448">内存顺序（Memory Order）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codedump.info/post/20191214-cxx11-memory-model-1/">C++11中的内存模型上篇 - 内存模型基础</a></li>
<li><a target="_blank" rel="noopener" href="https://www.codedump.info/post/20191214-cxx11-memory-model-2/">C++11中的内存模型下篇 - C++11支持的几种内存模型</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#aw-barrier">CUDA C++ Programming Guide: B.25. Asynchronous Barrier</a></li>
</ol>
</blockquote>
<h2 id="std-memory-order-C-11"><a href="#std-memory-order-C-11" class="headerlink" title="std::memory_order (C++11)"></a>std::memory_order (C++11)</h2><p>Defined in header \<atomic\><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// since C++11 until C++20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><br><strong>std::memory_order</strong> specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation.<br>std::memory_order指定如何围绕一个atomic操作对内存访问（包括常规的非原子访存）进行排序。</atomic\></p>
<p>Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.<br>多核系统中由于缺少任何限制，当多个线程同时读写少量变量时，一个线程观察到的某个变量的值的改变可能与对这个变量进行写入操作的线程的写入顺序不同，甚至多个线程观察到的变量的值的改变顺序可能都存在差异。对于单核系统，由于在memory model允许下编译器对代码的优化，一些类似的现象也会发生。</p>
<p>The default behavior of all atomic operations in the library provides for <strong>sequentially consistent ordering</strong> (see discussion below). That default can <strong>hurt performance</strong>, but the library’s atomic operations can be given an additional <strong>std::memory_order</strong> argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.<br>所有atomic操作默认是顺序一致的排序（全序，memory_order_seq_cst），虽然保证了内存读写的顺序，但影响程序性能，损失了并行性。因此，可通过额外指定std::memory_order来规定编译器和处理器在操作中必须遵守的内存顺序。</p>
<blockquote>
<ul>
<li><h4 id="memory-order-relaxed"><a href="#memory-order-relaxed" class="headerlink" title="memory_order_relaxed"></a>memory_order_relaxed</h4>Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation’s atomicity is guaranteed (see Relaxed ordering below)</li>
</ul>
<ol>
<li>仅保证当前原子操作的原子性，除此之外<strong>不加任何同步与顺序约束</strong>。</li>
</ol>
<ul>
<li><h4 id="memory-order-release"><a href="#memory-order-release" class="headerlink" title="memory_order_release"></a>memory_order_release</h4>A store operation with this memory order performs the release operation: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see Release-Acquire ordering below) and <strong>writes that carry a dependency into the atomic variable</strong> become visible in other threads that consume the same atomic (see Release-Consume ordering below).</li>
</ul>
<ol>
<li>使用此内存序的<strong>写入操作</strong>对所写入的内存执行<strong>release</strong> operation。</li>
<li>当前线程中，代码中本写入操作之前的所有对这块内存的读写操作都不可重排到这次写入之后。（保证本写入操作的代码顺序正确，不会在写入前被读取到，不会在后续被错误覆盖。）</li>
<li>当前线程中<strong>release之前的所有写操作</strong>，对于其他对这个原子变量进行acquire操作的线程可见。</li>
<li>当前线程中<strong>release之前的所有与这块内存有关的写入操作（依赖此原子变量的写入操作）</strong>，对于其他对这个原子变量进行consume的线程可见。</li>
</ol>
<ul>
<li><h4 id="memory-order-acquire"><a href="#memory-order-acquire" class="headerlink" title="memory_order_acquire"></a>memory_order_acquire</h4>A load operation with this memory order performs the acquire operation on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see Release-Acquire ordering below)</li>
</ul>
<ol>
<li>使用此内存序的<strong>读取操作</strong>对所读取的内存执行<strong>acquire</strong> operation。</li>
<li>当前线程中，代码中本读取操作其后所有对这块内存读写的操作都不可重排到这次读取之前。（保证本读取操作的代码顺序正确，不会在读取前被错误修改，也保证了当前读取操作的优先级）</li>
<li>对于其他对这个原子变量进行release的线程，其<strong>在release之前的所有写入操作</strong>对当前线程可见。</li>
</ol>
<ul>
<li><h4 id="memory-order-consume"><a href="#memory-order-consume" class="headerlink" title="memory_order_consume"></a>memory_order_consume</h4>A load operation with this memory order performs a consume operation on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see Release-Consume ordering below)</li>
</ul>
<ol>
<li>使用此内存序的<strong>读取操作</strong>对所读取的内存执行<strong>consume</strong> operation。</li>
<li>当前线程中，对所读取的内存施加<strong>acquire</strong>语义，在代码中这条语句后面所有与这块内存有关的读写操作都无法被重排到这个操作之前。（保证读取操作的代码顺序正确）</li>
<li>其他对这个原子变量进行release的线程，其<strong>在release之前与这块内存有关的所有写操作（依赖此原子变量的写入操作）</strong> 对当前线程可见。（data-dependent variables，数据依赖型变量，其值依赖当前原子变量的值）</li>
</ol>
<ul>
<li><h4 id="memory-order-acq-rel"><a href="#memory-order-acq-rel" class="headerlink" title="memory_order_acq_rel"></a>memory_order_acq_rel</h4>A read-modify-write operation with this memory order is both an acquire operation and a release operation. No memory reads or writes in the current thread can be reordered before the load, nor after the store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</li>
</ul>
<ol>
<li>使用此内存序的<strong>读后写操作(read-modify-write operation)</strong> 对内存执行<strong>acquire and release</strong> operation。同时具备acquire与release的特性。</li>
<li>acquire: 不可前置于load前;<br>release: 不可后置于store后;<br>acquire_release: <strong>前后顺序均不可变</strong>。</li>
<li>acquire特性：其他对本原子变量进行release操作的线程，在release前的所有写操作对本线程可见。</li>
<li>release特性：本线程在release前的所有写操作，对其他对本原子变量进行acquire的线程可见。</li>
</ol>
<ul>
<li><h4 id="memory-order-seq-cst"><a href="#memory-order-seq-cst" class="headerlink" title="memory_order_seq_cst"></a>memory_order_seq_cst</h4>A load operation with this memory order performs an acquire operation, a store performs a release operation, and read-modify-write performs both an acquire operation and a release operation, plus a single total order exists in which all threads observe all modifications in the same order (see Sequentially-consistent ordering below)</li>
</ul>
<ol>
<li>顺序一致性模型，不会出现重排导致的错误问题。<strong>默认的内存模型</strong>。</li>
<li>读操作: acquire operation;<br>写操作: release operation;<br>读后写操作: acquire and release operation。</li>
<li>所有使用此内存序的线程可观察到对所有内存修改的一个相同的顺序（<strong>统一的全局顺序</strong>）。依靠对所有参与线程<strong>对齐原子操作</strong>实现。</li>
<li>会在多个线程间切换，达到多个线程仿佛在一个线程内顺序执行的效果。即单线程中按照代码顺序，多线程之间按照一个全局统一顺序。</li>
</ol>
</blockquote>
<p>对于release-consume pattern，与release-acquire pattern不同的是，此内存序下不会限制线程中其他变量的重排，仅影响本原子变量和与本原子变量具有依赖关系的变量的指令顺序，相比之下开销更小。</p>
<center><img src="/2022/02/23/cuda-6/1.png" width="100%" height="100%"><font color="#708090" size="2">C++11开始支持的集中内存模型</font></center>

<h4 id="memory-order-seq-cst-顺序一致性模型示例代码"><a href="#memory-order-seq-cst-顺序一致性模型示例代码" class="headerlink" title="memory_order_seq_cst 顺序一致性模型示例代码"></a>memory_order_seq_cst 顺序一致性模型示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// x为false时自旋</span></span><br><span class="line">    <span class="keyword">while</span>(!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="comment">// 若y为true，++z</span></span><br><span class="line">    <span class="keyword">if</span>(y.<span class="built_in">load</span>(std::memory_order_seq_cst))</span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_seq_cst))</span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="literal">false</span>;</span><br><span class="line">    y=<span class="literal">false</span>;</span><br><span class="line">    z=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// std::thread，c++ 11之后的标准线程库</span></span><br><span class="line">    <span class="comment">// 初始化构造函数</span></span><br><span class="line">    <span class="comment">// template &lt;class Fn, class... Args&gt; </span></span><br><span class="line">    <span class="comment">// explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;... args);</span></span><br><span class="line">    <span class="comment">// 新产生的线程会调用fn函数，该函数的参数由args给出</span></span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;<span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    <span class="comment">// join(): 阻塞调用线程，让调用线程等待子线程执行完毕，然后再往下执行。</span></span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    c.<span class="built_in">join</span>();</span><br><span class="line">    d.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// void assert(int expression);</span></span><br><span class="line">    <span class="comment">// assert的执行是判断expression是否为假，只有在表达式为假时，才会调用abort报警。</span></span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于采用了顺序一致性模型，因此最后的断言assert不可能发生，即在程序结束时不可能出现z为0的情况。<br>所有线程共享一个执行顺序，就是代码顺序。</p>
<h4 id="memory-order-relaxed-松散内存模型示例代码"><a href="#memory-order-relaxed-松散内存模型示例代码" class="headerlink" title="memory_order_relaxed 松散内存模型示例代码"></a>memory_order_relaxed 松散内存模型示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);<span class="comment">// 1</span></span><br><span class="line">    y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// y为false时自旋</span></span><br><span class="line">    <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));<span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 若x为true，++z</span></span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))<span class="comment">// 4</span></span><br><span class="line">        ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="literal">false</span>;</span><br><span class="line">    y=<span class="literal">false</span>;</span><br><span class="line">    z=<span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>();</span><br><span class="line">    b.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用memory_order_relaxed模型，导致最后的断言有可能发生，即z可能为0。<br>此时的执行顺序为:<br>2(y = true), 3, 4(x = false), 1(x = true)</p>
<h4 id="Acquire-Release-模型示例代码"><a href="#Acquire-Release-模型示例代码" class="headerlink" title="Acquire-Release 模型示例代码"></a>Acquire-Release 模型示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::atomic&lt;std::string*&gt; ptr;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string* p  = <span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    data = <span class="number">42</span>;</span><br><span class="line">    ptr.<span class="built_in">store</span>(p, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string* p2;</span><br><span class="line">    <span class="keyword">while</span> (!(p2 = ptr.<span class="built_in">load</span>(std::memory_order_acquire)));<span class="comment">// 空指针会自旋</span></span><br><span class="line">    <span class="comment">// acquire操作，保证本线程中本次原子读正确，后续读写不许前置。</span></span><br><span class="line">    <span class="comment">// 与producer中对于ptr的原子release写操作对齐，可见release之前所有写操作</span></span><br><span class="line">    <span class="built_in">assert</span>(*p2 == <span class="string">&quot;Hello&quot;</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="built_in">assert</span>(data == <span class="number">42</span>); <span class="comment">// never fires</span></span><br><span class="line">    <span class="comment">// 此处由于本线程内acquire的约束，两次assert一定发生在ptr.load之后，而此时producer中ptr.store及其之前所有写操作对本线程可见，因此此处两个断言中表达式均为真，断言不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();<span class="comment">// 阻塞当前调用线程，等待两个线程执行结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Acquire-Release的传递示例代码"><a href="#Acquire-Release的传递示例代码" class="headerlink" title="Acquire-Release的传递示例代码"></a>Acquire-Release的传递示例代码</h4><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">std::atomic<T>::compare_exchange_weak, std::atomic<T>::compare_exchange_strong</T></T></a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">( T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::memory_order success,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::memory_order failure )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">( T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                              std::memory_order order = std::memory_order_seq_cst )</span></span></span><br><span class="line"><span class="function"><span class="comment">// compare_exchange_strong函数默认使用std::memory_order_seq_cst内存模型。</span></span></span><br></pre></td></tr></table></figure>
<p>将*this与expected进行比对:</p>
<ul>
<li>如果二者bitwise-equal (按位相等)，将*this替换为desired (read-modify-write operation)。</li>
<li>否则，将*this存储于expected中 (load operation)。</li>
</ul>
<p>The memory models for the read-modify-write and load operations are success and failure respectively.<br>success与failure分别是:</p>
<ul>
<li>比对成功时read-modify-write operation的内存模型</li>
<li>比对失败时load operation的内存模型</li>
</ul>
<p>order is used for both read-modify-write and load operations.<br>另一版本中两种操作都是用order作为内存模型，除非</p>
<ul>
<li>order == std::memory_order_acq_rel (读-修改-写)，那么load operation使用std::memory_order_acquire</li>
<li>order == std::memory_order_release (读-修改-写)，那么load operation使用std::memory_order_relaxed</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">    flag.<span class="built_in">store</span>(<span class="number">1</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> expected=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// memory_order_relaxed is okay because this is an RMW,</span></span><br><span class="line">    <span class="comment">// and RMWs (with any ordering) following a release form a release sequence</span></span><br><span class="line">    <span class="comment">// RMW：Read-Modify-Write，读-修改-写操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!flag.<span class="built_in">compare_exchange_strong</span>(expected, <span class="number">2</span>, std::memory_order_relaxed)) &#123;</span><br><span class="line">        expected = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (flag.<span class="built_in">load</span>(std::memory_order_acquire) &lt; <span class="number">2</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="comment">// if we read the value 2 from the atomic flag, we see 42 in the vector</span></span><br><span class="line">    <span class="built_in">assert</span>(data.<span class="built_in">at</span>(<span class="number">0</span>) == <span class="number">42</span>); <span class="comment">// will never fire</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</span><br><span class="line">    a.<span class="built_in">join</span>(); b.<span class="built_in">join</span>(); c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ByteDanceTech/article/details/120984767">深入理解一致性与 C++ 内存模型</a>中写道：</p>
<blockquote>
<p><strong>Release sequence</strong><br>对于一个变量 M，evaluation A 是作用在 M 的一个 release operation，那么在 A 之后由下面两种情况：</p>
<ul>
<li>同一线程内以任意 memory_order 执行的原子操作，</li>
<li>不同线程内 <strong>read-modify-write</strong> 类的所有原子操作，比如 fetch_add、cas 等</li>
</ul>
<p>构成的 modification order(包括 A) 称之为 以 A 为 head 的 release sequence。</p>
<p>比如对于 M，A 是一个 release operation，之后本线程内有 relaxed 的任意操作 B，其他线程有 <strong>read-modify-write</strong> 类操作如 fetch_add C、D，那么 A -&gt; {B、C、D } 是以 A 为 head 的 release sequence。由于 B、C、D 顺序不确定，所以这里放到了一个大括号内。具体为什么这么设计，可以参考 &lt;<C++ concurrency in action>&gt; 5.3.4 一节。</C++></p>
</blockquote>
<p>上面程序中，thread_2()中的compare_exchange_strong即包含read-modify-write operation，因此会与thread_1()中的flag.store(1, std::memory_order_release)，一个release operation，形成一个以flag.store(1, std::memory_order_release)为head的release sequence，使得compare_exchange_strong会在其后执行，并可见thread_1()中flag.store(1, std::memory_order_release)之前的所有写操作。</p>
<blockquote>
<p>对应程序中的注释:<br>RMWs (with any ordering) following a release form a release sequence.<br>这个following a release的release指的就是thread_1()中的flag.store(1, std::memory_order_release)</p>
</blockquote>
<h2 id="C-Order-of-evaluation-C-求值顺序"><a href="#C-Order-of-evaluation-C-求值顺序" class="headerlink" title="C++ Order of evaluation C++ 求值顺序"></a>C++ Order of evaluation C++ 求值顺序</h2><p>Order of evaluation of any part of any expression, including order of evaluation of function arguments is unspecified (with some exceptions listed below). The compiler can evaluate operands and other subexpressions in any order, and may choose another order when the same expression is evaluated again.<br>C++中表达式任意部份的求值顺序，包括函数的各个参数的求值顺序是不确定的（有一些例外）。编译器可以以任意顺序对表达式中的操作数和其他子表达式求值，对同一表达式进行两次求值可能会以不同的顺序进行。<br>There is no concept of left-to-right or right-to-left evaluation in C++. This is not to be confused with left-to-right and right-to-left associativity of operators: the expression a() + b() + c() is parsed as (a() + b()) + c() due to left-to-right associativity of operator +, but c() may be evaluated first, last, or between a() or b() at run time.<br>C++中没有从左至右或者从右至左求值的概念。不能将这个概念与操作符的左右结合性混淆。由于 + 运算符由左至右的结合性，a() + b() + c()会以(a() + b()) + c()的顺序计算，但其中a()、b()、c()三个子表达式哪个首先求值，这个顺序不确定。</p>
<h4 id="Sequenced-before-rules-since-C-11"><a href="#Sequenced-before-rules-since-C-11" class="headerlink" title="Sequenced-before rules (since C++11)"></a>Sequenced-before rules (since C++11)</h4><p><strong>Evaluation of Expressions 表达式的求值</strong><br>Evaluation of each expression includes:</p>
<ol>
<li><strong>value computations</strong>: calculation of the value that is returned by the expression. This may involve determination of the identity of the object (glvalue evaluation, e.g. if the expression returns a reference to some object) or reading the value previously assigned to an object (prvalue evaluation, e.g. if the expression returns a number, or some other value)<br>计算表达式的返回值。可能涉及到glvalue evaluation，确定返回值的类型，或prvalue evaluation，获取先前分配给对象的值。</li>
<li><strong>Initiation of side effects</strong>: access (read or write) to an object designated by a volatile glvalue, modification (writing) to an object, calling a library I/O function, or calling a function that does any of those operations.<br>side effects的开始。对volatile glvalue对象的访问，调用I/O库函数，或调用具有上述操作的其他函数。</li>
</ol>
<blockquote>
<p><strong>在C ++中，什么是左值lvalues，右值rvalues，x值xvalues，glvalue和prvalue？</strong></p>
<ul>
<li>左值 lvalues 具有程序可以访问的地址。左值表达式的示例包括变量名称，包括const变量，数组元素，返回左值引用的函数调用，位字段，并集和类成员。</li>
<li>将亡值 xvalue (expiring value) 表达式没有地址，表达式在执行完赋值任务后就会结束它的生命周期。可用于初始化右值引用，该引用提供对表达式的访问。示例包括返回右值引用的函数调用，数组下标等。</li>
<li>泛左值 glvalue (generalized left value) 是xvalues和左值lvalues的统称。</li>
<li>右值 rvalues，右值总有一个唯一的可读的值，其临时对象或子对象或与对象不相关的值。</li>
<li>纯右值 prvalue (pure right value)，即字面值，表达式没有程序可访问的地址。prvalue表达式的示例包括文字，返回非引用类型的函数调用。</li>
</ul>
</blockquote>
<h4 id="Sequenced-before"><a href="#Sequenced-before" class="headerlink" title="Sequenced-before"></a>Sequenced-before</h4><p>“sequenced-before” is an asymmetric, transitive, pair-wise relationship between evaluations within the same thread.<br>sequenced-before用于表示<strong>单线程</strong>之间，两个操作上的先后顺序，可以进行传递。<br>同一线程内，求值过程间的非对称、可传递、成对的关系。</p>
<ul>
<li>If A is sequenced before B, then evaluation of A will be complete before evaluation of B begins.<br>A的求值过程会在B的求值过程开始前完成。</li>
<li>If A is not sequenced before B and B is sequenced before A, then evaluation of B will be complete before evaluation of A begins.<br>反之B的求值过程会在A的求值过程开始前完成。</li>
<li>If A is not sequenced before B and B is not sequenced before A, then two possibilities exist:<br>若AB之前互相不具备sequenced before的关系，则有两种可能情况：<ul>
<li>evaluations of A and B are unsequenced: they may be performed in any order and may overlap (within a single thread of execution, the compiler may interleave the CPU instructions that comprise A and B)<br>二者为非排序关系，可以任意顺序进行，甚至重叠计算，乱序执行。</li>
<li>evaluations of A and B are indeterminately sequenced: they may be performed in any order but may not overlap: either A will be complete before B, or B will be complete before A. The order may be the opposite the next time the same expression is evaluated.<br>二者为不确定的顺序关系，可以按照任意顺序先后执行，但不可重叠。</li>
</ul>
</li>
</ul>
<p>两个操作A和操作B，如果有A sequenced-before B，除了表示<strong>操作A的顺序在B之前</strong>，还表示了<strong>操作A的结果操作B可见</strong>。因为A的求值过程已完成。</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>happens-before关系表示的<strong>不同线程之间</strong>的操作先后顺序，同样的也是非对称、可传递的关系。</p>
<p>如果A happens-before B，则A的内存状态将在B操作执行之前就可见。某些情况下一个写操作只是简单的写入Cache就返回了（没有真正的写入内存中），其他核心上的操作不一定能马上见到操作的结果，这样的关系是不满足happens-before的。</p>
<h4 id="synchronizes-with"><a href="#synchronizes-with" class="headerlink" title="synchronizes-with"></a>synchronizes-with</h4><p>synchronizes-with关系强调的是变量被修改之后的传播关系（propagate），即如果一个线程修改某变量的之后的结果能被其它线程可见，那么就是满足synchronizes-with关系的。</p>
<p>显然，满足synchronizes-with关系的操作一定满足happens-before关系了。</p>
<h4 id="Carries-dependency（具有依赖关系）"><a href="#Carries-dependency（具有依赖关系）" class="headerlink" title="Carries dependency（具有依赖关系）"></a>Carries dependency（具有依赖关系）</h4><p>Within the same thread, evaluation A that is sequenced-before evaluation B may also carry a dependency into B (that is, B depends on A), if any of the following is true</p>
<ol>
<li>The value of A is used as an operand of B, except  <strong>A是B的操作数</strong><br>a) if B is a call to std::kill_dependency<br>b) if A is the left operand of the built-in <strong>&amp;&amp;</strong>, <strong>||</strong>, <strong>?:</strong>, or <strong>,</strong> operators. (left operand，左操作数，左值。在这三个运算符中，A、B为并列关系，其值不会互相影响，因此不存在依赖关系。如A ? B : 2<em>B，在此运算中A的取值只影响运算的返回值，而不会影响B的值。**为什么+-\</em>/之类的运算符没有这种性质？？逗号我能理解，前两个因为C++短路求值？三目运算符呢？是因为相当于一个if再加一个赋值号=？先求条件表达式的值，之后再决定求后面哪个表达式的值，未必一定执行到，与短路求值相似所以没有依赖关系吗？**)</li>
<li>A writes to a scalar object M, B reads from M  <strong>A写入对象M中，而B从M中读取数据</strong></li>
<li>A carries dependency into another evaluation X, and X carries dependency into B  <strong>X依赖于A，而B依赖于X，依赖关系的传递</strong></li>
</ol>
<h4 id="Modification-order"><a href="#Modification-order" class="headerlink" title="Modification order"></a>Modification order</h4><p>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.<br>针对任意特定原子变量的所有修改都将以一个指定到该原子变量的全局顺序进行。<br>The following four requirements are guaranteed for all atomic operations:<br>所有原子操作都遵循以下四个条件：<br>1) <strong>Write-write coherence 写-写一致性</strong>: If evaluation A that modifies some atomic M (a write) happens-before evaluation B that modifies M, then A appears earlier than B in the modification order of M<br>2) <strong>Read-read coherence</strong>: if a value computation A of some atomic M (a read) happens-before a value computation B on M, and if the value of A comes from a write X on M, then the value of B is either the value stored by X, or the value stored by a side effect Y on M that appears later than X in the modification order of M.<br>3) <strong>Read-write coherence</strong>: if a value computation A of some atomic M (a read) happens-before an operation B on M (a write), then the value of A comes from a side-effect (a write) X that appears earlier than B in the modification order of M<br>4) <strong>Write-read coherence</strong>: if a side effect (a write) X on an atomic object M happens-before a value computation (a read) B of M, then the evaluation B shall take its value from X or from a side effect Y that follows X in the modification order of M</p>
<h2 id="B-25-Asynchronous-Barrier"><a href="#B-25-Asynchronous-Barrier" class="headerlink" title="B.25. Asynchronous Barrier"></a>B.25. Asynchronous Barrier</h2><p>std::barrier的GPU实现，允许用户指定barrier对象的范围。</p>
<p>Devices of compute capability 8.0 or higher provide <strong>hardware acceleration</strong> for barrier operations and integration of these barriers with the <strong>memcpy_async</strong> feature.<br>CC 8.0及以上的设备对barrier拥有硬件加速，且集成了memcpy_async的特性（用于异步拷贝的同步）。</p>
<p> On devices with compute capability below 8.0 but starting 7.0, these barriers are available without hardware acceleration.<br> 介于CC 7.0与8.0之间的设备具有barrier指令，但没有硬件加速。</p>
<h3 id="B-25-1-Simple-Synchronization-Pattern-简单同步模式"><a href="#B-25-1-Simple-Synchronization-Pattern-简单同步模式" class="headerlink" title="B.25.1. Simple Synchronization Pattern 简单同步模式"></a>B.25.1. Simple Synchronization Pattern 简单同步模式</h3><p> Without the arrive/wait barrier, synchronization is achieved using __syncthreads() (to synchronize all threads in a block) or group.sync() when using Cooperative Groups.</p>
<p>不使用barrier时，GPU拥有两种同步方式：</p>
<ol>
<li>__syncthreads()：同步一个block中的所有threads。</li>
<li>group.sync()：同步整个Cooperative Groups。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">simple_sync</span><span class="params">(<span class="type">int</span> iteration_count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iteration_count; ++i) &#123;</span><br><span class="line">        <span class="comment">/* code before arrive */</span></span><br><span class="line">        block.<span class="built_in">sync</span>(); <span class="comment">/* wait for all threads to arrive here */</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Cooperative Groups进行block级别同步的例子。<br>In addition, memory updates that happened before the synchronization point are guaranteed to be visible to all threads in the block after the synchronization point, i.e., equivalent to atomic_thread_fence(memory_order_seq_cst, thread_scope_block) as well as the sync.<br>除此之外，还隐含了memory fence的作用，在同步点前发生的内存修改操作，对同步点之后的所有线程均可见。这个特性__syncthreads()与group.sync()都有。保证了线程内存独写的先后顺序。</p>
<blockquote>
<p><strong>这种模式有三个阶段：</strong></p>
<ol>
<li>sync之前的内存更新操作，在sync之后可读</li>
<li>同步点Synchronization point</li>
<li>sync之后的代码，拥有对sync之前发生的内存更新操作的可见性</li>
</ol>
</blockquote>
<p>一个同步 + 一个Memory Fence</p>
<h3 id="B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-时间分割同步-与-同步的五个阶段"><a href="#B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-时间分割同步-与-同步的五个阶段" class="headerlink" title="B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段"></a>B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段</h3><p>The temporally-split synchronization pattern with the std::barrier is as follows.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">compute</span><span class="params">(<span class="type">float</span>* data, <span class="type">int</span> curr_iteration)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">split_arrive_wait</span><span class="params">(<span class="type">int</span> iteration_count, <span class="type">float</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> barrier = cuda::barrier&lt;cuda::thread_scope_block&gt;;</span><br><span class="line">    <span class="comment">// C++11引入，相当于typedef，定义类型别名</span></span><br><span class="line">    <span class="comment">// cuda::barrier&lt;cuda::thread_scope_block&gt;;作用范围为block级别的cuda::barrier类型</span></span><br><span class="line"></span><br><span class="line">    __shared__  barrier bar;</span><br><span class="line">    <span class="comment">// 放在shared mem中的cuda::barrier，作用于整个block</span></span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line">    <span class="comment">// 一个Cooperative Groups，定义范围为整个block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// block.thread_rank()，Cooperative Groups专用，返回线程的组内索引号</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用0号线程初始化存储于shared mem中的cuda::barrier</span></span><br><span class="line">        <span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Initialize the barrier with expected arrival count</span></span><br><span class="line">        <span class="comment">// expected arrival count这里为block size</span></span><br><span class="line">    &#125;</span><br><span class="line">    block.<span class="built_in">sync</span>();<span class="comment">// Cooperative Groups同步，其他线程等待0号线程初始化cuda::barrier结束，并在同步点之后对shared mem中的cuda::barrier拥有可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> curr_iter = <span class="number">0</span>; curr_iter &lt; iteration_count; ++curr_iter) &#123;</span><br><span class="line">        <span class="comment">/* code before arrive */</span></span><br><span class="line">       barrier::arrival_token token = bar.<span class="built_in">arrive</span>(); <span class="comment">/* this thread arrives. Arrival does not block a thread */</span></span><br><span class="line">       <span class="comment">// 先执行完的线程先开始其他工作，做完之后再bar.wait()等待其他线程到达bar.arrive()，从而减少每个线程等待的时间</span></span><br><span class="line">       <span class="built_in">compute</span>(data, curr_iter);</span><br><span class="line">       bar.<span class="built_in">wait</span>(std::<span class="built_in">move</span>(token)); <span class="comment">/* wait for all threads participating in the barrier to complete bar.arrive()*/</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>
<p>In this pattern, the synchronization point (<strong>block.sync()</strong>) is split into an arrive point (<strong>bar.arrive()</strong>) and a wait point (<strong>bar.wait(std::move(token))</strong>). A thread begins participating in a <strong>cuda::barrier</strong> with its first call to <strong>bar.arrive()</strong>.<br>此模式下原来的一个同步点block.sync()被分割为了一个到达点bar.arrive()与一个等待点bar.wait(std::move(token))。当一个线程首次执行到bar.arrive()时，视为其开始参与到cuda::barrier中。</p>
<p>When a thread calls bar.wait(std::move(token)) it will be blocked until participating threads have completed bar.arrive() the expected number of times as specified by the expected arrival count argument passed to init().<br>当一个线程执行到bar.wait(std::move(token))，此线程将被blocked，直到参与到cuda::barrier中的线程执行了期望次数的bar.arrive()。这个期望次数在一开始使用init()函数初始化cuda::barrier时指定。<br>比如示例代码中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Initialize the barrier with expected arrival count</span></span><br></pre></td></tr></table></figure><br>为使用block size初始化cuda::barrier，等于对block中所有线程的同步操作。</p>
<p><strong>Memory updates that happen before participating threads’ call to bar.arrive() are guaranteed to be visible to participating threads after their call to bar.wait(std::move(token)).</strong><br>这种方式也有memory fence的功能，区别是发生在bar.arrive()之前的内存修改将会对bar.wait()之后的代码可见。</p>
<p>Note that the call to bar.arrive() does not block a thread, it can proceed with other work that does not depend upon memory updates that happen before other participating threads’ call to bar.arrive().<br>bar.arrive()并不会阻塞一个线程继续执行，只有bar.wait()会，因此在线程到达bar.arrive()后，可以在等待其他线程到达bar.arrive()之前，继续执行一些不含访问由其他参与线程到达bar.arrive()之前修改的内存的工作。</p>
<blockquote>
<p><strong>这种arrive之后wait的模式有五个阶段：</strong></p>
<ol>
<li>arrive之前的内存更新操作，在wait之后可读</li>
<li>arrive点有隐式的memory fence，等价于<br><strong>atomic_thread_fence(memory_order_seq_cst, thread_scope_block)</strong></li>
<li>arrive与wait之间的代码，一些不依赖arrive之前会更新的内存数据的工作。</li>
<li>wait point等待点，等待arrive的数量满足要求。</li>
<li>wait之后的代码，拥有对arrive之前发生的内存更新操作的可见性</li>
</ol>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/22/cuda-5/" rel="prev" title="CUDA学习随记5 Asynchronous copy cp.async">
      <i class="fa fa-chevron-left"></i> CUDA学习随记5 Asynchronous copy cp.async
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/25/GAMES101-RayTracing-1/" rel="next" title="GAMES101 RayTracing Part 1">
      GAMES101 RayTracing Part 1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B06-std-memory-order-amp-B-25-Asynchronous-Barrier"><span class="nav-number">1.</span> <span class="nav-text">CUDA学习随记6  std::memory_order &amp; B.25. Asynchronous Barrier</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#std-memory-order-C-11"><span class="nav-number">1.1.</span> <span class="nav-text">std::memory_order (C++11)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-relaxed"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">memory_order_relaxed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-release"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">memory_order_release</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-acquire"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">memory_order_acquire</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-consume"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">memory_order_consume</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-acq-rel"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">memory_order_acq_rel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-seq-cst"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">memory_order_seq_cst</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-seq-cst-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.0.7.</span> <span class="nav-text">memory_order_seq_cst 顺序一致性模型示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memory-order-relaxed-%E6%9D%BE%E6%95%A3%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.0.8.</span> <span class="nav-text">memory_order_relaxed 松散内存模型示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Acquire-Release-%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.0.9.</span> <span class="nav-text">Acquire-Release 模型示例代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Acquire-Release%E7%9A%84%E4%BC%A0%E9%80%92%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.0.10.</span> <span class="nav-text">Acquire-Release的传递示例代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-Order-of-evaluation-C-%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text">C++ Order of evaluation C++ 求值顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sequenced-before-rules-since-C-11"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">Sequenced-before rules (since C++11)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sequenced-before"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">Sequenced-before</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#happens-before"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">happens-before</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronizes-with"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">synchronizes-with</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Carries-dependency%EF%BC%88%E5%85%B7%E6%9C%89%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%EF%BC%89"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">Carries dependency（具有依赖关系）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Modification-order"><span class="nav-number">1.2.0.6.</span> <span class="nav-text">Modification order</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-25-Asynchronous-Barrier"><span class="nav-number">1.3.</span> <span class="nav-text">B.25. Asynchronous Barrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-1-Simple-Synchronization-Pattern-%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.1.</span> <span class="nav-text">B.25.1. Simple Synchronization Pattern 简单同步模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-%E6%97%B6%E9%97%B4%E5%88%86%E5%89%B2%E5%90%8C%E6%AD%A5-%E4%B8%8E-%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">1.3.2.</span> <span class="nav-text">B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiang Shao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiang Shao</p>
  <div class="site-description" itemprop="description">WeChat: shaojiang9650<br>Email: shao_study@163.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Shao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
