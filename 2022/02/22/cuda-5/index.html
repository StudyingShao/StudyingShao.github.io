<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CUDA 11新特性，Ampere架构支持，Asynchronous copy异步数据拷贝">
<meta property="og:type" content="article">
<meta property="og:title" content="CUDA学习随记5 Asynchronous copy cp.async">
<meta property="og:url" content="http://example.com/2022/02/22/cuda-5/index.html">
<meta property="og:site_name" content="邵大宝的学习Blog">
<meta property="og:description" content="CUDA 11新特性，Ampere架构支持，Asynchronous copy异步数据拷贝">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/02/22/cuda-5/LDGSTS%20access%20and%20bypass.png">
<meta property="article:published_time" content="2022-02-22T13:51:12.000Z">
<meta property="article:modified_time" content="2022-06-28T14:18:33.319Z">
<meta property="article:author" content="Jiang Shao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/02/22/cuda-5/LDGSTS%20access%20and%20bypass.png">

<link rel="canonical" href="http://example.com/2022/02/22/cuda-5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CUDA学习随记5 Asynchronous copy cp.async | 邵大宝的学习Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">邵大宝的学习Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">最爱严小跳</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/22/cuda-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CUDA学习随记5 Asynchronous copy cp.async
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-22 21:51:12" itemprop="dateCreated datePublished" datetime="2022-02-22T21:51:12+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-28 22:18:33" itemprop="dateModified" datetime="2022-06-28T22:18:33+08:00">2022-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          
            <div class="post-description">CUDA 11新特性，Ampere架构支持，Asynchronous copy异步数据拷贝</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CUDA学习随记5-Asynchronous-copy-cp-async"><a href="#CUDA学习随记5-Asynchronous-copy-cp-async" class="headerlink" title="CUDA学习随记5 Asynchronous copy cp.async"></a>CUDA学习随记5 Asynchronous copy cp.async</h1><p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-asynchronous-copy">1. PTX (Parallel Thread Execution) ISA (Instruction Set Architecture)</a><br><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html">2. CUDA Binary Utilities (用于查询SASS code)</a></p>
<p>An asynchronous copy operation copies data from one state space to another asynchronously <strong>without blocking the executing thread</strong>.<br>Initiation of an asynchronous copy operation simply dispatches the copy operation from the source memory location to the destination memory location.<br>异步拷贝，不阻塞线程，仅发起一个异步拷贝请求。</p>
<p>There are two ways to wait for the completion of an asynchronous copy operation:<br>两种方式等待异步拷贝操作完成：</p>
<ol>
<li>使用<strong>cp.async-groups</strong><br>a. Initiate asynchronous copy operations.<br>b. Commit copy operations into a cp.async-group. <strong>Using cp.async.commit_group</strong><br>c. Wait for cp.async-group to complete the copy. <strong>Using cp.async.wait_group</strong><br>d. Once the cp.async-group completes, the writes performed by the copy operation in that cp.async-group are made <strong>visible to the thread that initiated the copy operations</strong>.</li>
<li>使用<strong>mbarrier</strong>对象<br>a. Initiate asynchronous copy operations.<br>b. Make an mbarrier object track the asynchronous copy operations.<br>c. Wait for the mbarrier object to complete the phase阶段 using mbarrier.test_wait.<br>d. Once mbarrier.test_wait returns True, the writes performed by the copy operation are made <strong>visible to all the threads which waited on the mbarrier object</strong>.</li>
</ol>
<p>A sequence of asynchronous copy operations initiated by a thread can be batched into a <strong>per-thread group</strong> referred to as cp.async-group.<br>由单个线程发出的一系列异步拷贝操作可以打包为a per-thread group，称为cp.async-group。</p>
<p>A commit operation creates <strong>a cp.async-group containing all prior asynchronous copy operations initiated by the executing thread</strong> but none of the asynchronous copy operations following the commit operation. A committed asynchronous copy operation belongs to a single cp.async-group.<br>创建一个cp.async-group将包含所有由本线程发出的之前的异步拷贝操作，不包括之后的。每个异步拷贝操作仅属于一个cp.async-group。<br>由于执行到cp.async-group时，其之前的所有异步拷贝操作均已被对应cp.async-group收录，因此下一个cp.async-group仅包含两条cp.async-group之间的新发出的异步拷贝操作，所以说每个异步拷贝操作仅属于一个cp.async-group。</p>
<p>When a cp.async-group completes, all the asynchronous copy operations belonging in that group are complete and the executing thread that initiated copy operations can read copied results. All cp.async-groups committed by an executing thread always complete in the order in which they were committed. There is no ordering between asynchronous copy operations within a cp.async-group.<br>当cp.async-group完成时，其所包含的所有异步拷贝操作均已完成，发出异步拷贝请求的线程（也就是当前线程）可以安全读取拷贝结果。线程发射的cp.async-groups永远按照顺序完成，而cp.async-group中包含的异步拷贝操作的执行顺序是随机的。</p>
<p>Writes performed by an asynchronous copy operation are visible to the thread that initiated the asynchronous copy operation only after the cp.async-group completes or mbarrier object tracking the asynchronous copy has completed the phase.<br>仅当cp.async-group完成 or mbarrier追踪到异步拷贝完成，当前线程才能安全读取由当前线程发出的异步拷贝操作写入的数据（数据可见）。</p>
<p>Once an asynchronous copy operation is initaited, modifiying the source memory location or reading from the destination memory location before the asynchronous copy operation completes, will cause unpredictable results.<br>一旦一个异步拷贝操作被发起，不等待异步拷贝操作完成就 修改源内存地址中的数据 or 就读取目标内存地址中的数据，将会产生unpredictable results。</p>
<h4 id="cp-async"><a href="#cp-async" class="headerlink" title="cp.async"></a>cp.async</h4><p>Initiates an asynchronous copy operation from one state space to another.<br>发起一个异步拷贝操作。<br>Operand src specifies a location in the global state space and dst specifies a location in the shared state space.<br>异步拷贝只能是从global mem拷贝到shared mem。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cp.async.ca.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], cp-size&#123;, src-size&#125;&#123;, cache-policy&#125; ;</span><br><span class="line">cp.async.cg.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], <span class="number">16</span>&#123;, src-size&#125;&#123;, cache-policy&#125; ;</span><br><span class="line">cp.async.ca.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], cp-size&#123;, ignore-src&#125;&#123;, cache-policy&#125; ;</span><br><span class="line">cp.async.cg.shared.global&#123;.level::cache_hint&#125;&#123;.level::prefetch_size&#125;</span><br><span class="line">                         [dst], [src], <span class="number">16</span>&#123;, ignore-src&#125;&#123;, cache-policy&#125; ;</span><br></pre></td></tr></table></figure><br>The <strong>.cg</strong> qualifier indicates caching of data only at global level cache L2 and not at L1 whereas <strong>.ca</strong> qualifier indicates caching of data at all levels including L1 cache. Cache operator are treated as performance hints only.<br><strong>.cg</strong>表示仅用L2 cache，数据传输绕过L1 cache与register。对应LDGSTS.BYPASS。<br><strong>.ca</strong>表示同时使用L1 cache与L2 cache，数据传输仅绕过register。对应LDGSTS.ACCESS。<br>这俩标识符只是对编译器的建议，具体用不用要看编译器的意思。实际上具体使用哪种取决于传输数据的大小与对齐方式。4 Bytes-&gt;access，16 Bytes-&gt;bypass。</p>
<p>Operand cp-size is an integer constant which specifies the size of data in bytes to be copied to the destination dst. cp-size can only be 4, 8 and 16.<br>cp-size指定了传输数据的大小（in bytes），可以是4、8、16，可以看到cp-size最小是4，而.cg指令cp-size直接指定为16，正好符合上面的说法。</p>
<center><img src="/2022/02/22/cuda-5/LDGSTS%20access%20and%20bypass.png" width="100%" height="100%"><font color="#708090" size="2">Two types of LDGSTS: access and bypass.</font></center>

<p>Instruction cp.async allows optionally specifying a 32-bit integer operand <strong>src-size</strong>. Operand src-size represents the size of the data in bytes to be copied from src to dst and must be less than <strong>cp-size</strong>. In such case, remaining bytes in destination dst are filled with zeros. Specifying src-size larger than cp-size results in undefined behavior.<br>src-size，指定拷贝源数据大小，必须比cp-size小，否则undefined behavior。很简答，如果比cp-size大，则拷贝数据不完整，再读取肯定不对。cp-size比src-size多出来的部份在dst中会被填充0。</p>
<p>The optional and non-immediate predicate argument <strong>ignore-src</strong> specifies whether the data from the source location src should be ignored completely. If the source data is ignored then zeros will be copied to destination dst. If the argument ignore-src is not specified then it defaults to False.<br>指定是否忽略scr中的数据，如果置为true，则向dst中拷贝0。默认为false。</p>
<p>The mandatory(强制的) <strong>.async</strong> qualifier indicates that the cp instruction will <strong>initiate the memory copy operation asynchronously</strong> and <strong>control will return to the executing thread before the copy operation is complete</strong>. The executing thread can then use <strong>cp.async.wait_all</strong> or <strong>cp.async.wait_group</strong> or <strong>mbarrier instructions</strong> to wait for completion of the asynchronous copy operation. No other synchronization mechanisms described in Memory Consistency Model can be used to guarantee the completion of the asynchronous copy operations.<br>三种用来同步异步数据传输操作的方法：<br><strong>cp.async.wait_all</strong> or <strong>cp.async.wait_group</strong> or <strong>mbarrier instructions</strong></p>
<p>There is no ordering guarantee between two cp.async operations if they are not explicitly synchronized using cp.async.wait_all or cp.async.wait_group or mbarrier instructions.<br>如果没有显式同步，两个cp.async之间没有顺序保证。</p>
<p>The <strong>.level::prefetch_size</strong> qualifier is a hint to <strong>fetch additional data of the specified size into the respective cache level</strong>.The sub-qualifier prefetch_size can be set to either of 64B, 128B, 256B thereby allowing the prefetch size to be 64 Bytes, 128 Bytes or 256 Bytes respectively.</p>
<p>The qualifier .level::prefetch_size may only be used with .global state space and with generic addressing where the address points to .global state space. If the generic address does not fall within the address window of the global memory, then the prefetching behavior is undefined.</p>
<p>The .level::prefetch_size qualifier is treated as a performance hint only.</p>
<p>When the optional argument <strong>cache-policy</strong> is specified, the qualifier <strong>.level::cache_hint</strong> is required. The 64-bit operand cache-policy specifies <strong>the cache eviction policy</strong> that may be used during the memory access.</p>
<p>The qualifier .level::cache_hint is only supported for .global state space and for generic addressing where the address points to the .global state space.</p>
<p>cache-policy is a hint to the cache subsystem and may not always be respected. It is treated as a performance hint only, and does not change the memory consistency behavior of the program.</p>
<p>.level::prefetch_size与.level::cache_hint都是与缓存相关的qualifier。都是hints to the compiler，并不一定被编译器所采纳。由于是缓存相关的，所以操作对象地址必须在global memory中，否则会导致undefined behavior.<br>.level::prefetch_size用于在缓存中除了要拷贝的数据之外，额外fetch一定大小的数据到对应cache中，用于增加缓存命中率，减少从device memory中读取数据的次数。<br>.level::cache_hint用于cache-policy指定时，用于指定缓存清除策略，如何使用缓存。</p>
<h4 id="cp-async-commit-group"><a href="#cp-async-commit-group" class="headerlink" title="cp.async.commit_group"></a>cp.async.commit_group</h4><p>Commits all prior initiated but uncommitted cp.async instructions into a cp.async-group.<br>将之前的未被commit的cp.async commit到一个cp.async-group。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp.async.commit_group;</span><br></pre></td></tr></table></figure>
<p>这条PTX code所产生的SASS code就是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDGDEPBAR <span class="comment">//Global Load Dependency Barrier</span></span><br></pre></td></tr></table></figure><br>会导致一个很大的stall long scoreboard。</p>
<p><strong>cp.async.commit_group</strong> instruction creates a new cp.async-group <strong>per thread</strong> and batches all prior cp.async instructions <strong>initiated by the executing thread but not committed to any cp.async-group</strong> into the new cp.async-group. If there are no uncommitted cp.async instructions then cp.async.commit_group results in an empty cp.async-group.</p>
<p>An executing thread can wait for the completion of all cp.async operations in a cp.async-group using cp.async.wait_group.</p>
<p>There is no memory ordering guarantee provided between any two cp.async operations within the same cp.async-group. So two or more cp.async operations within a cp.async-group copying data to the same location results in undefined behavior.<br>在同一个cp.async-group中的cp.async没有顺序保证，因此在同一cp.async-group中对同一地址的cp.async会导致undefined behavior。</p>
<h4 id="cp-async-wait-group-cp-async-wait-all"><a href="#cp-async-wait-group-cp-async-wait-all" class="headerlink" title="cp.async.wait_group/cp.async.wait_all"></a>cp.async.wait_group/cp.async.wait_all</h4><p>Wait for completion of prior asynchronous copy operations.<br>等待先前的异步拷贝操作完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp.async.wait_group N;</span><br><span class="line">cp.async.wait_all;</span><br></pre></td></tr></table></figure>
<p><strong>cp.async.wait_group</strong> instruction will cause executing thread to wait till <strong>only N or fewer of the most recent cp.async-groups are pending</strong> and <strong>all the prior cp.async-groups committed by the executing threads are complete</strong>. For example, when N is 0, the executing thread waits on all the prior cp.async-groups to complete. Operand N is an integer constant.</p>
<p>cp.async.wait_group N; 等待execution thread直到还剩 N 个或更少个<strong>最近的</strong>cp.async-group还在进行中、未完成。由于cp.async-group按照被commit的顺序依次完成，因此先发出的必先完成，等待指令等待后发出的cp.async-group。</p>
<p>cp.async.wait_all; 等待execution thread先前的所有cp.async都完成。也就是等价于commit一个cp.async-group然后马上等待所有先前的cp.async-group完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp.async.commit_group; <span class="comment">//将仍未被commit的cp.async commit到一个cp.async-group中</span></span><br><span class="line">cp.async.wait_group <span class="number">0</span>; <span class="comment">//等待所有先前的cp.async-group完成</span></span><br></pre></td></tr></table></figure></p>
<p>如果N为0，那么这条PTX code所产生的SASS code就是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEPBAR.LE SB0, <span class="number">0x0</span> ;<span class="comment">//等待直到SB0的计数降至0</span></span><br></pre></td></tr></table></figure><br>DEPBAR的作用是等待，直到某一Scoreboard的计数小于特定值。（比如DEPBAR.LE SB5, 0x6 ;表示stall直至第5个Scoreboard的值降到6或以下）</p>
<p>SB指的就是scoreboard。记录cp.async-group的数量（一个counter）与每个cp.async-group所对应的cp.async (LDGSTS)的数量。每次一个cp.async-group完成，counter - 1。counter的数量刚好对应N的值。<br>N 指明线程等待直到只有 N 或更少个cp.async-group未完成才继续。如果是0，那么就是等待只有0个未完成，代表等待所有的cp.async-group完成。由于cp.async-group是保持发射顺序的，因此N等待的永远是倒数的N个cp.async-group，就是最近发射的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of .wait_all:</span></span><br><span class="line">cp.async.ca.shared.global [shrd1], [gbl1], <span class="number">4</span>;</span><br><span class="line">cp.async.cg.shared.global [shrd2], [gbl2], <span class="number">16</span>;</span><br><span class="line">cp.async.wait_all;  <span class="comment">// waits for all prior cp.async to complete</span></span><br></pre></td></tr></table></figure>
<p>cp.async.wait_all等待前面所有的cp.async完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of .wait_group :</span></span><br><span class="line">cp.async.ca.shared.global [shrd3], [gbl3], <span class="number">8</span>;</span><br><span class="line">cp.async.commit_group;  <span class="comment">// End of group 1</span></span><br><span class="line"></span><br><span class="line">cp.async.cg.shared.global [shrd4], [gbl4], <span class="number">16</span>;</span><br><span class="line">cp.async.commit_group;  <span class="comment">// End of group 2</span></span><br><span class="line"></span><br><span class="line">cp.async.cg.shared.global [shrd5], [gbl5], <span class="number">16</span>;</span><br><span class="line">cp.async.commit_group;  <span class="comment">// End of group 3</span></span><br><span class="line"></span><br><span class="line">cp.async.wait_group <span class="number">1</span>;  <span class="comment">// waits for group 1 and group 2 to complete</span></span><br></pre></td></tr></table></figure>
<p>cp.async.wait_group 1 允许有一个cp.async-group未完成，按照顺序，此条指令等待group 1 and 2完成。</p>
<p>Writes performed by cp.async operations are made <strong>visible to the executing thread</strong> only after :</p>
<ol>
<li>The completion of cp.async.wait_all or</li>
<li>The completion of cp.async.wait_group on the cp.async-group in which the cp.async belongs to or</li>
<li>mbarrier.test_wait returns True on an mbarrier object which is tracking the completion of the cp.async operation.<br>三种情况下，由cp.async写入的数据对当前线程可见。cp.async.wait_all完成了，代表此处之前所有的cp.async都已完成。cp.async所在的cp.async-group完成了，使用cp.async.wait_group实现。追踪此cp.async的mbarrier的mbarrier.test_wait返回true。</li>
</ol>
<p>There is no ordering between two cp.async operations that are not synchronized with cp.async.wait_all or cp.async.wait_group or mbarrier objects.</p>
<p><strong>cp.async.wait_group and cp.async.wait_all does not provide any ordering and visibility guarantees for any other memory operation apart from cp.async.</strong><br>cp.async.wait_group and cp.async.wait_all仅影响cp.async的顺序，其他内存操作与此无关。很容易看出嘛。前缀都是cp.async.*，明显就是这个专用的。这里没说mbarrier，说明这玩应是对所有内存操作都有效的，是同步障碍。</p>
<h3 id="与Julien-Demouth-60-x6a-100-x65-x6d-111-x75-x74-x68-x40-110-x76-105-100-105-97-46-x63-x6f-x6d-gt-的邮件往来"><a href="#与Julien-Demouth-60-x6a-100-x65-x6d-111-x75-x74-x68-x40-110-x76-105-100-105-97-46-x63-x6f-x6d-gt-的邮件往来" class="headerlink" title="与Julien Demouth &#60;&#x6a;&#100;&#x65;&#x6d;&#111;&#x75;&#x74;&#x68;&#x40;&#110;&#x76;&#105;&#100;&#105;&#97;&#46;&#x63;&#x6f;&#x6d;&gt;的邮件往来"></a>与Julien Demouth <a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#60;&#x6a;&#100;&#x65;&#x6d;&#111;&#x75;&#x74;&#x68;&#x40;&#110;&#x76;&#105;&#100;&#105;&#97;&#46;&#x63;&#x6f;&#x6d;">&#60;&#x6a;&#100;&#x65;&#x6d;&#111;&#x75;&#x74;&#x68;&#x40;&#110;&#x76;&#105;&#100;&#105;&#97;&#46;&#x63;&#x6f;&#x6d;</a>&gt;的邮件往来</h3><h4 id="我愚蠢的问题"><a href="#我愚蠢的问题" class="headerlink" title="我愚蠢的问题"></a>我愚蠢的问题</h4><p>Hi Julien<br>Sorry to bother you. I am an intern in devtech team. I have seen your email about LDGDEPBAR with LDGSTS.  I have a question about it.<br>Can LDGSTS bands to a certain gmem barrier？For example, I want to do a prefetch on smem. In a for cycle, can i issue a set of LDGSTS for variable A and LDS variable B.  Then i sync LDGSTS for A. next loop i issue a set of LDGSTS for B and then LDS A. THEN I sync LDGSTS for B. then run this two loop many times.<br>is this possible by using inlinePTX？<br>I will really appreciate if you can answer my question.<br>thanks a lot. </p>
<blockquote>
<p>这里我想做一个SMEM的prefetch，在当前循环步使用LDGSTS从GMEM中预先异步读取下一个循环步要使用到的数据到SMEM。而当前循环步使用LDS从SMEM中读取上一循环预读的数据。</p>
</blockquote>
<h4 id="大佬的回答"><a href="#大佬的回答" class="headerlink" title="大佬的回答"></a>大佬的回答</h4><p>Hi Jiang,</p>
<p>You are not bothering me 😊. I hope you enjoy your internship with NVIDIA and the Devtech team.</p>
<p>Say you have two LDGSTS for A and two LDGSTS for B and you want to alternate between both:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  LDGSTS A0 <span class="comment">// write to shared memory</span></span><br><span class="line"><span class="number">2</span>  LDGSTS A1 <span class="comment">// write to shared memory – you have to make sure that’s a different region from A0</span></span><br><span class="line"><span class="number">3</span>  LDGDEPBAR </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span>  LDS B0 <span class="comment">// load from shared memory – that buffer must have been filled earlier</span></span><br><span class="line"><span class="number">6</span>  LDS B1</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span>  DEPBAR <span class="number">0</span> <span class="comment">// make sure the instructions before the LAST LDGDEPBAR have completed =&gt; A0/A1 are in shared memory</span></span><br><span class="line"><span class="number">9</span>  BAR.SYNC <span class="comment">// __syncthreads</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> LDGSTS B2 <span class="comment">// trigger the next LDGSTS for B – you can reuse the same memory buffer than the one for B0</span></span><br><span class="line"><span class="number">12</span> LDGSTS B3</span><br><span class="line"><span class="number">13</span> LDGDEPBAR </span><br><span class="line"><span class="number">14</span>  </span><br><span class="line"><span class="number">15</span> LDS A0 </span><br><span class="line"><span class="number">16</span> LDS A1</span><br><span class="line"><span class="number">17</span> </span><br><span class="line"><span class="number">18</span> DEPBAR <span class="number">0</span> </span><br><span class="line"><span class="number">19</span> BAR.SYNC <span class="comment">// __syncthreads</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>&emsp;&emsp;解读一下这段代码，Line 2 特意告知我 “you have to make sure that’s a different region from A0” 是由于同一个 cp.async_group 中的 cp.saync 操作的先后顺序是没有保证的，因此对同一地址的拷贝会导致未定义的结果。<br>&emsp;&emsp;Line 3 是cp.async.commit_group，创建一个cp.async_group将前两个LDGSTS包含在内。到此为止的三行发起了从GMEM到SMEM的异步拷贝操作，并将其归纳到了同一个cp.async_group。<br>&emsp;&emsp;Line 5 &amp; 6 使用LDS从SMEM中读取上一循环中准备好的数据。<br>&emsp;&emsp;Line 8 为cp.async.wait_group 0; 等待直到还剩下0个cp.async_group未完成，也就是等待所有cp.async_group完成。这里为确保A0、A1数据准备就绪。<br>&emsp;&emsp;BAR.SYNC 为__syncthreads()，同步block内所有线程。（从SMEM中读取数据必须保证同步，保证所有线程都已经读取完毕）<br>&emsp;&emsp;后续操作重复这一过程，区别是交换了预读使用的与当前读取的SMEM buffer。即为上一循环预读数据存入A0、A1，使用B0、B1已经读好的数据。下一循环预读数据存入B0、B1，使用A0、A1已经读好的数据。以此达到隐藏访存延迟的效果。</p>
</blockquote>
<p>This code does the trick. </p>
<p>That said if you have enough shared memory you can do smarter things:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  LDGSTS A0</span><br><span class="line"><span class="number">2</span>  LDGSTS A1</span><br><span class="line"><span class="number">3</span>  LDGDEPBAR </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span>  LDGSTS B2 <span class="comment">// It must write to a different buffer in shared memory than the one used for B0/B1</span></span><br><span class="line"><span class="number">6</span>  LDGSTS B3</span><br><span class="line"><span class="number">7</span>  LDGDEPBAR </span><br><span class="line"><span class="number">8</span> </span><br><span class="line"><span class="number">9</span>  LDS B0</span><br><span class="line"><span class="number">10</span> LDS B1</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> DEPBAR <span class="number">1</span> <span class="comment">// The LDGSTS B2/B3 can still be in flight</span></span><br><span class="line"><span class="number">13</span> BAR.SYNC <span class="comment">// __syncthreads</span></span><br><span class="line"><span class="number">14</span> </span><br><span class="line"><span class="number">15</span> LDGSTS A2 <span class="comment">// It must write to a different buffer in shared memory than the one used for A0/A1 – shared memory for B0/B1?</span></span><br><span class="line"><span class="number">16</span> LDGSTS A3</span><br><span class="line"><span class="number">17</span> LDGDEPBAR </span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span> LDS A0</span><br><span class="line"><span class="number">20</span> LDS A1</span><br><span class="line"><span class="number">21</span>  </span><br><span class="line"><span class="number">22</span> DEPBAR <span class="number">1</span> <span class="comment">// A2/A3 can still be in flight </span></span><br><span class="line"><span class="number">23</span> BAR.SYNC <span class="comment">// __syncthreads</span></span><br></pre></td></tr></table></figure>
<p>I hope it makes sense. If not, do not hesitate to ask questions.</p>
<blockquote>
<p>&emsp;&emsp;再来看一下这段代码，大体上基本相似。Line 3、7分别创建了两个cp.async-group，Line 3包含了Line 1、2的异步拷贝操作，而Line 7则包含Line 5、6的异步拷贝。随后LDS从SMEM中B0、B1地址读取在之前已经准备好的数据。<br>&emsp;&emsp;Line 12 DEPBAR 1;指定线程等待直到仅剩一个cp.async-group，这里只有两个，为等待A0、A1访存结束。此时B2、B3还在传输中。<br>&emsp;&emsp;Line 17又创建了一个cp.async-group，包含了Line 15、16的异步拷贝操作。<br>&emsp;&emsp;由于A0、A1数据已经准备就绪，因此可直接LDS访问A0、A1。<br>&emsp;&emsp;执行到Line 22时，同样指定线程等待直到仅剩一个cp.async-group，此时仅剩2个cp.async-group仍在执行，即为等待B2、B3数据拷贝结束。</p>
</blockquote>
<p>补充一下后续其他操作，这种改动相当于是使用更多的SMEM，将每次LDGSTS中间穿插两次LDS，增大发起从GMEM中取回数据的异步拷贝操作与LDS之间的时间间隔(间隔两个循环步的prefetch)，更好地隐藏访存延迟。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  LDGSTS A0</span><br><span class="line"><span class="number">2</span>  LDGSTS A1</span><br><span class="line"><span class="number">3</span>  LDGDEPBAR </span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span>  LDGSTS B2 <span class="comment">// It must write to a different buffer in shared memory than the one used for B0/B1</span></span><br><span class="line"><span class="number">6</span>  LDGSTS B3</span><br><span class="line"><span class="number">7</span>  LDGDEPBAR </span><br><span class="line"><span class="number">8</span>  <span class="comment">// A0 A1 B2 B3 PENDING B0 B1 READY</span></span><br><span class="line"><span class="number">9</span>  LDS B0</span><br><span class="line"><span class="number">10</span> LDS B1</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span> DEPBAR <span class="number">1</span> <span class="comment">// The LDGSTS B2/B3 can still be in flight</span></span><br><span class="line"><span class="number">13</span> BAR.SYNC <span class="comment">// __syncthreads</span></span><br><span class="line"><span class="number">14</span> <span class="comment">// B2 B3 PENDING B0 B1 A0 A1 READY</span></span><br><span class="line"><span class="number">15</span> LDGSTS A2 <span class="comment">// It must write to a different buffer in shared memory than the one used for A0/A1 – shared memory for B0/B1?</span></span><br><span class="line"><span class="number">16</span> LDGSTS A3</span><br><span class="line"><span class="number">17</span> LDGDEPBAR </span><br><span class="line"><span class="number">18</span> <span class="comment">// B2 B3 A2 A3 PENDING B0 B1 A0 A1 READY</span></span><br><span class="line"><span class="number">19</span> LDS A0</span><br><span class="line"><span class="number">20</span> LDS A1</span><br><span class="line"><span class="number">21</span>  </span><br><span class="line"><span class="number">22</span> DEPBAR <span class="number">1</span> <span class="comment">// A2/A3 can still be in flight </span></span><br><span class="line"><span class="number">23</span> BAR.SYNC <span class="comment">// __syncthreads</span></span><br><span class="line"><span class="number">24</span> <span class="comment">// A2 A3 PENDING B0 B1 A0 A1 B2 B3 READY</span></span><br><span class="line"><span class="number">25</span> LDGSTS B0</span><br><span class="line"><span class="number">26</span> LDGSTS B1</span><br><span class="line"><span class="number">27</span> LDGDEPBAR</span><br><span class="line"><span class="number">28</span> <span class="comment">// A2 A3 B0 B1 PENDING A0 A1 B2 B3 READY</span></span><br><span class="line"><span class="number">29</span> LDS B2</span><br><span class="line"><span class="number">30</span> LDS B3</span><br><span class="line"><span class="number">31</span> </span><br><span class="line"><span class="number">32</span> DEPBAR <span class="number">1</span> </span><br><span class="line"><span class="number">33</span> BAR.SYNC</span><br><span class="line"><span class="number">34</span> <span class="comment">// B0 B1 PENDING A0 A1 B2 B3 A2 A3 READY</span></span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/20/cuda-4/" rel="prev" title="CUDA学习随记4 Volta’s Independent Thread Scheduling">
      <i class="fa fa-chevron-left"></i> CUDA学习随记4 Volta’s Independent Thread Scheduling
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/23/cuda-6/" rel="next" title="CUDA学习随记6 C++11中的内存模型 std::memory_order">
      CUDA学习随记6 C++11中的内存模型 std::memory_order <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B05-Asynchronous-copy-cp-async"><span class="nav-number">1.</span> <span class="nav-text">CUDA学习随记5 Asynchronous copy cp.async</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cp-async"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">cp.async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cp-async-commit-group"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">cp.async.commit_group</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cp-async-wait-group-cp-async-wait-all"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">cp.async.wait_group&#x2F;cp.async.wait_all</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8EJulien-Demouth-60-x6a-100-x65-x6d-111-x75-x74-x68-x40-110-x76-105-100-105-97-46-x63-x6f-x6d-gt-%E7%9A%84%E9%82%AE%E4%BB%B6%E5%BE%80%E6%9D%A5"><span class="nav-number">1.0.1.</span> <span class="nav-text">与Julien Demouth &lt;jdemouth@nvidia.com&gt;的邮件往来</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%91%E6%84%9A%E8%A0%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">我愚蠢的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E4%BD%AC%E7%9A%84%E5%9B%9E%E7%AD%94"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">大佬的回答</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiang Shao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiang Shao</p>
  <div class="site-description" itemprop="description">WeChat: shaojiang9650<br>Email: shao_study@163.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Shao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
