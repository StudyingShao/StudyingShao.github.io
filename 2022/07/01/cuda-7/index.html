<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CUDA学习随记7 B.25. Asynchronous Barrier CUDA, 软件抽象的幻影背后 CUDA, 软件抽象的幻影背后 之二 CUDA, 软件抽象的幻影背后 之三  CUDA Samples里面有好多有意思的代码，多学多看 6_Advanced&#x2F;jacobiCudaGraphs0_Simple\cudaTensorCoreGemm  References:  CUDA C++ P">
<meta property="og:type" content="article">
<meta property="og:title" content="CUDA学习随记7 Asynchronous Barrier">
<meta property="og:url" content="http://example.com/2022/07/01/cuda-7/index.html">
<meta property="og:site_name" content="邵大宝的学习Blog">
<meta property="og:description" content="CUDA学习随记7 B.25. Asynchronous Barrier CUDA, 软件抽象的幻影背后 CUDA, 软件抽象的幻影背后 之二 CUDA, 软件抽象的幻影背后 之三  CUDA Samples里面有好多有意思的代码，多学多看 6_Advanced&#x2F;jacobiCudaGraphs0_Simple\cudaTensorCoreGemm  References:  CUDA C++ P">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/07/01/cuda-7/1.jpg">
<meta property="og:image" content="http://example.com/2022/07/01/cuda-7/1.png">
<meta property="article:published_time" content="2022-07-01T14:56:18.000Z">
<meta property="article:modified_time" content="2022-07-18T08:58:07.464Z">
<meta property="article:author" content="Jiang Shao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/07/01/cuda-7/1.jpg">

<link rel="canonical" href="http://example.com/2022/07/01/cuda-7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CUDA学习随记7 Asynchronous Barrier | 邵大宝的学习Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">邵大宝的学习Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">最爱严小跳</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/01/cuda-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Shao">
      <meta itemprop="description" content="WeChat: shaojiang9650<br>Email: shao_study@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="邵大宝的学习Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CUDA学习随记7 Asynchronous Barrier
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-01 22:56:18" itemprop="dateCreated datePublished" datetime="2022-07-01T22:56:18+08:00">2022-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-18 16:58:07" itemprop="dateModified" datetime="2022-07-18T16:58:07+08:00">2022-07-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">CUDA学习随记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CUDA学习随记7-B-25-Asynchronous-Barrier"><a href="#CUDA学习随记7-B-25-Asynchronous-Barrier" class="headerlink" title="CUDA学习随记7 B.25. Asynchronous Barrier"></a>CUDA学习随记7 B.25. Asynchronous Barrier</h1><ol>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/06/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e/">CUDA, 软件抽象的幻影背后</a></li>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/08/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%ba%8c/">CUDA, 软件抽象的幻影背后 之二</a></li>
<li><a target="_blank" rel="noopener" href="https://singvision.net/2015/01/13/cuda-%e8%bd%af%e4%bb%b6%e6%8a%bd%e8%b1%a1%e7%9a%84%e5%b9%bb%e5%bd%b1%e8%83%8c%e5%90%8e-%e4%b9%8b%e4%b8%89/">CUDA, 软件抽象的幻影背后 之三</a></li>
</ol>
<p>CUDA Samples里面有好多有意思的代码，多学多看</p>
<p>6_Advanced/jacobiCudaGraphs<br>0_Simple\cudaTensorCoreGemm</p>
<blockquote>
<p><strong>References:</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#aw-barrier">CUDA C++ Programming Guide: B.25. Asynchronous Barrier</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-mbarrier">PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier</a></li>
</ol>
</blockquote>
<h2 id="CUDA-C-Programming-Guide-B-25-Asynchronous-Barrier"><a href="#CUDA-C-Programming-Guide-B-25-Asynchronous-Barrier" class="headerlink" title="CUDA C++ Programming Guide: B.25. Asynchronous Barrier"></a>CUDA C++ Programming Guide: B.25. Asynchronous Barrier</h2><h2 id="异步barrier"><a href="#异步barrier" class="headerlink" title="异步barrier"></a>异步barrier</h2><p>std::barrier的GPU实现，允许用户指定barrier对象的范围。</p>
<p>Devices of compute capability 8.0 or higher provide <strong>hardware acceleration</strong> for barrier operations and integration of these barriers with the <strong>memcpy_async</strong> feature.<br>CC 8.0及以上的设备对barrier拥有硬件加速，且集成了memcpy_async的特性（用于异步拷贝的同步）。</p>
<p>On devices with compute capability below 8.0 but starting 7.0, these barriers are available without hardware acceleration.<br>介于CC 7.0与8.0之间的设备具有barrier指令，但没有硬件加速。</p>
<h3 id="B-25-1-Simple-Synchronization-Pattern-简单同步模式"><a href="#B-25-1-Simple-Synchronization-Pattern-简单同步模式" class="headerlink" title="B.25.1. Simple Synchronization Pattern 简单同步模式"></a>B.25.1. Simple Synchronization Pattern 简单同步模式</h3><p>Without the arrive/wait barrier, synchronization is achieved using __syncthreads() (to synchronize all threads in a block) or group.sync() when using Cooperative Groups.</p>
<p>不使用barrier时，GPU拥有两种同步方式：</p>
<ol>
<li>__syncthreads()：同步一个block中的所有threads。</li>
<li>group.sync()：同步整个Cooperative Groups。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">simple_sync</span><span class="params">(<span class="type">int</span> iteration_count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iteration_count; ++i) &#123;</span><br><span class="line">        <span class="comment">/* code before arrive */</span></span><br><span class="line">        block.<span class="built_in">sync</span>(); <span class="comment">/* wait for all threads to arrive here */</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Cooperative Groups进行block级别同步的例子。<br>In addition, memory updates that happened before the synchronization point are guaranteed to be visible to all threads in the block after the synchronization point, i.e., equivalent to atomic_thread_fence(memory_order_seq_cst, thread_scope_block) as well as the sync.<br>除此之外，还隐含了memory fence的作用，在同步点前发生的内存修改操作，对同步点之后的所有线程均可见。这个特性__syncthreads()与group.sync()都有。保证了线程内内存读写的先后顺序。</p>
<blockquote>
<p><strong>这种模式有三个阶段：</strong></p>
<ol>
<li>sync之前的代码执行内存更新操作，且将要在sync之后被读取</li>
<li>同步点Synchronization point</li>
<li>sync之后的代码，拥有对sync之前发生的内存更新操作的可见性</li>
</ol>
</blockquote>
<p>一个同步 + 一个Memory Fence</p>
<h3 id="B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-时间分割同步-与-同步的五个阶段"><a href="#B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-时间分割同步-与-同步的五个阶段" class="headerlink" title="B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段"></a>B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段</h3><p>The temporally-split synchronization pattern with the std::barrier is as follows.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">compute</span><span class="params">(<span class="type">float</span>* data, <span class="type">int</span> curr_iteration)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">split_arrive_wait</span><span class="params">(<span class="type">int</span> iteration_count, <span class="type">float</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> barrier = cuda::barrier&lt;cuda::thread_scope_block&gt;;</span><br><span class="line">    <span class="comment">// C++11引入，相当于typedef，定义类型别名</span></span><br><span class="line">    <span class="comment">// cuda::barrier&lt;cuda::thread_scope_block&gt;;作用范围为block级别的cuda::barrier类型</span></span><br><span class="line"></span><br><span class="line">    __shared__  barrier bar;</span><br><span class="line">    <span class="comment">// 放在shared mem中的cuda::barrier，作用于整个block</span></span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line">    <span class="comment">// 一个Cooperative Groups，定义范围为整个block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// block.thread_rank()，Cooperative Groups专用，返回线程的组内索引号</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用0号线程初始化存储于shared mem中的cuda::barrier</span></span><br><span class="line">        <span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Initialize the barrier with expected arrival count</span></span><br><span class="line">        <span class="comment">// expected arrival count这里为block size</span></span><br><span class="line">    &#125;</span><br><span class="line">    block.<span class="built_in">sync</span>();<span class="comment">// Cooperative Groups同步，其他线程等待0号线程初始化cuda::barrier结束，并在同步点之后对shared mem中的cuda::barrier拥有可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> curr_iter = <span class="number">0</span>; curr_iter &lt; iteration_count; ++curr_iter) &#123;</span><br><span class="line">        <span class="comment">/* code before arrive */</span></span><br><span class="line">       barrier::arrival_token token = bar.<span class="built_in">arrive</span>(); <span class="comment">/* this thread arrives. Arrival does not block a thread */</span></span><br><span class="line">       <span class="comment">// 先执行完的线程先开始其他工作，做完之后再bar.wait()等待其他线程到达bar.arrive()，从而减少每个线程等待的时间</span></span><br><span class="line">       <span class="built_in">compute</span>(data, curr_iter);</span><br><span class="line">       bar.<span class="built_in">wait</span>(std::<span class="built_in">move</span>(token)); <span class="comment">/* wait for all threads participating in the barrier to complete bar.arrive()*/</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>
<p>In this pattern, the synchronization point (<strong>block.sync()</strong>) is split into an arrive point (<strong>bar.arrive()</strong>) and a wait point (<strong>bar.wait(std::move(token))</strong>). A thread begins participating in a <strong>cuda::barrier</strong> with its first call to <strong>bar.arrive()</strong>.<br>此模式下原来的一个同步点block.sync()被分割为了一个到达点bar.arrive()与一个等待点bar.wait(std::move(token))。当一个线程首次执行到bar.arrive()时，视为其开始参与到cuda::barrier中。</p>
<p>When a thread calls bar.wait(std::move(token)) it will be blocked until participating threads have completed bar.arrive() the expected number of times as specified by the expected arrival count argument passed to init().<br>当一个线程执行到bar.wait(std::move(token))，此线程将被blocked，直到参与到cuda::barrier中的线程执行了期望次数的bar.arrive()。这个期望次数在一开始使用init()函数初始化cuda::barrier时指定。<br>比如示例代码中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Initialize the barrier with expected arrival count</span></span><br></pre></td></tr></table></figure><br>为使用block size初始化cuda::barrier，等于对block中所有线程的同步操作。</p>
<p><strong>Memory updates that happen before participating threads’ call to bar.arrive() are guaranteed to be visible to participating threads after their call to bar.wait(std::move(token)).</strong><br>这种方式也有memory fence的功能，区别是发生在bar.arrive()之前的内存修改将会对bar.wait()之后的代码可见。</p>
<p>Note that the call to bar.arrive() does not block a thread, it can proceed with other work that does not depend upon memory updates that happen before other participating threads’ call to bar.arrive().<br>bar.arrive()并不会阻塞一个线程继续执行，只有bar.wait()会，因此在线程到达bar.arrive()后，可以在等待其他线程到达bar.arrive()之前，继续执行一些不依赖于由其他参与线程到达bar.arrive()之前进行的内存修改的工作。</p>
<blockquote>
<p><strong>这种arrive之后wait的模式有五个阶段：</strong></p>
<ol>
<li>arrive之前的代码执行内存更新操作，且将会在wait之后被读取</li>
<li>arrive point 到达点，含有隐式的memory fence，等价于<br><strong>atomic_thread_fence(memory_order_seq_cst, thread_scope_block) 顺序一致模型</strong></li>
<li>arrive与wait之间的代码，一些不依赖其他线程在arrive之前进行的内存更新操作的工作。</li>
<li>wait point 等待点，等待执行arrive的数量满足要求。</li>
<li>wait之后的代码，拥有对arrive之前发生的内存更新操作的可见性。</li>
</ol>
</blockquote>
<h3 id="B-25-3-Bootstrap-Initialization-Expected-Arrival-Count-and-Participation-初始化、预期到达计数、参与性"><a href="#B-25-3-Bootstrap-Initialization-Expected-Arrival-Count-and-Participation-初始化、预期到达计数、参与性" class="headerlink" title="B.25.3. Bootstrap Initialization, Expected Arrival Count, and Participation 初始化、预期到达计数、参与性"></a>B.25.3. Bootstrap Initialization, Expected Arrival Count, and Participation 初始化、预期到达计数、参与性</h3><p>Initialization must happen before any thread begins participating in a cuda::barrier.<br>cuda::barrier的初始化必须happen before任意线程开始参与cuda::barrier。<br>happen before具有对内存状态的可见性，也就是说其他线程必须对初始化之后的结果可见。<br>cuda::barrier对线程participating的定义为线程调用bar.arrive()开始。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">init_barrier</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    __shared__ cuda::barrier&lt;cuda::thread_scope_block&gt; bar;</span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(&amp;bar, block.<span class="built_in">size</span>()); <span class="comment">// Single thread initializes the total expected arrival count.</span></span><br><span class="line">    &#125;</span><br><span class="line">    block.<span class="built_in">sync</span>();         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数init()来为cuda::barrier进行初始化，其第二个参数为expected arrival count (期望到达数量)，指期待参与线程执行bar.arrive()的次数，到达这个数量后，线程于bar.wait(std::move(token))处unblocked。</p>
<p>A cuda::barrier is flexible in specifying how threads participate (split arrive/wait) and which threads participate. In contrast this_thread_block.sync() from cooperative groups or <strong>syncthreads() is applicable to whole-thread-block and </strong>syncwarp(mask) is a specified subset of a warp. If the intention of the user is to synchronize a full thread block or a full warp we recommend using <strong>syncthreads() and </strong>syncwarp(mask) respectively for <strong>performance reasons</strong>.<br>cuda::barrier可以自由指定参与其中的线程与线程参与的方式，相比之下cooperative groups (指定为整个block) 或<strong>syncthreads()作用于整个block，而</strong>syncwarp(mask)作用于一个warp的子集 (具体参与其中的线程lane由mask对应bit位为 0/1 指定 不参与/参与)<br>如果希望对block或warp进行同步，使用<strong>syncthreads()与</strong>syncwarp(mask)性能更好。</p>
<h3 id="B-25-4-A-Barrier’s-Phase-Arrival-Countdown-Completion-and-Reset-Barrier的四种状态：到达、倒计时、完成、重置"><a href="#B-25-4-A-Barrier’s-Phase-Arrival-Countdown-Completion-and-Reset-Barrier的四种状态：到达、倒计时、完成、重置" class="headerlink" title="B.25.4. A Barrier’s Phase: Arrival, Countdown, Completion, and Reset Barrier的四种状态：到达、倒计时、完成、重置"></a>B.25.4. A Barrier’s Phase: Arrival, Countdown, Completion, and Reset Barrier的四种状态：到达、倒计时、完成、重置</h3><p>A cuda::barrier counts down from the expected arrival count to zero as participating threads call bar.arrive(). When the countdown reaches zero, a cuda::barrier is complete for the current phase. When the last call to bar.arrive() causes the countdown to reach zero, the countdown (计数器) is <strong>automatically</strong> and <strong>atomically</strong> reset. The reset assigns <strong>the countdown to the expected arrival count</strong>, and moves the cuda::barrier to the next phase.</p>
<p>A token object (记号对象) of class <strong>cuda::barrier::arrival_token</strong>, as <strong>returned from token=bar.arrive()</strong>, is associated with the current phase of the barrier. A call to bar.wait(std::move(token)) blocks the calling thread while the cuda::barrier is in the current phase, i.e., while <strong>the phase associated with the token matches the phase of the cuda::barrier</strong>. If the phase is advanced (because the countdown reaches zero) before the call to bar.wait(std::move(token)) then the thread does not block; if the phase is advanced while the thread is blocked in bar.wait(std::move(token)), the thread is unblocked.<br>bar.wait(std::move(token))函数会block其中cuda::barrier与其参数token处于相同阶段的线程，如果线程的阶段更超前，则unblocked。</p>
<blockquote>
<p>std::move语句的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用来使用该值，避免了使用左值对象赋值时，调用拷贝构造函数，具有更佳的性能。<br>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。</p>
<p>std::move，移动构造函数。<br>通过移动构造，<strong>b指向a的资源，a不再拥有资源 (资源所有权的转移) </strong>，这里的资源，可以是动态申请的内存，网络链接，打开的文件，也可以是本例中的string。<strong>这时候访问a的行为时未定义的</strong>，比如，如果资源是动态内存，a被移动之后，再次访问a的资源，根据移动构造函数的定义，可能是空指针，如果是资源上文的string，移动之后，a的资源为空字符串（string被移动之后，为空字符串）。</p>
<center><img src="/2022/07/01/cuda-7/1.jpg" width="100%" height="100%"></center>

</blockquote>
<ul>
<li>A thread’s calls to token=bar.arrive() and bar.wait(std::move(token)) must be <strong>sequenced</strong> such that token=bar.arrive() occurs during the cuda::barrier’s current phase, and bar.wait(std::move(token)) occurs during the same or next phase.<br><code>token=bar.arrive()</code>与<code>bar.wait(std::move(token))</code>必须有严格的先后顺序</li>
<li>A thread’s call to bar.arrive() must occur when the barrier’s counter is non-zero. After barrier initialization, if a thread’s call to bar.arrive() causes the countdown to reach zero then a call to bar.wait(std::move(token)) must happen before the barrier can be reused for a subsequent call to bar.arrive().<br>必须在<code>cuda::barrier</code>的countdown非0的时候才能调用<code>bar.arrive()</code>。在初始化<code>cuda::barrier</code>之后，如果任一线程调用<code>bar.arrive()</code>导致countdown到达0，则此时必须调用一次<code>bar.wait(std::move(token))</code>，才可将<code>cuda::barrier</code> reset，从而reuse这个<code>cuda::barrier</code>。</li>
<li>bar.wait() must only be called using a token object of the current phase or the immediately preceding phase. For any other values of the token object, the behavior is undefined.</li>
</ul>
<h3 id="B-25-5-Spatial-Partitioning-also-known-as-Warp-Specialization-空间划分-warp专用"><a href="#B-25-5-Spatial-Partitioning-also-known-as-Warp-Specialization-空间划分-warp专用" class="headerlink" title="B.25.5. Spatial Partitioning (also known as Warp Specialization)  空间划分 (warp专用)"></a>B.25.5. Spatial Partitioning (also known as Warp Specialization)  空间划分 (warp专用)</h3><p>A thread block can be spatially partitioned such that warps are specialized to <strong>perform independent computations</strong>. Spatial partitioning is used in a <strong>producer</strong> or <strong>consumer</strong> pattern, where one subset of threads produces data that is concurrently consumed by the other (disjoint) subset of threads.<br>block中线程按照warp划分，不同的warp间可独立执行不同的指令 (disjoint)。</p>
<p>A producer/consumer spatial partitioning pattern requires two one sided synchronizations to manage a data buffer between the producer and consumer.<br>producer/consumer空间划分方式需要在producer与consumer中分别进行单侧同步。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Producer</th>
<th>Consumer</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait for buffer to be ready to be filled</td>
<td>signal buffer is ready to be filled</td>
</tr>
<tr>
<td>produce data and fill the buffer</td>
<td></td>
</tr>
<tr>
<td>signal buffer is filled</td>
<td>wait for buffer to be filled</td>
</tr>
<tr>
<td></td>
<td>consume data in filled buffer</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> barrier = cuda::barrier&lt;cuda::thread_scope_block&gt;;</span><br><span class="line"><span class="comment">// 类型别名</span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">producer</span><span class="params">(barrier ready[], barrier filled[], <span class="type">float</span>* buffer, <span class="type">float</span>* in, <span class="type">int</span> N, <span class="type">int</span> buffer_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (N/buffer_len); ++i) &#123;</span><br><span class="line">        ready[i%<span class="number">2</span>].<span class="built_in">arrive_and_wait</span>(); <span class="comment">/* wait for buffer_(i%2) to be ready to be filled */</span></span><br><span class="line">        <span class="comment">// 初始情况下所有producer线程执行一次arrive_and_wait，此函数为arrive之后wait，因此结合consumer中的线程，block中所有线程初始时均执行了一次arrive，此时ready[i%2] barrier的countdown由初始化的block size减至0，此时此处的arrive_and_wait中包含的wait不再block producer线程</span></span><br><span class="line">        <span class="comment">// 此时ready[i%2] barrier reset，其countdown重新恢复至block size</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* produce, i.e., fill in, buffer_(i%2)  */</span></span><br><span class="line">        <span class="comment">// producer线程填充 buffer</span></span><br><span class="line"></span><br><span class="line">        barrier::arrival_token token = filled[i%<span class="number">2</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_(i%2) is filled */</span></span><br><span class="line">        <span class="comment">// 线程填充过之后会将对应的filled[i%2] barrier的countdown减至warp size</span></span><br><span class="line">        <span class="comment">// 并++i进入下一循环，使得另一个ready barrier的countdown减至warpsize</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">void</span> <span class="title">consumer</span><span class="params">(barrier ready[], barrier filled[], <span class="type">float</span>* buffer, <span class="type">float</span>* out, <span class="type">int</span> N, <span class="type">int</span> buffer_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    barrier::arrival_token token1 = ready[<span class="number">0</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_0 is ready for initial fill */</span></span><br><span class="line">    barrier::arrival_token token2 = ready[<span class="number">1</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_1 is ready for initial fill */</span></span><br><span class="line">    <span class="comment">// 以上代码每个consumer线程都会执行一次，因此会使得两个ready barrier的countdown均减至一个warp size (block size = 2 * warp size)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (N/buffer_len); ++i) &#123;</span><br><span class="line">        filled[i%<span class="number">2</span>].<span class="built_in">arrive_and_wait</span>(); <span class="comment">/* wait for buffer_(i%2) to be filled */</span></span><br><span class="line">        <span class="comment">// 等待producer填充数据结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* consume buffer_(i%2) */</span></span><br><span class="line">        <span class="comment">// consumer使用buffer中已经填充好的数据</span></span><br><span class="line"></span><br><span class="line">        barrier::arrival_token token = ready[i%<span class="number">2</span>].<span class="built_in">arrive</span>(); <span class="comment">/* buffer_(i%2) is ready to be re-filled */</span></span><br><span class="line">        <span class="comment">// 提示对应buffer中的数据已经使用完毕，可以填充新的数据进来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//N is the total number of float elements in arrays in and out</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">producer_consumer_pattern</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> buffer_len, <span class="type">float</span>* in, <span class="type">float</span>* out)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shared memory buffer declared below is of size 2 * buffer_len</span></span><br><span class="line">    <span class="comment">// so that we can alternatively work between two buffers. </span></span><br><span class="line">    <span class="comment">// buffer_0 = buffer and buffer_1 = buffer + buffer_len</span></span><br><span class="line">    __shared__ <span class="keyword">extern</span> <span class="type">float</span> buffer[];</span><br><span class="line">    <span class="comment">// 动态分配的shared memory，大小在launch kernel时指定，为 2 * buffer_len</span></span><br><span class="line">    <span class="comment">// double buffer</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bar[0] and bar[1] track if buffers buffer_0 and buffer_1 are ready to be filled, </span></span><br><span class="line">    <span class="comment">// while bar[2] and bar[3] track if buffers buffer_0 and buffer_1 are filled-in respectively</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ping-Pong buffer，两个标记填充完毕，两个标记使用完毕</span></span><br><span class="line">    __shared__ barrier bar[<span class="number">4</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line">    <span class="comment">// block.thread_rank()函数返回cooperative_groups中线程Index</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="built_in">init</span>(bar + block.<span class="built_in">thread_rank</span>(), block.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 用四个线程，每个线程负责初始化一个cuda::barrier</span></span><br><span class="line">        <span class="comment">// barrier的countdown为block size</span></span><br><span class="line">    block.<span class="built_in">sync</span>();</span><br><span class="line">    <span class="comment">// block同步，顺便隐含一个memory fence，后续线程等待cuda::barrier初始化结束，并对初始化之后的结果可见</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// block size为两个warp，前32个作为producer，后32个为consumer</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() &lt; warpSize)</span><br><span class="line">        <span class="built_in">producer</span>(bar, bar+<span class="number">2</span>, buffer, in, N, buffer_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">consumer</span>(bar, bar+<span class="number">2</span>, buffer, out, N, buffer_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><img src="/2022/07/01/cuda-7/1.png" width="100%" height="100%"></center>

<p>In this example the first warp is specialized as the producer and the remaining warps are specialized as the consumer. All producer and consumer threads participate (call <code>bar.arrive()</code> or <code>bar.arrive_and_wait()</code>) in each of the four <code>cuda::barriers</code> so the expected arrival counts are equal to <code>block.size()</code>.<br>在这个示例中，通过if语句，将第一个warp指定为producer，而其余warps指定为consumer。所有的线程都通过调用<code>bar.arrive()</code> or <code>bar.arrive_and_wait()</code>函数参与到了四个barriers中。所以四个barrier的expected arrival counts均设置为block size。</p>
<p>A producer thread waits for the consumer threads to <strong>signal</strong> that the shared memory buffer can be filled. In order to wait for a <code>cuda::barrier</code> a producer thread must first arrive on that <code>ready[i%2].arrive()</code> to get a <strong>token</strong> and then <code>ready[i%2].wait(token)</code> with that token. For simplicity <code>ready[i%2].arrive_and_wait()</code> combines these operations.<br>wait函数需要使用arrive函数返回的token进行配对，而<code>ready[i%2].arrive_and_wait()</code>简化了这个过程，其相当于<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line"><span class="comment">/* is equivalent to */</span></span><br><span class="line">bar.<span class="built_in">wait</span>(bar.<span class="built_in">arrive</span>());</span><br></pre></td></tr></table></figure></p>
<p>Producer threads compute and fill the ready buffer, they then <strong>signal</strong> that the buffer is filled by arriving on the filled barrier, <code>filled[i%2].arrive()</code>. A producer thread does not wait at this point, instead it waits until the next iteration’s buffer (double buffering) is ready to be filled.<br>producer负责计算和填充已经ready的buffer，接着通过调用<code>filled[i%2].arrive()</code>发出buffer is filled的信号。producer不等待这个filled信号，而是等待consumer使用完毕之后发出的ready信号。</p>
<p>A consumer thread begins by signaling that both buffers are ready to be filled. A consumer thread does not wait at this point, instead it waits for this iteration’s buffer to be filled, <code>filled[i%2].arrive_and_wait()</code>. After the consumer threads consume the buffer they signal that the buffer is ready to be filled again, <code>ready[i%2].arrive()</code>, and then wait for the next iteration’s buffer to be filled.<br>consumer在一开始发出两个buffer均已经ready，可以进行填充的信号。而consumer不等待这个filled信号，而是等待producer发出的填充完毕的filled信号，通过调用函数<code>filled[i%2].arrive_and_wait()</code>。当consumer使用完毕一个buffer之后，其通过调用<code>ready[i%2].arrive()</code>，发出ready信号，告知producer可以对这个buffer进行填充，并等待下一个buffer to be filled。</p>
<p><strong>producer的循环流程为：</strong></p>
<ol>
<li>等待consumer的ready信号</li>
<li>填充ready的buffer</li>
<li>发出填充完毕的filled信号</li>
</ol>
<p><strong>consumer的循环流程为：</strong></p>
<ol>
<li>等待producer的filled信号</li>
<li>使用filled的buffer</li>
<li>发出使用完毕的ready信号</li>
</ol>
<h3 id="B-25-6-Early-Exit-Dropping-out-of-Participation-早退，提前退出barrier"><a href="#B-25-6-Early-Exit-Dropping-out-of-Participation-早退，提前退出barrier" class="headerlink" title="B.25.6. Early Exit (Dropping out of Participation) 早退，提前退出barrier"></a>B.25.6. Early Exit (Dropping out of Participation) 早退，提前退出barrier</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cuda/barrier&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cooperative_groups.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__device__ <span class="type">bool</span> <span class="title">condition_check</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">early_exit_kernel</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> barrier = cuda::barrier&lt;cuda::thread_scope_block&gt;;</span><br><span class="line">    __shared__ barrier bar;</span><br><span class="line">    <span class="comment">// 依旧放在shared mem中</span></span><br><span class="line">    <span class="keyword">auto</span> block = cooperative_groups::<span class="built_in">this_thread_block</span>();</span><br><span class="line">    <span class="comment">// 定义整个block为cooperative_groups</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">thread_rank</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">init</span>(&amp;bar , block.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//由0号线程完成barrier初始化工作，the expected arrival counts设置为block size </span></span><br><span class="line">    block.<span class="built_in">sync</span>();</span><br><span class="line">    <span class="comment">// block同步，同时隐含mem fence，使得其他线程对0号线程的初始化结果可见</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">condition_check</span>()) &#123;</span><br><span class="line">          bar.<span class="built_in">arrive_and_drop</span>();</span><br><span class="line">          <span class="comment">// arrive和drop函数的combination，线程先执行arrive参与到barrier中，随后drop早退</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 早退的线程直接return结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* other threads can proceed normally */</span></span><br><span class="line">        barrier::arrival_token token = bar.<span class="built_in">arrive</span>();</span><br><span class="line">        <span class="comment">/* code between arrive and wait */</span></span><br><span class="line">        bar.<span class="built_in">wait</span>(std::<span class="built_in">move</span>(token)); <span class="comment">/* wait for all threads to arrive */</span></span><br><span class="line">        <span class="comment">/* code after wait */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bar.arrive_and_drop();</code><br>This operation arrives on the <code>cuda::barrier</code> to fulfill the participating thread’s obligation to arrive in the current phase, and then decrements the expected arrival count for the next phase so that this thread is no longer expected to arrive on the barrier.<br>这个操作首先执行arrive，履行参与线程的义务，使barrier计数达到the expected arrival count，从而进入下一phase，接下来执行drop操作，退出barrier的参与，同时<strong>减少barrier在下一个phase中的the expected arrival count</strong>，因为此线程退出了，永远不会arrive。</p>
<h3 id="B-25-7-Memory-Barrier-Primitives-Interface-内存barrier原语接口-mbarrier"><a href="#B-25-7-Memory-Barrier-Primitives-Interface-内存barrier原语接口-mbarrier" class="headerlink" title="B.25.7. Memory Barrier Primitives Interface  内存barrier原语接口 (mbarrier)"></a>B.25.7. Memory Barrier Primitives Interface  内存barrier原语接口 (mbarrier)</h3><blockquote>
<p><strong>Primitives 原语</strong><br>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中<strong>不可被中断</strong>。原语一旦开始执行，就要连续执行完，不允许中断，否则就会出现操作错误，造成系统混乱。</p>
</blockquote>
<ul>
<li>需要include头文件<code>&lt;cuda_awbarrier_primitives.h&gt;</code></li>
</ul>
<h4 id="B-25-7-1-Data-Types-数据类型"><a href="#B-25-7-1-Data-Types-数据类型" class="headerlink" title="B.25.7.1. Data Types 数据类型"></a>B.25.7.1. Data Types 数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="comment">/* implementation defined */</span> <span class="type">__mbarrier_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="comment">/* implementation defined */</span> <span class="type">__mbarrier_token_t</span>;  </span><br></pre></td></tr></table></figure>
<h4 id="B-25-7-2-Memory-Barrier-Primitives-API-原语API"><a href="#B-25-7-2-Memory-Barrier-Primitives-API-原语API" class="headerlink" title="B.25.7.2. Memory Barrier Primitives API 原语API"></a>B.25.7.2. Memory Barrier Primitives API 原语API</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> __mbarrier_maximum_count();</span><br><span class="line"><span class="type">void</span> __mbarrier_init(<span class="type">__mbarrier_t</span>* bar, <span class="type">uint32_t</span> expected_count); </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>初始化函数的原语函数</strong></li>
<li>bar must be a pointer to <strong>shared</strong> memory.  <strong>bar指针指向的mbarrier对象必须放在shared mem中！</strong></li>
<li>expected_count &lt;= __mbarrier_maximum_count()  </li>
<li>Initialize *bar expected arrival count for the current and next phase to expected_count.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __mbarrier_inval(<span class="type">__mbarrier_t</span>* bar); </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>功能：使mbarrier失效！</strong></li>
<li>bar must be a pointer to the mbarrier object residing in shared memory.  <strong>bar必须为指向放在shared mem中的mbarrier对象的指针</strong></li>
<li>Invalidation of <em>bar is required before the corresponding shared memory can be repurposed.  <em>*在重新将mbarrier所占用的shared mem分配出去之前必须先使mbarrier失效</em></em></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__mbarrier_token_t</span> __mbarrier_arrive(<span class="type">__mbarrier_t</span>* bar);    </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>bar.arrive()函数的原语函数</strong></li>
<li>Initialization of *bar must happen before this call.</li>
<li>Pending count must not be zero.</li>
<li>Atomically decrement the pending count for the current phase of the barrier.  <strong>以原子方式做countdown</strong></li>
<li>Return an arrival token associated with the barrier state immediately prior to the decrement.  <strong>返回计数-1之前反映barrier状态的token</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__mbarrier_token_t</span> __mbarrier_arrive_and_drop(<span class="type">__mbarrier_t</span>* bar);   </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>arrive_and_drop函数的原语函数，由于包含arrive函数，因此含有arrive函数的所有特性，此外还含有drop函数的特性</strong></li>
<li>Initialization of *bar must happen before this call.</li>
<li>Pending count must not be zero.</li>
<li>Atomically decrement <strong>the pending count for the current phase</strong> and <strong>expected count for the next phase</strong> of the barrier.  <strong>除了arrive会将做countdown之外，drop函数还会使线程早退，并使得the expected arrival count -1</strong></li>
<li>Return an arrival token associated with the barrier state immediately prior to the decrement.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __mbarrier_test_wait(<span class="type">__mbarrier_t</span>* bar, <span class="type">__mbarrier_token_t</span> token);  </span><br></pre></td></tr></table></figure>
<ul>
<li>token must be associated with <strong>the immediately preceding phase</strong> or <strong>current phase</strong> of *this.</li>
<li>Returns true if token is associated with the immediately preceding phase of <em>bar, otherwise returns false.  <em>*如果token为前一阶段，则返回true (还需继续等待)，使得线程wait；如果token为当前阶段，则返回false (无需继续等待)，unblock线程。</em></em></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This API has been deprecated in CUDA 11.1 </span></span><br><span class="line"><span class="comment">// 从CUDA 11.1开始，__mbarrier_pending_count函数被弃用</span></span><br><span class="line"><span class="type">uint32_t</span> __mbarrier_pending_count(<span class="type">__mbarrier_token_t</span> token);</span><br></pre></td></tr></table></figure>
<h2 id="PTX-ISA-9-7-12-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier"><a href="#PTX-ISA-9-7-12-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier" class="headerlink" title="PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier"></a>PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier</h2><h2 id="并行同步通讯指令：mbarrier"><a href="#并行同步通讯指令：mbarrier" class="headerlink" title="并行同步通讯指令：mbarrier"></a>并行同步通讯指令：mbarrier</h2><p><code>mbarrier</code> is a barrier created in <strong>shared memory</strong> that supports :</p>
<ul>
<li>Synchronizing any subset of threads within a CTA<br>同步一个block中的任意线程子集 (mbarrier本身位于shared mem中，因此只能作用于block范围内)</li>
<li>Waiting for completion of asynchronous <code>cp.async</code> operations initiated by a thread and <strong>making them visible to other threads</strong>.<br>等待线程发起的异步数据拷贝结束(cp.async，global mem to shared mem的异步数据拷贝)，并使得拷贝的结果对其他线程可见。</li>
</ul>
<blockquote>
<p>CTA (Cooperative Thread Array), CUDA程序的任务分发单位，CTA与block是同一事物在<strong>执行模型</strong>和<strong>编程模型</strong>中的表述。</p>
</blockquote>
<p>An mbarrier object is an <strong>opaque object</strong> in memory which can be initialized and invalidated using :</p>
<ul>
<li><code>mbarrier.init</code> <strong>initialize</strong></li>
<li><code>mbarrier.inval</code> <strong>invalidate</strong></li>
</ul>
<blockquote>
<p>C++ opaque object，不透明对象，其没有对外可见的属性和方法，只能 pass these objects to related functions that know how to work with them.</p>
</blockquote>
<p>Operations supported on mbarrier objects are :</p>
<ul>
<li><code>mbarrier.arrive</code></li>
<li><code>mbarrier.arrive_drop</code></li>
<li><code>mbarrier.test_wait</code></li>
<li><code>mbarrier.pending_count</code> // 按照 <a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#memory_barrier_primitives_interface">CUDA C++ Programming Guide</a> 的说法，这个在CUDA 11.1中被弃用了</li>
<li><code>cp.async.mbarrier.arrive</code> //与异步拷贝函数cp.async相关</li>
</ul>
<p>未经<code>mbarrier.init</code>初始化就对mbarrier施加操作会导致undefined behavior。</p>
<p>mbarrier operations enable threads to perform useful work <strong>after the arrival at the mbarrier</strong> and <strong>before waiting for the mbarrier to complete</strong>. The wait operation test_wait performs a <strong>non blocking test</strong> of mbarrier completion.</p>
<h3 id="9-7-12-11-1-Size-and-alignment-of-mbarrier-object"><a href="#9-7-12-11-1-Size-and-alignment-of-mbarrier-object" class="headerlink" title="9.7.12.11.1. Size and alignment of mbarrier object"></a>9.7.12.11.1. Size and alignment of mbarrier object</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Type</th>
<th style="text-align:center">Alignment (bytes)</th>
<th style="text-align:center">Memory space</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.b64</td>
<td style="text-align:center">8</td>
<td style="text-align:center">.shared</td>
</tr>
</tbody>
</table>
</div>
<h3 id="9-7-12-11-2-Contents-of-the-mbarrier-object"><a href="#9-7-12-11-2-Contents-of-the-mbarrier-object" class="headerlink" title="9.7.12.11.2. Contents of the mbarrier object"></a>9.7.12.11.2. Contents of the mbarrier object</h3><p>An opaque mbarrier object keeps track of the following information :</p>
<ul>
<li>Current phase of the mbarrier object<br>当前phase</li>
<li>Count of pending arrivals for the current phase of the mbarrier object<br>等待arrive的数量</li>
<li>Count of expected arrivals for the next phase of the mbarrier object<br>下一phase的expected arrivals count</li>
</ul>
<p>An mbarrier object progresses through a sequence of phases where each phase is defined by <strong>threads performing an expected number of arrive-on operations</strong>.<br>phase of the mbarrier: 线程进行expected number的arrive-on operation。</p>
<p>The valid range of pending arrival count and expected arrival count is [1, 220 -1].<br>pending arrival count: 待arrive的数量<br>expected arrival count: 期望arrive的数量<br>expected arrival count - pending arrival count = 已经arrive的数量</p>
<h3 id="9-7-12-11-3-Lifecycle-of-the-mbarrier-object"><a href="#9-7-12-11-3-Lifecycle-of-the-mbarrier-object" class="headerlink" title="9.7.12.11.3. Lifecycle of the mbarrier object"></a>9.7.12.11.3. Lifecycle of the mbarrier object</h3><p>The mbarrier object must be initialized prior to use.<br>使用前必须先进行初始化，不然会导致undefined behavior。</p>
<p>An mbarrier object is used to <strong>synchronize threads (within a block)</strong> and <strong>cp.async operations (除了等待完成还会使得结果对block内其他线程可见)</strong>.</p>
<p>An mbarrier object may be used to perform a sequence of such synchronizations.<br>mbarrier可重复使用，每一段使用过程对应一个phase。</p>
<p>An mbarrier object must be invalidated to repurpose its memory.<br>在重新分配mbarrier所占用的内存之前，必须先将其invalidated。</p>
<h3 id="9-7-12-11-4-Phase-of-the-mbarrier-object"><a href="#9-7-12-11-4-Phase-of-the-mbarrier-object" class="headerlink" title="9.7.12.11.4. Phase of the mbarrier object"></a>9.7.12.11.4. Phase of the mbarrier object</h3><p>The phase of an mbarrier object is <strong>the number of times the mbarrier object has been used</strong> to synchronize threads and cp.async operations. In each phase {0, 1, 2, …}, threads perform in program order :</p>
<ul>
<li>arrive-on operations to <strong>complete the current phase</strong> and</li>
<li>test-wait operations to <strong>check for the completion of the current phase</strong>.</li>
</ul>
<p>An mbarrier object is <strong>automatically reinitialized upon completion of the current phase</strong> for immediate use in the next phase. The current phase is incomplete and all prior phases are complete.<br>当前phase完成时自动初始化，以便立即开始下一phase的重复使用。</p>
<h3 id="9-7-12-11-5-Arrive-on-operation-on-mbarrier-object"><a href="#9-7-12-11-5-Arrive-on-operation-on-mbarrier-object" class="headerlink" title="9.7.12.11.5. Arrive-on operation on mbarrier object"></a>9.7.12.11.5. Arrive-on operation on mbarrier object</h3><p>An arrive-on operation, with <strong>an optional count argument (不指定默认为1)</strong>, on an mbarrier object consists of the following 2 steps :</p>
<ul>
<li><p>mbarrier signalling :<br>Signals <strong>the arrival of the executing thread</strong> OR <strong>completion of the asynchronous copy operations initiated by the executing thread</strong> on the mbarrier object. As a result of this, the pending arrival count is decremented by <strong>count</strong>. If the count argument is not specified, then <strong>it defaults to 1</strong>.<br>发出信号宣布当前执行线程arrive-on 或 当前执行线程发出的异步拷贝操作已经完成。通过将the pending arrival count减少count的方式发出这个信号，如果不指定count默认为1。</p>
</li>
<li><p>mbarrier completing the current phase :<br>If the count of <strong>the pending arrivals has reached zero</strong> then :</p>
<ul>
<li>the mbarrier object <strong>completes the current phase</strong> and <strong>transitions to the next phase</strong> and</li>
<li><strong>the pending arrival count is reinitialized to the expected arrival count</strong></li>
</ul>
<p>In other words, if all the pending arrivals of the mbarrier object have happened, the mbarrier object gets reinitialized so that it can be immediately reused and the mbarrier object transitions to the next phase.<br>如果所有的pending arrivals都arrive-on了，那么mbarrier自动初始化 (the pending arrivel count 由0重新变为 the expected arrival count)，当前phase完成，进入下一phase。</p>
</li>
</ul>
<h3 id="9-7-12-11-6-Parallel-Synchronization-and-Communication-Instructions-mbarrier-init"><a href="#9-7-12-11-6-Parallel-Synchronization-and-Communication-Instructions-mbarrier-init" class="headerlink" title="9.7.12.11.6. Parallel Synchronization and Communication Instructions: mbarrier.init"></a>9.7.12.11.6. Parallel Synchronization and Communication Instructions: mbarrier.init</h3><p><strong>mbarrier.init</strong><br>Initialize the mbarrier object.</p>
<p><strong>Syntax 语法</strong><br><code>mbarrier.init&#123;.shared&#125;.b64 [addr], count;</code><br>.shared: 存储空间为shared mem<br>.b64: 数据类型<br>count: the expected arrival count</p>
<p><strong>Description</strong><br><code>mbarrier.init</code> initializes the mbarrier object at the location specified by the address operand <code>addr</code> with the unsigned 32-bit integer <code>count</code>. The value of operand <code>count</code> must be in the range as specified in Contents of the mbarrier object.</p>
<p>Initialization of the mbarrier object involves :</p>
<ul>
<li><strong>Initializing the current phase to 0.</strong><br>所以我猜current phase其实就是当前phase中arrive-on的count</li>
<li>Initializing the expected arrival count to count.</li>
<li>Initializing the pending arrival count to count.</li>
</ul>
<p>If no state space is specified then Generic Addressing is used. If the address specified by <code>addr</code> does not fall within the address window of <code>.shared</code> state space then the behavior is undefined.<br>如果没有使用<code>.share</code>操作数指定state space，则使用Generic Addressing通用地址，此时就要求<code>addr</code>指向的地址必须位于shared mem中，否则会导致undefined behavior。</p>
<p>Supported addressing modes for operand <code>addr</code> is as described in Addresses as Operands.<br>Alignment for operand addr is as described in the Size and alignment of mbarrier object.<br><strong>8 bytes, 64 bits</strong></p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.shared .b64 shMem, shMem2;</span><br><span class="line">.reg    .b64 addr;</span><br><span class="line">.reg    .b32 %r1;</span><br><span class="line"></span><br><span class="line">cvta.shared.u64          addr, shMem2;</span><br><span class="line">mbarrier.init.b64        [addr],   %r1;</span><br><span class="line">bar.sync                 0;</span><br><span class="line">// ... other mbarrier operations on addr</span><br><span class="line">// 这里cvta.shared.u64保证了addr指向的空间位于.share state space。因此mbarrier.init.b64指令没有添加.shared。</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem], 12;</span><br><span class="line">bar.sync                 0;</span><br><span class="line">// ... other mbarrier operations on shMem</span><br></pre></td></tr></table></figure></p>
<h3 id="9-7-12-11-7-Parallel-Synchronization-and-Communication-Instructions-mbarrier-inval"><a href="#9-7-12-11-7-Parallel-Synchronization-and-Communication-Instructions-mbarrier-inval" class="headerlink" title="9.7.12.11.7. Parallel Synchronization and Communication Instructions: mbarrier.inval"></a>9.7.12.11.7. Parallel Synchronization and Communication Instructions: mbarrier.inval</h3><p><strong>mbarrier.inval</strong><br>Invalidates the mbarrier object.</p>
<p><strong>Syntax</strong><br><code>mbarrier.inval&#123;.shared&#125;.b64 [addr];</code></p>
<p><strong>Description</strong><br><code>mbarrier.inval</code> invalidates the mbarrier object at the location specified by the address operand <code>addr</code>.</p>
<p>An mbarrier object must be invalidated before using its memory location for any other purpose.<br>在将mbarrier所占用内存用作其他用途之前，必须先将mbarrier无效处理。</p>
<p>Performing any mbarrier operation except mbarrier.init on an invalidated mbarrier object results in undefined behaviour.</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.shared .b64 shmem;</span><br><span class="line">.reg    .b64 addr;</span><br><span class="line">.reg    .b32 %r1;</span><br><span class="line">.reg    .pred t0;</span><br><span class="line"></span><br><span class="line">// Example 1 :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.init.b64     [addr], %r1;</span><br><span class="line">// ... other mbarrier operations on addr</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.inval.b64    [addr];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Example 2 :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">mbarrier.init.shared.b64      [shmem], 12;</span><br><span class="line">// ... other mbarrier operations on shmem</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.inval.shared.b64 [shmem];</span><br><span class="line"></span><br><span class="line">// shmem can be reused here for unrelated use :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">st.shared.b64                 [shmem], ...;</span><br><span class="line"></span><br><span class="line">// shmem can be re-initialized as mbarrier object :</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.init.shared.b64  [shmem], 24;</span><br><span class="line">// ... other mbarrier operations on shmem</span><br><span class="line">bar.sync                      0;</span><br><span class="line">@t0 mbarrier.inval.shared.b64 [shmem];</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-8-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive"><a href="#9-7-12-11-8-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive" class="headerlink" title="9.7.12.11.8. Parallel Synchronization and Communication Instructions: mbarrier.arrive"></a>9.7.12.11.8. Parallel Synchronization and Communication Instructions: mbarrier.arrive</h3><p><strong>mbarrier.arrive</strong><br>Performs <strong>arrive-on operation</strong> on the mbarrier object.</p>
<p><strong>Syntax</strong><br><code>mbarrier.arrive&#123;.shared&#125;.b64 state, [addr];</code><br><code>mbarrier.arrive.noComplete&#123;.shared&#125;.b64 state, [addr], count;</code></p>
<p><strong>Description</strong><br>A thread executing <code>mbarrier.arrive</code> performs an <strong>arrive-on operation</strong> on the mbarrier object at the location specified by the address operand <code>addr</code>. The 32-bit unsigned integer operand <code>count</code> specifies the count argument to the arrive-on operation.<br>count操作数指定实行arrive-on operation时，从the pending arrival count中减去的值。</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p>When the argument count is specified, the modifier <code>.noComplete</code> is required. A <code>mbarrier.arrive</code> operation with <code>.noComplete</code> qualifier <strong>must not cause the mbarrier to complete its current phase</strong>, otherwise the behavior is undefined.<br>当不使用默认为1的count数，而是人为指定count数值的时候，必须为<code>mbarrier.arrive</code>操作加上说明符<code>.noComplete</code>，这样的操作<strong>不能导致mbarrier完成当前phase</strong> (指the pending arrival count减去count数后变为0)，否则会导致undefined behavior。</p>
<p>The value of the operand count must be in the range as specified in Contents of the mbarrier object.</p>
<p><code>mbarrier.arrive</code> returns <strong>an opaque 64-bit register capturing the phase of the mbarrier object prior to the arrive-on operation</strong> in the destination operand (输出操作数) <code>state</code>. Contents of the <code>state</code> operand are implementation specific. Optionally, sink symbol ‘_’ can be used for the state argument.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p>Support for sink symbol ‘_’ as the destination operand is introduced in PTX ISA version 7.1.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.reg .b32 cnt;</span><br><span class="line">.reg .b64 %r&lt;3&gt;, addr;</span><br><span class="line">.shared .b64 shMem, shMem2;</span><br><span class="line"></span><br><span class="line">cvta.shared.u64          addr, shMem2;</span><br><span class="line"></span><br><span class="line">mbarrier.arrive.shared.b64     %r0, [shMem];</span><br><span class="line"></span><br><span class="line">mbarrier.arrive.noComplete.b64 %r1, [addr], 2;</span><br><span class="line">mbarrier.arrive.noComplete.b64 %r2, [addr], cnt;</span><br><span class="line">// 后两个指定了count，因此必须加上.noComplete说明符</span><br><span class="line">// 且后两个操作不能造成当前phase完成！</span><br></pre></td></tr></table></figure></p>
<h3 id="9-7-12-11-9-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive-drop"><a href="#9-7-12-11-9-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive-drop" class="headerlink" title="9.7.12.11.9. Parallel Synchronization and Communication Instructions: mbarrier.arrive_drop"></a>9.7.12.11.9. Parallel Synchronization and Communication Instructions: mbarrier.arrive_drop</h3><p><strong>mbarrier.arrive_drop</strong><br>Decrements <strong>the expected count</strong> of the mbarrier object and performs <strong>arrive-on operation</strong>.</p>
<p><strong>Syntax</strong><br><code>mbarrier.arrive_drop&#123;.shared&#125;.b64 state, [addr];</code><br><code>mbarrier.arrive_drop.noComplete&#123;.shared&#125;.b64 state, [addr], count;</code></p>
<p><strong>Description</strong><br>A thread executing <code>mbarrier.arrive_drop</code> on the mbarrier object at the location specified by the address operand <code>addr</code> performs the following steps:</p>
<ul>
<li>Decrements <strong>the expected arrival count</strong> of the mbarrier object by the value specified by the 32-bit integer operand <code>count</code>. If count operand is not specified, it defaults to 1.</li>
<li>Performs <strong>an arrive-on operation</strong> on the mbarrier object. The operand <code>count</code> specifies the <code>count</code> argument to the arrive-on operation.</li>
</ul>
<p><strong>The decrement done in the expected arrivals count of the mbarrier object will be for all the subsequent phases of the mbarrier object.</strong><br>调用mbarrier.arrive_drop后，使得the expected arrival count永久减少，这对后续phases均产生影响。</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p>When the argument count is specified, the modifier .noComplete is required. A mbarrier.arrive_drop with .noComplete qualifier must not complete the mbarrier, otherwise the behavior is undefined.<br>这个特性与arrive相同，指定了count后需要添加说明符<code>.noComplete</code>，且此操作不能完成当前阶段，否则导致undefined behavior。</p>
<p>The value of the operand count must be in the range as specified in Contents of the mbarrier object.</p>
<p>A thread that wants to either <strong>exit</strong> or opt (选择) <strong>out of participating</strong> in the arrive-on operation can use <code>mbarrier.arrive_drop</code> to drop itself from the mbarrier.<br>必须先arrive-on之后才能drop！因为当前mbarrier的the expected arrival count是包含此线程的，换句话说mbarrier在期待此线程arrive-on，如果没有arrive-on直接drop，会使得mbarrier永远等不到此线程导致死锁。</p>
<p><code>mbarrier.arrive_drop</code> returns <strong>an opaque 64-bit register capturing the phase of the mbarrier object prior to the arrive-on operation</strong> in the destination operand <code>state</code>. Contents of the returned <code>state</code> are implementation specific. Optionally, sink symbol ‘_’ can be used for the state argument.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.reg .b64 %r1;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">@p mbarrier.arrive_drop.shared.b64 _, [shMem];</span><br><span class="line">@p exit;</span><br><span class="line">@p2 mbarrier.arrive_drop.noComplete.shared.b64 _, [shMem], %a;</span><br><span class="line">// 指定了count，因此添加了.noComplete</span><br><span class="line">@p2 exit;</span><br><span class="line">..</span><br><span class="line">@!p mbarrier.arrive.shared.b64   %r1, [shMem];</span><br><span class="line">@!p mbarrier.test_wait.shared.b64  q, [shMem], %r1;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-10-Parallel-Synchronization-and-Communication-Instructions-cp-async-mbarrier-arrive"><a href="#9-7-12-11-10-Parallel-Synchronization-and-Communication-Instructions-cp-async-mbarrier-arrive" class="headerlink" title="9.7.12.11.10. Parallel Synchronization and Communication Instructions: cp.async.mbarrier.arrive"></a>9.7.12.11.10. Parallel Synchronization and Communication Instructions: cp.async.mbarrier.arrive</h3><p><strong>cp.async.mbarrier.arrive</strong><br>Makes the mbarrier object track <strong>all prior <code>cp.async</code> operations initiated by the executing thread</strong>.<br>追踪执行线程先前所有的<code>cp.async</code> operations。</p>
<p><strong>Syntax</strong><br><code>cp.async.mbarrier.arrive&#123;.noinc&#125;&#123;.shared&#125;.b64 [addr];</code></p>
<p><strong>Description</strong><br>Causes an arrive-on operation to be triggered by the system on the mbarrier object upon <strong>the completion of all prior cp.async operations initiated by the executing thread</strong>. The mbarrier object is at the location specified by the operand <code>addr</code>. The arrive-on operation is asynchronous to execution of cp.async.mbarrier.arrive.</p>
<p>When <code>.noinc</code> modifier is not specified, <strong>the pending count of the mbarrier object is incremented by 1 prior to the asynchronous arrive-on operation</strong>. This results in a zero-net change for the pending count from the asynchronous arrive-on operation during the current phase. The pending count of the mbarrier object after the increment should not exceed the limit as mentioned in Contents of the mbarrier object. Otherwise, the behavior is undefined.</p>
<p>When the <code>.noinc</code> modifier is specified, <strong>the increment to the pending count of the mbarrier object is not performed</strong>. Hence the decrement of the pending count done by the asynchronous arrive-on operation must be accounted for in the initialization of the mbarrier object.</p>
<blockquote>
<p>由于线程的arrive-on与cp.async的asynchronous arrive-on均会导致the pending arrival count减少。因此cp.async.mbarrier.arrive额外增加了一个<code>.noinc</code>修饰符，当不添加这个修饰符时，cp.async.mbarrier.arrive操作默认会在asynchronous arrive-on操作前先将the pending count + 1，这样在初始化mbarrier时，就不需要额外计算asynchronous arrive-on的数量，再将这个数量加到the expected arrival count中了。如果不指定<code>.noinc</code>修饰符，那么cp.async.mbarrier.arrive就不会在asynchronous arrive-on操作前对the pending count + 1，那么在mbarrier初始化的时候，就需要额外考虑由the asynchronous arrive-on operation带来的the pending count的减少。</p>
</blockquote>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Example 1: no .noinc</span><br><span class="line">mbarrier.init.shared.b64 [shMem], threadCount;</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard1], [gbl1], 4;</span><br><span class="line">cp.async.cg.shared.global [shard2], [gbl2], 16;</span><br><span class="line">// 这里initiate了两次cp.async异步数据拷贝操作</span><br><span class="line">....</span><br><span class="line">// Absence of .noinc accounts for arrive-on from completion of prior cp.async operations.</span><br><span class="line">// So mbarrier.init must only account for arrive-on from mbarrier.arrive.</span><br><span class="line">// 不添加.noinc modifier使得由completion of prior cp.async operations带来的arrive-on操作不被计数，因此mbarrier.init只需要考虑由mbarrier.arrive所带来的arrive-on即可。</span><br><span class="line"></span><br><span class="line">cp.async.mbarrier.arrive.shared.b64 [shMem];</span><br><span class="line">// 这里不会导致the pending count - 1</span><br><span class="line">....</span><br><span class="line">mbarrier.arrive.shared.b64 state, [shMem];</span><br><span class="line">// 这里会导致the pending count - 1</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64 p, [shMem], state;</span><br><span class="line">@!p bra waitLoop;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Example 2: with .noinc</span><br><span class="line">// Tracks arrive-on from mbarrier.arrive and cp.async.mbarrier.arrive.</span><br><span class="line">// 添加了 .noinc modifier，此时需要追踪来自mbarrier.arrive与cp.async.mbarrier.arrive所带来的arrive-on操作</span><br><span class="line"></span><br><span class="line">// All threads participating in the mbarrier perform cp.async</span><br><span class="line">mov.b32 copyOperationCnt, threadCount;</span><br><span class="line">// copyOperationCnt = threadCount</span><br><span class="line"></span><br><span class="line">// 3 arrive-on operations will be triggered per-thread</span><br><span class="line">mul.lo.u32 copyArrivalCnt, copyOperationCnt, 3;</span><br><span class="line">// copyArrivalCnt = copyOperationCnt * 3</span><br><span class="line"></span><br><span class="line">add.u32 totalCount, threadCount, copyArrivalCnt;</span><br><span class="line">// totalCount = threadCount + copyArrivalCnt</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem], totalCount;</span><br><span class="line">// 这里初始化时给定的the expected arrival count既考虑了mbarrier.arrival，也考虑了cp.async.mbarrier.arrival所带来的arrive-on</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard1], [gbl1], 4;</span><br><span class="line">cp.async.cg.shared.global [shard2], [gbl2], 16;</span><br><span class="line">// 每个线程initiate两次cp.async操作</span><br><span class="line">...</span><br><span class="line">// Presence of .noinc requires mbarrier initalization to have accounted for arrive-on from cp.async</span><br><span class="line">cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 1st instance</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard3], [gbl3], 4;</span><br><span class="line">cp.async.ca.shared.global [shard4], [gbl4], 16;</span><br><span class="line">cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 2nd instance</span><br><span class="line">....</span><br><span class="line">cp.async.ca.shared.global [shard5], [gbl5], 4;</span><br><span class="line">cp.async.cg.shared.global [shard6], [gbl6], 16;</span><br><span class="line">cp.async.mbarrier.arrive.noinc.shared.b64 [shMem]; // 3rd and last instance</span><br><span class="line">....</span><br><span class="line">mbarrier.arrive.shared.b64 state, [shMem];</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64 p, [shMem], state;</span><br><span class="line">@!p bra waitLoop;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier-test-wait"><a href="#9-7-12-11-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier-test-wait" class="headerlink" title="9.7.12.11.11. Parallel Synchronization and Communication Instructions: mbarrier.test_wait"></a>9.7.12.11.11. Parallel Synchronization and Communication Instructions: mbarrier.test_wait</h3><p><strong>mbarrier.test_wait</strong><br>Checks whether the mbarrier object has completed the phase.<br>检测当前phase是否已经完成</p>
<p><strong>Syntax</strong><br><code>mbarrier.test_wait&#123;.shared&#125;.b64 waitComplete, [addr], state;</code><br><code>mbarrier.test_wait.parity&#123;.shared&#125;.b64 waitComplete, [addr], phaseParity;</code></p>
<p><strong>Description</strong><br>The <strong>test_wait</strong> operation tests for <strong>the completion of the current or the immediately preceding phase</strong> of an mbarrier object at the location specified by the operand <code>addr</code>. The test_wait operation <strong>does not block</strong> the executing thread.</p>
<ul>
<li>如果执行到此处时，当前phase还未完成，那么部份先到达的线程执行test_wait后等待，test_wait检查当前phase是否完成，如果完成就unblock这部分等待的线程。</li>
<li>如果执行到此处时，当前phase已经完成，the pending arrival count已经降至0，那么test_wait就不会阻塞这部分线程</li>
</ul>
<p><code>mbarrier.test_wait</code> instruction tests for the completion of <strong>the phase specified by the operand <code>state</code></strong>, which was <strong>returned by an <code>mbarrier.arrive</code> instruction</strong> on the same mbarrier object during the current or the immediately preceding phase.</p>
<p><code>mbarrier.test_wait.parity</code> instruction tests for the completion of <strong>the phase indicated by the operand <code>phaseParity</code></strong>, which is the integer parity (整型奇偶校验) of either the current phase or the immediately preceding phase of the mbarrier object. An even phase (偶数phase) has <strong>integer parity 0</strong> and an odd phase (奇数phase) has <strong>integer parity of 1</strong>. So the valid values of phaseParity operand are 0 and 1.</p>
<p>Note: the use of the mbarrier.test_wait.parity requires tracking the phase of an mbarrier object throughout its lifetime.</p>
<p>The test_wait operations are valid only for :</p>
<ul>
<li>the current incomplete phase, for which <code>waitComplete</code> returns False.</li>
<li>the immediately preceding phase, for which <code>waitComplete</code> returns True.<blockquote>
<p>这里指的是由state指定的phase是the current incomplete phase还是the immediately preceding phase</p>
</blockquote>
</li>
</ul>
<p>For each phase of the mbarrier object, at least one test_wait operation must be performed which returns True for <code>waitComplete</code> before an arrive-on operation in the subsequent phase.</p>
<p>If no state space is specified then Generic Addressing is used. If the address specified by addr does not fall within the address window of .shared state space then the behavior is undefined.</p>
<p>Supported addressing modes for operand addr is as described in Addresses as Operands. Alignment for operand addr is as described in the Size and alignment of mbarrier object.</p>
<p>The following ordering of memory operations hold for the executing thread when mbarrier.test_wait returns True (表征当前phase已完成) :</p>
<ol>
<li>All memory accesses (except cp.async ) requested prior, in program order, to <code>mbarrier.arrive</code> during the completed phase are performed and are <strong>visible to the executing thread</strong>.</li>
<li>All <code>cp.async</code> operations requested prior, in program order, to <code>cp.async.mbarrier.arrive</code> during the completed phase are performed and made <strong>visible to the executing thread</strong>.<br>arrive之前的所有访存对执行线程可见</li>
<li>All memory accesses requested <strong>after</strong> the mbarrier.test_wait, in program order, are <strong>not performed</strong> and <strong>not visible</strong> to memory accesses performed prior to mbarrier.arrive, in program order, by other threads participating in the mbarrier.<br>本线程test_wait之后的访存，对其他参与到mbarrier的线程在arrive之前的访存不可见</li>
<li>There is no ordering and visibility guarantee for memory accesses requested by the thread <strong>after <code>mbarrier.arrive</code> and prior to <code>mbarrier.test_wait</code></strong>, in program order.<br>arrive与test_wait之间的访存顺序与可见性没有保证</li>
</ol>
<p>相当于具有一个arrive之前与test_wait之后的memory fence，且这个memory fence对cp.async这种异步拷贝操作有效。</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p>Modifier .parity is introduced in PTX ISA version 7.1.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Example 1, thread synchronization :</span><br><span class="line">// block内参与mbarrier线程的同步</span><br><span class="line"></span><br><span class="line">.reg .b64 %r1;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem], N;  // N threads participating in the mbarrier.</span><br><span class="line">...</span><br><span class="line">mbarrier.arrive.shared.b64  %r1, [shMem]; // N threads executing mbarrier.arrive</span><br><span class="line"></span><br><span class="line">// computation not requiring mbarrier synchronization...</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64    complete, [shMem], %r1;</span><br><span class="line">@!complete nanosleep.u32 20;</span><br><span class="line">@!complete bra waitLoop;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Example 2, thread synchronization using phase parity :</span><br><span class="line">// 使用phase奇偶校验的线程同步</span><br><span class="line"></span><br><span class="line">.reg .b32 i, parArg;</span><br><span class="line">.reg .b64 %r1;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">mov.b32 i, 0;</span><br><span class="line">mbarrier.init.shared.b64 [shMem], N;  // N threads participating in the mbarrier.</span><br><span class="line">...</span><br><span class="line">loopStart :                           // One phase per loop iteration</span><br><span class="line">    ...</span><br><span class="line">    mbarrier.arrive.shared.b64  %r1, [shMem]; // N threads</span><br><span class="line">    ...</span><br><span class="line">    and.b32 parArg, i, 1;</span><br><span class="line">    waitLoop:</span><br><span class="line">    mbarrier.test_wait.parity.shared.b64  complete, [shMem], parArg;</span><br><span class="line">    @!complete nanosleep.u32 20;</span><br><span class="line">    @!complete bra waitLoop;</span><br><span class="line">    ...</span><br><span class="line">    add.u32 i, i, 1;</span><br><span class="line">    setp.lt.u32 p, i, IterMax;</span><br><span class="line">@p bra loopStart;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Example 3, Asynchronous copy completion waiting :</span><br><span class="line">// 等待异步数据传输完成</span><br><span class="line"></span><br><span class="line">.reg .b64 state;</span><br><span class="line">.shared .b64 shMem2;</span><br><span class="line">.shared .b64 shard1, shard2;</span><br><span class="line">.global .b64 gbl1, gbl2;</span><br><span class="line"></span><br><span class="line">mbarrier.init.shared.b64 [shMem2], threadCount;</span><br><span class="line">...</span><br><span class="line">cp.async.ca.shared.global [shard1], [gbl1], 4;</span><br><span class="line">cp.async.cg.shared.global [shard2], [gbl2], 16;</span><br><span class="line"></span><br><span class="line">// Absence of .noinc accounts for arrive-on from prior cp.async operation</span><br><span class="line">// 没添加.noinc modifier，因此初始化mbarrier时无需考虑cp.async导致的arrive-on</span><br><span class="line">cp.async.mbarrier.arrive.shared.b64 [shMem2];</span><br><span class="line">...</span><br><span class="line">mbarrier.arrive.shared.b64 state, [shMem2];</span><br><span class="line"></span><br><span class="line">waitLoop:</span><br><span class="line">mbarrier.test_wait.shared.b64 p, [shMem2], state;</span><br><span class="line">@!p bra waitLoop;</span><br></pre></td></tr></table></figure>
<h3 id="9-7-12-11-12-Parallel-Synchronization-and-Communication-Instructions-mbarrier-pending-count"><a href="#9-7-12-11-12-Parallel-Synchronization-and-Communication-Instructions-mbarrier-pending-count" class="headerlink" title="9.7.12.11.12. Parallel Synchronization and Communication Instructions: mbarrier.pending_count"></a>9.7.12.11.12. Parallel Synchronization and Communication Instructions: mbarrier.pending_count</h3><blockquote>
<p>按照 <a target="_blank" rel="noopener" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#memory_barrier_primitives_interface">CUDA C++ Programming Guide</a> 的说法，这个对应于函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> __mbarrier_pending_count(<span class="type">__mbarrier_token_t</span> token);</span><br></pre></td></tr></table></figure><br>此函数从CUDA 11.1开始被弃用了</p>
</blockquote>
<p><strong>mbarrier.pending_count</strong><br>Query <strong>the pending arrival count</strong> from the opaque mbarrier state.<br>查询当前mbarrier的the pending arrival count</p>
<p><strong>Syntax</strong><br><code>mbarrier.pending_count.b64 count, state;</code><br>// 输入state对应的mbarrier phase，由参数count返回当前phase的the pending arrival count</p>
<p><strong>Description</strong><br>The pending count can be queried from the opaque mbarrier state using mbarrier.pending_count.</p>
<p>The <code>state</code> operand is a 64-bit register that must be <strong>the result of a prior mbarrier.arrive.noComplete or mbarrier.arrive_drop.noComplete instruction</strong>. Otherwise, the behavior is undefined.<br>要求arrive操作必须带有.noComplete说明符，意味着对应的arrive操作中count没有使用默认的1，而是人为指定的，且这个arrive操作不能导致当前phase complete。</p>
<p>The destination register <code>count</code> is a 32-bit unsigned integer representing the pending count of the mbarrier object <strong>prior to the arrive-on operation from which the <code>state</code> register was obtained</strong>.<br>返回的不是调用mbarrier.pending_count时的the pending count，而是传入参数state所对应的arrive-on操作之前的the pending count。</p>
<p><strong>PTX ISA Notes</strong><br>Introduced in PTX ISA version 7.0.</p>
<p><strong>Target ISA Notes</strong><br>Requires <strong>sm_80</strong> or higher.</p>
<p><strong>Examples</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.reg .b32 %r1;</span><br><span class="line">.reg .b64 state;</span><br><span class="line">.shared .b64 shMem;</span><br><span class="line"></span><br><span class="line">mbarrier.arrive.noComplete.b64 state, [shMem], 1;</span><br><span class="line">mbarrier.pending_count.b64 %r1, state;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/06/23/Git/" rel="prev" title="Git">
      <i class="fa fa-chevron-left"></i> Git
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/07/VSCode-MarkDown-Hexo-Blog/" rel="next" title="VSCode_MarkDown_Hexo_Blog">
      VSCode_MarkDown_Hexo_Blog <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CUDA%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B07-B-25-Asynchronous-Barrier"><span class="nav-number">1.</span> <span class="nav-text">CUDA学习随记7 B.25. Asynchronous Barrier</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CUDA-C-Programming-Guide-B-25-Asynchronous-Barrier"><span class="nav-number">1.1.</span> <span class="nav-text">CUDA C++ Programming Guide: B.25. Asynchronous Barrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5barrier"><span class="nav-number">1.2.</span> <span class="nav-text">异步barrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-1-Simple-Synchronization-Pattern-%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">B.25.1. Simple Synchronization Pattern 简单同步模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-2-Temporal-Splitting-and-Five-Stages-of-Synchronization-%E6%97%B6%E9%97%B4%E5%88%86%E5%89%B2%E5%90%8C%E6%AD%A5-%E4%B8%8E-%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BA%94%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">1.2.2.</span> <span class="nav-text">B.25.2. Temporal Splitting and Five Stages of Synchronization 时间分割同步 与 同步的五个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-3-Bootstrap-Initialization-Expected-Arrival-Count-and-Participation-%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%81%E9%A2%84%E6%9C%9F%E5%88%B0%E8%BE%BE%E8%AE%A1%E6%95%B0%E3%80%81%E5%8F%82%E4%B8%8E%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">B.25.3. Bootstrap Initialization, Expected Arrival Count, and Participation 初始化、预期到达计数、参与性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-4-A-Barrier%E2%80%99s-Phase-Arrival-Countdown-Completion-and-Reset-Barrier%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9A%E5%88%B0%E8%BE%BE%E3%80%81%E5%80%92%E8%AE%A1%E6%97%B6%E3%80%81%E5%AE%8C%E6%88%90%E3%80%81%E9%87%8D%E7%BD%AE"><span class="nav-number">1.2.4.</span> <span class="nav-text">B.25.4. A Barrier’s Phase: Arrival, Countdown, Completion, and Reset Barrier的四种状态：到达、倒计时、完成、重置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-5-Spatial-Partitioning-also-known-as-Warp-Specialization-%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86-warp%E4%B8%93%E7%94%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">B.25.5. Spatial Partitioning (also known as Warp Specialization)  空间划分 (warp专用)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-6-Early-Exit-Dropping-out-of-Participation-%E6%97%A9%E9%80%80%EF%BC%8C%E6%8F%90%E5%89%8D%E9%80%80%E5%87%BAbarrier"><span class="nav-number">1.2.6.</span> <span class="nav-text">B.25.6. Early Exit (Dropping out of Participation) 早退，提前退出barrier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-25-7-Memory-Barrier-Primitives-Interface-%E5%86%85%E5%AD%98barrier%E5%8E%9F%E8%AF%AD%E6%8E%A5%E5%8F%A3-mbarrier"><span class="nav-number">1.2.7.</span> <span class="nav-text">B.25.7. Memory Barrier Primitives Interface  内存barrier原语接口 (mbarrier)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-25-7-1-Data-Types-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">B.25.7.1. Data Types 数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-25-7-2-Memory-Barrier-Primitives-API-%E5%8E%9F%E8%AF%ADAPI"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">B.25.7.2. Memory Barrier Primitives API 原语API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PTX-ISA-9-7-12-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier"><span class="nav-number">1.3.</span> <span class="nav-text">PTX ISA: 9.7.12.11. Parallel Synchronization and Communication Instructions: mbarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E8%AE%AF%E6%8C%87%E4%BB%A4%EF%BC%9Ambarrier"><span class="nav-number">1.4.</span> <span class="nav-text">并行同步通讯指令：mbarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-1-Size-and-alignment-of-mbarrier-object"><span class="nav-number">1.4.1.</span> <span class="nav-text">9.7.12.11.1. Size and alignment of mbarrier object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-2-Contents-of-the-mbarrier-object"><span class="nav-number">1.4.2.</span> <span class="nav-text">9.7.12.11.2. Contents of the mbarrier object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-3-Lifecycle-of-the-mbarrier-object"><span class="nav-number">1.4.3.</span> <span class="nav-text">9.7.12.11.3. Lifecycle of the mbarrier object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-4-Phase-of-the-mbarrier-object"><span class="nav-number">1.4.4.</span> <span class="nav-text">9.7.12.11.4. Phase of the mbarrier object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-5-Arrive-on-operation-on-mbarrier-object"><span class="nav-number">1.4.5.</span> <span class="nav-text">9.7.12.11.5. Arrive-on operation on mbarrier object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-6-Parallel-Synchronization-and-Communication-Instructions-mbarrier-init"><span class="nav-number">1.4.6.</span> <span class="nav-text">9.7.12.11.6. Parallel Synchronization and Communication Instructions: mbarrier.init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-7-Parallel-Synchronization-and-Communication-Instructions-mbarrier-inval"><span class="nav-number">1.4.7.</span> <span class="nav-text">9.7.12.11.7. Parallel Synchronization and Communication Instructions: mbarrier.inval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-8-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive"><span class="nav-number">1.4.8.</span> <span class="nav-text">9.7.12.11.8. Parallel Synchronization and Communication Instructions: mbarrier.arrive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-9-Parallel-Synchronization-and-Communication-Instructions-mbarrier-arrive-drop"><span class="nav-number">1.4.9.</span> <span class="nav-text">9.7.12.11.9. Parallel Synchronization and Communication Instructions: mbarrier.arrive_drop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-10-Parallel-Synchronization-and-Communication-Instructions-cp-async-mbarrier-arrive"><span class="nav-number">1.4.10.</span> <span class="nav-text">9.7.12.11.10. Parallel Synchronization and Communication Instructions: cp.async.mbarrier.arrive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-11-Parallel-Synchronization-and-Communication-Instructions-mbarrier-test-wait"><span class="nav-number">1.4.11.</span> <span class="nav-text">9.7.12.11.11. Parallel Synchronization and Communication Instructions: mbarrier.test_wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7-12-11-12-Parallel-Synchronization-and-Communication-Instructions-mbarrier-pending-count"><span class="nav-number">1.4.12.</span> <span class="nav-text">9.7.12.11.12. Parallel Synchronization and Communication Instructions: mbarrier.pending_count</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiang Shao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiang Shao</p>
  <div class="site-description" itemprop="description">WeChat: shaojiang9650<br>Email: shao_study@163.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Shao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
